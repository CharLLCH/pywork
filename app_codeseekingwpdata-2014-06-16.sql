-- phpMyAdmin SQL Dump
-- version 3.3.8.1
-- http://www.phpmyadmin.net
--
-- 主机: w.rdc.sae.sina.com.cn:3307
-- 生成日期: 2014 年 06 月 16 日 14:23
-- 服务器版本: 5.5.23
-- PHP 版本: 5.3.3

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `app_codeseeking`
--

-- --------------------------------------------------------

--
-- 表的结构 `wp_commentmeta`
--

CREATE TABLE IF NOT EXISTS `wp_commentmeta` (
  `meta_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `comment_id` bigint(20) unsigned NOT NULL DEFAULT '0',
  `meta_key` varchar(255) DEFAULT NULL,
  `meta_value` longtext,
  PRIMARY KEY (`meta_id`),
  KEY `comment_id` (`comment_id`),
  KEY `meta_key` (`meta_key`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;

--
-- 转存表中的数据 `wp_commentmeta`
--


-- --------------------------------------------------------

--
-- 表的结构 `wp_comments`
--

CREATE TABLE IF NOT EXISTS `wp_comments` (
  `comment_ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `comment_post_ID` bigint(20) unsigned NOT NULL DEFAULT '0',
  `comment_author` tinytext NOT NULL,
  `comment_author_email` varchar(100) NOT NULL DEFAULT '',
  `comment_author_url` varchar(200) NOT NULL DEFAULT '',
  `comment_author_IP` varchar(100) NOT NULL DEFAULT '',
  `comment_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `comment_date_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `comment_content` text NOT NULL,
  `comment_karma` int(11) NOT NULL DEFAULT '0',
  `comment_approved` varchar(20) NOT NULL DEFAULT '1',
  `comment_agent` varchar(255) NOT NULL DEFAULT '',
  `comment_type` varchar(20) NOT NULL DEFAULT '',
  `comment_parent` bigint(20) unsigned NOT NULL DEFAULT '0',
  `user_id` bigint(20) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`comment_ID`),
  KEY `comment_approved` (`comment_approved`),
  KEY `comment_post_ID` (`comment_post_ID`),
  KEY `comment_approved_date_gmt` (`comment_approved`,`comment_date_gmt`),
  KEY `comment_date_gmt` (`comment_date_gmt`),
  KEY `comment_parent` (`comment_parent`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

--
-- 转存表中的数据 `wp_comments`
--

INSERT INTO `wp_comments` (`comment_ID`, `comment_post_ID`, `comment_author`, `comment_author_email`, `comment_author_url`, `comment_author_IP`, `comment_date`, `comment_date_gmt`, `comment_content`, `comment_karma`, `comment_approved`, `comment_agent`, `comment_type`, `comment_parent`, `user_id`) VALUES
(1, 1, 'WordPress 先生', '', 'http://wordpress.org/', '', '2012-10-15 06:34:07', '2012-10-15 06:34:07', '嗨，这是一条评论。<br />要删除一条评论，请先登录，然后再查看这篇文章的评论。在那里，您可以看到编辑或者删除评论的选项。', 0, 'post-trashed', '', '', 0, 0),
(2, 5, 'cc', 'charleytemp@163.com', '', '221.2.164.21', '2012-10-15 07:03:27', '2012-10-15 07:03:27', 'test', 0, 'post-trashed', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.15 Safari/537.1', '', 0, 1);

-- --------------------------------------------------------

--
-- 表的结构 `wp_links`
--

CREATE TABLE IF NOT EXISTS `wp_links` (
  `link_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `link_url` varchar(255) NOT NULL DEFAULT '',
  `link_name` varchar(255) NOT NULL DEFAULT '',
  `link_image` varchar(255) NOT NULL DEFAULT '',
  `link_target` varchar(25) NOT NULL DEFAULT '',
  `link_description` varchar(255) NOT NULL DEFAULT '',
  `link_visible` varchar(20) NOT NULL DEFAULT 'Y',
  `link_owner` bigint(20) unsigned NOT NULL DEFAULT '1',
  `link_rating` int(11) NOT NULL DEFAULT '0',
  `link_updated` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `link_rel` varchar(255) NOT NULL DEFAULT '',
  `link_notes` mediumtext NOT NULL,
  `link_rss` varchar(255) NOT NULL DEFAULT '',
  PRIMARY KEY (`link_id`),
  KEY `link_visible` (`link_visible`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

--
-- 转存表中的数据 `wp_links`
--

INSERT INTO `wp_links` (`link_id`, `link_url`, `link_name`, `link_image`, `link_target`, `link_description`, `link_visible`, `link_owner`, `link_rating`, `link_updated`, `link_rel`, `link_notes`, `link_rss`) VALUES
(1, 'http://wp4sae.sinaapp.com/', 'WordPress for SAE', '', '', '', 'Y', 1, 0, '0000-00-00 00:00:00', '', '', 'http://wp4sae.sinaapp.com/feed/'),
(2, 'http://wordpress.org/news/', 'WordPress Blog', '', '', '', 'Y', 1, 0, '0000-00-00 00:00:00', '', '', 'http://wordpress.org/news/feed/');

-- --------------------------------------------------------

--
-- 表的结构 `wp_options`
--

CREATE TABLE IF NOT EXISTS `wp_options` (
  `option_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `blog_id` int(11) NOT NULL DEFAULT '0',
  `option_name` varchar(64) NOT NULL DEFAULT '',
  `option_value` longtext NOT NULL,
  `autoload` varchar(20) NOT NULL DEFAULT 'yes',
  PRIMARY KEY (`option_id`),
  UNIQUE KEY `option_name` (`option_name`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=145 ;

--
-- 转存表中的数据 `wp_options`
--

INSERT INTO `wp_options` (`option_id`, `blog_id`, `option_name`, `option_value`, `autoload`) VALUES
(1, 0, 'siteurl', 'http://codeseeking.sinaapp.com', 'yes'),
(2, 0, 'blogname', '寻找CODE', 'yes'),
(3, 0, 'blogdescription', 'coding', 'yes'),
(4, 0, 'users_can_register', '0', 'yes'),
(5, 0, 'admin_email', 'charleytemp@163.com', 'yes'),
(6, 0, 'start_of_week', '1', 'yes'),
(7, 0, 'use_balanceTags', '0', 'yes'),
(8, 0, 'use_smilies', '1', 'yes'),
(9, 0, 'require_name_email', '1', 'yes'),
(10, 0, 'comments_notify', '1', 'yes'),
(11, 0, 'posts_per_rss', '10', 'yes'),
(12, 0, 'rss_use_excerpt', '0', 'yes'),
(13, 0, 'mailserver_url', 'mail.example.com', 'yes'),
(14, 0, 'mailserver_login', 'login@example.com', 'yes'),
(15, 0, 'mailserver_pass', 'password', 'yes'),
(16, 0, 'mailserver_port', '110', 'yes'),
(17, 0, 'default_category', '1', 'yes'),
(18, 0, 'default_comment_status', 'open', 'yes'),
(19, 0, 'default_ping_status', 'open', 'yes'),
(20, 0, 'default_pingback_flag', '1', 'yes'),
(21, 0, 'default_post_edit_rows', '20', 'yes'),
(22, 0, 'posts_per_page', '10', 'yes'),
(23, 0, 'date_format', 'm/d/Y', 'yes'),
(24, 0, 'time_format', 'H:i', 'yes'),
(25, 0, 'links_updated_date_format', 'Y 年 n 月 j 日a g:i', 'yes'),
(26, 0, 'links_recently_updated_prepend', '<em>', 'yes'),
(27, 0, 'links_recently_updated_append', '</em>', 'yes'),
(28, 0, 'links_recently_updated_time', '120', 'yes'),
(29, 0, 'comment_moderation', '1', 'yes'),
(30, 0, 'moderation_notify', '1', 'yes'),
(31, 0, 'permalink_structure', '', 'yes'),
(32, 0, 'gzipcompression', '0', 'yes'),
(33, 0, 'hack_file', '0', 'yes'),
(34, 0, 'blog_charset', 'UTF-8', 'yes'),
(35, 0, 'moderation_keys', '', 'no'),
(36, 0, 'active_plugins', 'a:1:{i:0;s:25:"wp-codebox/wp-codebox.php";}', 'yes'),
(37, 0, 'home', 'http://codeseeking.sinaapp.com', 'yes'),
(38, 0, 'category_base', '', 'yes'),
(39, 0, 'ping_sites', 'http://rpc.pingomatic.com/', 'yes'),
(40, 0, 'advanced_edit', '0', 'yes'),
(41, 0, 'comment_max_links', '2', 'yes'),
(42, 0, 'gmt_offset', '0', 'yes'),
(43, 0, 'default_email_category', '1', 'yes'),
(44, 0, 'recently_edited', '', 'no'),
(45, 0, 'template', 'flat', 'yes'),
(46, 0, 'stylesheet', 'flat', 'yes'),
(47, 0, 'comment_whitelist', '1', 'yes'),
(48, 0, 'blacklist_keys', '', 'no'),
(49, 0, 'comment_registration', '1', 'yes'),
(50, 0, 'rss_language', 'en', 'yes'),
(51, 0, 'html_type', 'text/html', 'yes'),
(52, 0, 'use_trackback', '0', 'yes'),
(53, 0, 'default_role', 'subscriber', 'yes'),
(54, 0, 'db_version', '18226', 'yes'),
(55, 0, 'uploads_use_yearmonth_folders', '1', 'yes'),
(56, 0, 'upload_path', '', 'yes'),
(57, 0, 'blog_public', '1', 'yes'),
(58, 0, 'default_link_category', '2', 'yes'),
(59, 0, 'show_on_front', 'posts', 'yes'),
(60, 0, 'tag_base', '', 'yes'),
(61, 0, 'show_avatars', '1', 'yes'),
(62, 0, 'avatar_rating', 'G', 'yes'),
(63, 0, 'upload_url_path', '', 'yes'),
(64, 0, 'thumbnail_size_w', '150', 'yes'),
(65, 0, 'thumbnail_size_h', '150', 'yes'),
(66, 0, 'thumbnail_crop', '1', 'yes'),
(67, 0, 'medium_size_w', '300', 'yes'),
(68, 0, 'medium_size_h', '300', 'yes'),
(69, 0, 'avatar_default', 'gravatar_default', 'yes'),
(70, 0, 'enable_app', '0', 'yes'),
(71, 0, 'enable_xmlrpc', '0', 'yes'),
(72, 0, 'large_size_w', '1024', 'yes'),
(73, 0, 'large_size_h', '1024', 'yes'),
(74, 0, 'image_default_link_type', 'file', 'yes'),
(75, 0, 'image_default_size', '', 'yes'),
(76, 0, 'image_default_align', '', 'yes'),
(77, 0, 'close_comments_for_old_posts', '1', 'yes'),
(78, 0, 'close_comments_days_old', '3', 'yes'),
(79, 0, 'thread_comments', '1', 'yes'),
(80, 0, 'thread_comments_depth', '5', 'yes'),
(81, 0, 'page_comments', '', 'yes'),
(82, 0, 'comments_per_page', '50', 'yes'),
(83, 0, 'default_comments_page', 'newest', 'yes'),
(84, 0, 'comment_order', 'asc', 'yes'),
(85, 0, 'sticky_posts', 'a:0:{}', 'yes'),
(86, 0, 'widget_categories', 'a:3:{i:2;a:4:{s:5:"title";s:0:"";s:5:"count";i:0;s:12:"hierarchical";i:0;s:8:"dropdown";i:0;}i:3;a:4:{s:5:"title";s:0:"";s:5:"count";i:1;s:12:"hierarchical";i:1;s:8:"dropdown";i:0;}s:12:"_multiwidget";i:1;}', 'yes'),
(87, 0, 'widget_text', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(88, 0, 'widget_rss', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(89, 0, 'timezone_string', '', 'yes'),
(90, 0, 'embed_autourls', '1', 'yes'),
(91, 0, 'embed_size_w', '', 'yes'),
(92, 0, 'embed_size_h', '600', 'yes'),
(93, 0, 'page_for_posts', '0', 'yes'),
(94, 0, 'page_on_front', '0', 'yes'),
(95, 0, 'default_post_format', '0', 'yes'),
(96, 0, 'wp_user_roles', 'a:5:{s:13:"administrator";a:2:{s:4:"name";s:13:"Administrator";s:12:"capabilities";a:62:{s:13:"switch_themes";b:1;s:11:"edit_themes";b:1;s:16:"activate_plugins";b:1;s:12:"edit_plugins";b:1;s:10:"edit_users";b:1;s:10:"edit_files";b:1;s:14:"manage_options";b:1;s:17:"moderate_comments";b:1;s:17:"manage_categories";b:1;s:12:"manage_links";b:1;s:12:"upload_files";b:1;s:6:"import";b:1;s:15:"unfiltered_html";b:1;s:10:"edit_posts";b:1;s:17:"edit_others_posts";b:1;s:20:"edit_published_posts";b:1;s:13:"publish_posts";b:1;s:10:"edit_pages";b:1;s:4:"read";b:1;s:8:"level_10";b:1;s:7:"level_9";b:1;s:7:"level_8";b:1;s:7:"level_7";b:1;s:7:"level_6";b:1;s:7:"level_5";b:1;s:7:"level_4";b:1;s:7:"level_3";b:1;s:7:"level_2";b:1;s:7:"level_1";b:1;s:7:"level_0";b:1;s:17:"edit_others_pages";b:1;s:20:"edit_published_pages";b:1;s:13:"publish_pages";b:1;s:12:"delete_pages";b:1;s:19:"delete_others_pages";b:1;s:22:"delete_published_pages";b:1;s:12:"delete_posts";b:1;s:19:"delete_others_posts";b:1;s:22:"delete_published_posts";b:1;s:20:"delete_private_posts";b:1;s:18:"edit_private_posts";b:1;s:18:"read_private_posts";b:1;s:20:"delete_private_pages";b:1;s:18:"edit_private_pages";b:1;s:18:"read_private_pages";b:1;s:12:"delete_users";b:1;s:12:"create_users";b:1;s:17:"unfiltered_upload";b:1;s:14:"edit_dashboard";b:1;s:14:"update_plugins";b:1;s:14:"delete_plugins";b:1;s:15:"install_plugins";b:1;s:13:"update_themes";b:1;s:14:"install_themes";b:1;s:11:"update_core";b:1;s:10:"list_users";b:1;s:12:"remove_users";b:1;s:9:"add_users";b:1;s:13:"promote_users";b:1;s:18:"edit_theme_options";b:1;s:13:"delete_themes";b:1;s:6:"export";b:1;}}s:6:"editor";a:2:{s:4:"name";s:6:"Editor";s:12:"capabilities";a:34:{s:17:"moderate_comments";b:1;s:17:"manage_categories";b:1;s:12:"manage_links";b:1;s:12:"upload_files";b:1;s:15:"unfiltered_html";b:1;s:10:"edit_posts";b:1;s:17:"edit_others_posts";b:1;s:20:"edit_published_posts";b:1;s:13:"publish_posts";b:1;s:10:"edit_pages";b:1;s:4:"read";b:1;s:7:"level_7";b:1;s:7:"level_6";b:1;s:7:"level_5";b:1;s:7:"level_4";b:1;s:7:"level_3";b:1;s:7:"level_2";b:1;s:7:"level_1";b:1;s:7:"level_0";b:1;s:17:"edit_others_pages";b:1;s:20:"edit_published_pages";b:1;s:13:"publish_pages";b:1;s:12:"delete_pages";b:1;s:19:"delete_others_pages";b:1;s:22:"delete_published_pages";b:1;s:12:"delete_posts";b:1;s:19:"delete_others_posts";b:1;s:22:"delete_published_posts";b:1;s:20:"delete_private_posts";b:1;s:18:"edit_private_posts";b:1;s:18:"read_private_posts";b:1;s:20:"delete_private_pages";b:1;s:18:"edit_private_pages";b:1;s:18:"read_private_pages";b:1;}}s:6:"author";a:2:{s:4:"name";s:6:"Author";s:12:"capabilities";a:10:{s:12:"upload_files";b:1;s:10:"edit_posts";b:1;s:20:"edit_published_posts";b:1;s:13:"publish_posts";b:1;s:4:"read";b:1;s:7:"level_2";b:1;s:7:"level_1";b:1;s:7:"level_0";b:1;s:12:"delete_posts";b:1;s:22:"delete_published_posts";b:1;}}s:11:"contributor";a:2:{s:4:"name";s:11:"Contributor";s:12:"capabilities";a:5:{s:10:"edit_posts";b:1;s:4:"read";b:1;s:7:"level_1";b:1;s:7:"level_0";b:1;s:12:"delete_posts";b:1;}}s:10:"subscriber";a:2:{s:4:"name";s:10:"Subscriber";s:12:"capabilities";a:2:{s:4:"read";b:1;s:7:"level_0";b:1;}}}', 'yes'),
(97, 0, 'widget_search', 'a:2:{i:2;a:1:{s:5:"title";s:0:"";}s:12:"_multiwidget";i:1;}', 'yes'),
(98, 0, 'widget_recent-posts', 'a:3:{i:2;a:2:{s:5:"title";s:0:"";s:6:"number";i:5;}i:3;a:2:{s:5:"title";s:0:"";s:6:"number";i:8;}s:12:"_multiwidget";i:1;}', 'yes'),
(99, 0, 'widget_recent-comments', 'a:2:{i:2;a:2:{s:5:"title";s:0:"";s:6:"number";i:5;}s:12:"_multiwidget";i:1;}', 'yes'),
(100, 0, 'widget_archives', 'a:2:{i:2;a:3:{s:5:"title";s:0:"";s:5:"count";i:0;s:8:"dropdown";i:0;}s:12:"_multiwidget";i:1;}', 'yes'),
(101, 0, 'widget_meta', 'a:3:{i:2;a:1:{s:5:"title";s:0:"";}i:4;a:1:{s:5:"title";s:0:"";}s:12:"_multiwidget";i:1;}', 'yes'),
(102, 0, 'sidebars_widgets', 'a:6:{s:19:"wp_inactive_widgets";a:13:{i:0;s:7:"pages-2";i:1;s:10:"calendar-2";i:2;s:7:"links-2";i:3;s:6:"text-2";i:4;s:5:"rss-2";i:5;s:11:"tag_cloud-2";i:6;s:10:"nav_menu-2";i:7;s:8:"search-2";i:8;s:14:"recent-posts-2";i:9;s:17:"recent-comments-2";i:10;s:10:"archives-2";i:11;s:12:"categories-2";i:12;s:6:"meta-2";}s:3:"top";a:1:{i:0;s:12:"categories-3";}s:4:"left";a:1:{i:0;s:14:"recent-posts-3";}s:5:"right";a:0:{}s:6:"bottom";a:1:{i:0;s:6:"meta-4";}s:13:"array_version";i:3;}', 'yes'),
(103, 0, 'cron', 'a:3:{i:1402900480;a:3:{s:16:"wp_version_check";a:1:{s:32:"40cd750bba9870f18aada2478b24840a";a:3:{s:8:"schedule";s:10:"twicedaily";s:4:"args";a:0:{}s:8:"interval";i:43200;}}s:17:"wp_update_plugins";a:1:{s:32:"40cd750bba9870f18aada2478b24840a";a:3:{s:8:"schedule";s:10:"twicedaily";s:4:"args";a:0:{}s:8:"interval";i:43200;}}s:16:"wp_update_themes";a:1:{s:32:"40cd750bba9870f18aada2478b24840a";a:3:{s:8:"schedule";s:10:"twicedaily";s:4:"args";a:0:{}s:8:"interval";i:43200;}}}i:1402900487;a:1:{s:19:"wp_scheduled_delete";a:1:{s:32:"40cd750bba9870f18aada2478b24840a";a:3:{s:8:"schedule";s:5:"daily";s:4:"args";a:0:{}s:8:"interval";i:86400;}}}s:7:"version";i:2;}', 'yes'),
(104, 0, 'widget_pages', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(105, 0, 'widget_calendar', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(106, 0, 'widget_links', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(107, 0, 'widget_tag_cloud', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(108, 0, 'widget_nav_menu', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(109, 0, 'widget_widget_twentyeleven_ephemera', 'a:2:{i:2;a:0:{}s:12:"_multiwidget";i:1;}', 'yes'),
(110, 0, 'zh_cn_language_pack_enable_backend_style_modifications', '1', 'yes'),
(111, 0, 'zh_cn_language_pack_enable_chinese_fake_oembed', '1', 'yes'),
(112, 0, 'dashboard_widget_options', 'a:3:{s:25:"dashboard_recent_comments";a:1:{s:5:"items";i:5;}s:24:"dashboard_incoming_links";a:5:{s:4:"home";s:30:"http://codeseeking.sinaapp.com";s:4:"link";s:106:"http://blogsearch.google.com/blogsearch?scoring=d&partner=wordpress&q=link:http://codeseeking.sinaapp.com/";s:3:"url";s:139:"http://blogsearch.google.com/blogsearch_feeds?scoring=d&ie=utf-8&num=10&output=rss&partner=wordpress&q=link:http://codeseeking.sinaapp.com/";s:5:"items";i:5;s:9:"show_date";i:1;}s:17:"dashboard_primary";a:7:{s:4:"link";s:26:"http://wp4sae.sinaapp.com/";s:3:"url";s:36:"http://wp4sae.sinaapp.com/?feed=rss2";s:5:"title";s:24:"WordPress for SAE 博客";s:5:"items";i:2;s:12:"show_summary";i:1;s:11:"show_author";i:1;s:9:"show_date";i:1;}}', 'yes'),
(115, 0, 'current_theme', 'FLAT', 'yes'),
(114, 0, 'can_compress_scripts', '1', 'yes'),
(116, 0, 'theme_mods_flat', 'a:1:{i:0;b:0;}', 'yes'),
(117, 0, 'contempo-notifier-cache', '<?xml version="1.0" encoding="UTF-8"?>\n<notifier>\n<latest>3.3</latest>\n<changelog>\n<![CDATA[\n<dl>\n <dt>ver3.3 2013/6/11</dt>\n <dd>Fixed theme_options.php file.</dd>\n <dt>ver3.2 2013/5/6</dt>\n <dd>Fixed update_notifier.php file.</dd>\n <dt>ver3.1 2012/12/1</dt>\n <dd>Fixed jscript.js for Opera background bug.</dd>\n <dt>ver3.0 2012/11/1</dt>\n <dd>Change design.Add new functions.</dd>\n <dt>ver2.1 2012/9/17</dt>\n <dd>Fixed update_notifier.php file.</dd>\n <dt>ver2.0 2012/8/4</dt>\n <dd>Major update. Add theme update notifier, logo uploading function, new theme option page.</dd>\n <dt>ver1.3 2012/6/10</dt>\n <dd>Fixed IE7 bug.</dd>\n <dt>ver1.2 2012/5/1</dt>\n <dd>Adjust right side info and search area.</dd>\n <dt>ver1.1.2 2012/4/30</dt>\n <dd>Fixed header menu bug.</dd>\n <dt>ver1.1 2012/4/30</dt>\n <dd>Add Chinese language file.</dd>\n <dt>ver1.0 2012/4/29</dt>\n <dd>Released first version of FLAT.</dd>\n</dl>\n]]>\n</changelog>\n</notifier>', 'yes'),
(118, 0, 'contempo-notifier-last-updated', '1402623573', 'yes'),
(121, 0, 'recently_activated', 'a:0:{}', 'yes'),
(122, 0, 'cb_default_setting', '1', 'yes'),
(123, 0, 'cb_colla', 'on', 'yes'),
(124, 0, 'cb_highlight', '', 'yes'),
(125, 0, 'cb_caps', 'GESHI_CAPS_NO_CHANGE', 'yes'),
(126, 0, 'cb_tab_width', '2', 'yes'),
(127, 0, 'cb_keywords_link', 'on', 'yes'),
(128, 0, 'cb_plain_txt', '', 'yes'),
(129, 0, 'cb_line', 'on', 'yes'),
(130, 0, 'cb_wrap_over', '', 'yes'),
(131, 0, 'cb_strict', '', 'yes'),
(133, 0, 'flat_options', 'a:18:{s:11:"show_author";i:1;s:13:"show_category";i:1;s:8:"show_tag";i:1;s:9:"show_date";i:1;s:12:"show_comment";i:1;s:17:"show_comment_time";i:1;s:14:"show_next_post";i:1;s:16:"show_bread_crumb";i:1;s:15:"show_return_top";i:1;s:11:"show_search";i:1;s:8:"show_rss";i:1;s:14:"show_site_desc";i:1;s:17:"information_title";s:11:"INFORMATION";s:20:"information_contents";s:117:"CharleyCh：\r\nHIT-LITTLE CODER\r\nhttp://weibo.com/charlley88\r\nHere to share\r\nHere to fight\r\nHere to mark\r\nHere to seek";s:5:"pager";s:5:"pager";s:11:"twitter_url";s:0:"";s:12:"facebook_url";s:0:"";s:16:"custom_search_id";s:10:"charlley88";}', 'yes'),
(144, 0, 'category_children', 'a:3:{i:6;a:7:{i:0;i:9;i:1;i:10;i:2;i:11;i:3;i:12;i:4;i:13;i:5;i:36;i:6;i:40;}i:8;a:2:{i:0;i:14;i:1;i:15;}i:22;a:5:{i:0;i:28;i:1;i:31;i:2;i:32;i:3;i:33;i:4;i:49;}}', 'yes');

-- --------------------------------------------------------

--
-- 表的结构 `wp_postmeta`
--

CREATE TABLE IF NOT EXISTS `wp_postmeta` (
  `meta_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `post_id` bigint(20) unsigned NOT NULL DEFAULT '0',
  `meta_key` varchar(255) DEFAULT NULL,
  `meta_value` longtext,
  PRIMARY KEY (`meta_id`),
  KEY `post_id` (`post_id`),
  KEY `meta_key` (`meta_key`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=331 ;

--
-- 转存表中的数据 `wp_postmeta`
--

INSERT INTO `wp_postmeta` (`meta_id`, `post_id`, `meta_key`, `meta_value`) VALUES
(1, 2, '_wp_page_template', 'default'),
(2, 1, '_edit_lock', '1350283301:1'),
(61, 50, '_edit_last', '1'),
(62, 50, '_edit_lock', '1363160120:1'),
(5, 1, '_wp_trash_meta_comments_status', 'a:1:{i:1;s:1:"1";}'),
(6, 5, '_edit_last', '1'),
(7, 5, '_edit_lock', '1350284127:1'),
(13, 10, '_edit_lock', '1350285423:1'),
(12, 10, '_edit_last', '1'),
(20, 2, '_edit_lock', '1350285625:1'),
(313, 218, '_edit_last', '1'),
(23, 5, '_wp_trash_meta_comments_status', 'a:1:{i:2;s:1:"1";}'),
(57, 48, '_edit_last', '1'),
(56, 3, '_edit_last', '1'),
(26, 17, '_edit_last', '1'),
(27, 17, '_edit_lock', '1350316907:1'),
(31, 19, '_edit_lock', '1350386850:1'),
(30, 19, '_edit_last', '1'),
(37, 25, '_edit_lock', '1350386958:1'),
(36, 25, '_edit_last', '1'),
(41, 33, '_edit_lock', '1366738670:1'),
(40, 33, '_edit_last', '1'),
(45, 38, '_edit_lock', '1366739009:1'),
(44, 38, '_edit_last', '1'),
(314, 218, '_edit_lock', '1402449630:1'),
(309, 213, '_edit_last', '1'),
(60, 48, '_edit_lock', '1400660289:1'),
(71, 58, '_edit_last', '1'),
(72, 58, '_edit_lock', '1364435922:1'),
(81, 63, '_edit_lock', '1365666432:1'),
(75, 60, '_edit_last', '1'),
(80, 63, '_edit_last', '1'),
(78, 60, '_edit_lock', '1364437794:1'),
(79, 60, '_oembed_075f59af2178e81ce8a2c75fc2af6624', '{{unknown}}'),
(85, 65, '_edit_lock', '1366247626:1'),
(84, 65, '_edit_last', '1'),
(89, 67, '_edit_lock', '1366739272:1'),
(88, 67, '_edit_last', '1'),
(93, 72, '_edit_lock', '1366867878:1'),
(92, 72, '_edit_last', '1'),
(127, 92, '_edit_lock', '1367345504:1'),
(123, 89, '_edit_lock', '1367072704:1'),
(122, 89, '_edit_last', '1'),
(116, 86, '_edit_last', '1'),
(117, 86, '_edit_lock', '1366867917:1'),
(126, 92, '_edit_last', '1'),
(135, 100, '_edit_lock', '1367167102:1'),
(134, 100, '_edit_last', '1'),
(139, 102, '_edit_lock', '1367358145:1'),
(138, 102, '_edit_last', '1'),
(143, 105, '_edit_lock', '1400660456:1'),
(142, 105, '_edit_last', '1'),
(149, 108, '_edit_lock', '1400660517:1'),
(148, 108, '_edit_last', '1'),
(153, 110, '_edit_lock', '1400550729:1'),
(152, 110, '_edit_last', '1'),
(161, 116, '_edit_lock', '1368115507:1'),
(160, 116, '_edit_last', '1'),
(166, 118, '_edit_lock', '1400660548:1'),
(165, 118, '_edit_last', '1'),
(164, 116, '_oembed_365fc88862bf96519cead76e2a30498a', '{{unknown}}'),
(178, 126, '_edit_lock', '1400660602:1'),
(174, 123, '_edit_lock', '1369271179:1'),
(173, 123, '_edit_last', '1'),
(177, 126, '_edit_last', '1'),
(182, 128, '_edit_lock', '1400660301:1'),
(181, 128, '_edit_last', '1'),
(186, 131, '_edit_lock', '1400656437:1'),
(185, 131, '_edit_last', '1'),
(194, 138, '_edit_lock', '1400550656:1'),
(193, 138, '_edit_last', '1'),
(200, 141, '_edit_lock', '1400554668:1'),
(199, 141, '_edit_last', '1'),
(204, 143, '_edit_lock', '1400589531:1'),
(203, 143, '_edit_last', '1'),
(210, 147, '_edit_lock', '1402044052:1'),
(209, 147, '_edit_last', '1'),
(302, 208, '_edit_lock', '1402280291:1'),
(301, 208, '_edit_last', '1'),
(234, 163, '_edit_lock', '1402024334:1'),
(238, 165, '_edit_lock', '1402045094:1'),
(233, 163, '_edit_last', '1'),
(237, 165, '_edit_last', '1'),
(242, 168, '_edit_lock', '1401242599:1'),
(241, 168, '_edit_last', '1'),
(248, 171, '_edit_lock', '1401321986:1'),
(247, 171, '_edit_last', '1'),
(252, 173, '_edit_lock', '1401763926:1'),
(251, 173, '_edit_last', '1'),
(257, 179, '_edit_last', '1'),
(258, 179, '_edit_lock', '1402021334:1'),
(262, 181, '_edit_lock', '1402024420:1'),
(261, 181, '_edit_last', '1'),
(310, 213, '_edit_lock', '1402282064:1'),
(292, 201, '_edit_lock', '1402277734:1'),
(291, 201, '_edit_last', '1'),
(281, 195, '_edit_last', '1'),
(282, 195, '_edit_lock', '1402061721:1'),
(318, 224, '_edit_lock', '1402627042:1'),
(317, 224, '_edit_last', '1'),
(324, 229, '_edit_lock', '1402539132:1'),
(323, 229, '_edit_last', '1'),
(330, 233, '_edit_lock', '1402649280:1'),
(329, 233, '_edit_last', '1');

-- --------------------------------------------------------

--
-- 表的结构 `wp_posts`
--

CREATE TABLE IF NOT EXISTS `wp_posts` (
  `ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `post_author` bigint(20) unsigned NOT NULL DEFAULT '0',
  `post_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_date_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content` longtext NOT NULL,
  `post_title` text NOT NULL,
  `post_excerpt` text NOT NULL,
  `post_status` varchar(20) NOT NULL DEFAULT 'publish',
  `comment_status` varchar(20) NOT NULL DEFAULT 'open',
  `ping_status` varchar(20) NOT NULL DEFAULT 'open',
  `post_password` varchar(20) NOT NULL DEFAULT '',
  `post_name` varchar(200) NOT NULL DEFAULT '',
  `to_ping` text NOT NULL,
  `pinged` text NOT NULL,
  `post_modified` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_modified_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content_filtered` text NOT NULL,
  `post_parent` bigint(20) unsigned NOT NULL DEFAULT '0',
  `guid` varchar(255) NOT NULL DEFAULT '',
  `menu_order` int(11) NOT NULL DEFAULT '0',
  `post_type` varchar(20) NOT NULL DEFAULT 'post',
  `post_mime_type` varchar(100) NOT NULL DEFAULT '',
  `comment_count` bigint(20) NOT NULL DEFAULT '0',
  PRIMARY KEY (`ID`),
  KEY `post_name` (`post_name`),
  KEY `type_status_date` (`post_type`,`post_status`,`post_date`,`ID`),
  KEY `post_parent` (`post_parent`),
  KEY `post_author` (`post_author`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=236 ;

--
-- 转存表中的数据 `wp_posts`
--

INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(36, 1, '2012-10-16 00:53:12', '2012-10-16 00:53:12', 'cookies &　session　的创建时机我算是纠结了下，并不是因为不好创建，而是前期知识量不足导致页面安排混乱进而在进一步编写联系的时候就纠结了，首先说说ASP的cookies & session创建和使用：\n<pre lang="asp" colla="+">\n<%\n  ''Create cookies''\n  Response.Cookie("name") = "cc"\n  ''Create Session''\n  Session("name") = "charley"\n  ''get the cookies''\n  Request.Cookie("name")\n  ''get the session''\n  Session("name")\n%>\n</pre>\nsession本来就是一次会话生存期（？）的，而简单利用Response.Cookie("")来创建的cookies也只保存一次会话，关闭页面再次登录就不含有此次cookies了，其实这样适合多选商品，而本质是cookies的过期时间没有设置，so...JAVASCRIPT版使用\n<pre lang="javascript" colla="+">\n<script type="text/javascript">\n//actually document.cookie = ...\n\nfunction setCookie(cname,cvalue,expiredays){\n	var exdate=new Date()\n	exdate.setDate(exdate.getDate()+expiredays)\n	document.cookie=cname+ "=" +escape(cvalue)+ ((expiredays==null) ? "" : ";expires="+exdate.toGMTString())\n}\nfunction getCookie(c_name)\n{\nif (document.cookie.length>0)\n  {\n  c_start=document.cookie.indexOf(c_name + "=")\n  if (c_start!=-1)\n    { \n    c_start=c_start + c_name.length+1 \n    c_end=document.cookie.indexOf(";",c_start)\n    if (c_end==-1) c_end=document.cookie.length\n    return unescape(document.cookie.substring(c_start,c_end))\n    } \n  }\nreturn ""\n}\n</script>\n</pre>', '电商整理（三）-cookies & session', '', 'inherit', 'open', 'open', '', '33-revision-3', '', '', '2012-10-16 00:53:12', '2012-10-16 00:53:12', '', 33, 'http://codeseeking.sinaapp.com/?p=36', 0, 'revision', '', 0),
(35, 1, '2012-10-16 00:52:18', '2012-10-16 00:52:18', 'cookies &　session　的创建时机我算是纠结了下，并不是因为不好创建，而是前期知识量不足导致页面安排混乱进而在进一步编写联系的时候就纠结了，首先说说ASP的cookies & session创建和使用：\r\n<per lang="asp" colla="+">\r\n<%\r\n  ''Create cookies''\r\n  Response.Cookie("name") = "cc"\r\n  ''Create Session''\r\n  Session("name") = "charley"\r\n  ''get the cookies''\r\n  Request.Cookie("name")\r\n  ''get the session''\r\n  Session("name")\r\n%>\r\n</per>\r\nsession本来就是一次会话生存期（？）的，而简单利用Response.Cookie("")来创建的cookies也只保存一次会话，关闭页面再次登录就不含有此次cookies了，其实这样适合多选商品，而本质是cookies的过期时间没有设置，so...JAVASCRIPT版使用\r\n<per lang="javascript" colla="+">\r\n<script type="text/javascript>\r\n//actually document.cookie = ...\r\n\r\nfunction setCookie(cname,cvalue,expiredays){\r\n	var exdate=new Date()\r\n	exdate.setDate(exdate.getDate()+expiredays)\r\n	document.cookie=cname+ "=" +escape(cvalue)+ ((expiredays==null) ? "" : ";expires="+exdate.toGMTString())\r\n}\r\nfunction getCookie(c_name)\r\n{\r\nif (document.cookie.length>0)\r\n  {\r\n  c_start=document.cookie.indexOf(c_name + "=")\r\n  if (c_start!=-1)\r\n    { \r\n    c_start=c_start + c_name.length+1 \r\n    c_end=document.cookie.indexOf(";",c_start)\r\n    if (c_end==-1) c_end=document.cookie.length\r\n    return unescape(document.cookie.substring(c_start,c_end))\r\n    } \r\n  }\r\nreturn ""\r\n}\r\n</script>\r\n</pre>', '电商整理（三）-cookies & session', '', 'inherit', 'open', 'open', '', '33-revision-2', '', '', '2012-10-16 00:52:18', '2012-10-16 00:52:18', '', 33, 'http://codeseeking.sinaapp.com/?p=35', 0, 'revision', '', 0),
(34, 1, '2012-10-16 00:51:11', '2012-10-16 00:51:11', 'cookies &　session　的创建时机我算是纠结了下，并不是因为不好创建，而是前期知识量不足导致页面安排混乱进而在进一步编写联系的时候就纠结了，首先说说ASP的cookies & session创建和使用：\n<per lang="asp" colla="+">\n<%\n  ''Create cookies''\n  Response.Cookie("name") = "cc"\n  ''Create Session''\n  Session("name") = "charley"\n  ''get the cookies''\n  Request.Cookie("name")\n  ''get the session''\n  Session("name")\n%>\n</per>\nsession本来就是一次会话生存期（？）的，而简单利用Response.Cookie("")来创建的cookies也只保存一次会话，关闭页面再次登录就不含有此次cookies了，其实这样适合多选商品，而本质是cookies的过期时间没有设置，so...JAVASCRIPT版使用\n<per lang="javascript" colla="+">\n<script type="text/javascript>\n//actually document.cookie = ...\n\nfunction setCookie(cname,cvalue,expiredays){\n	var exdate=new Date()\n	exdate.setDate(exdate.getDate()+expiredays)\n	document.cookie=cname+ "=" +escape(cvalue)+ ((expiredays==null) ? "" : ";expires="+exdate.toGMTString())\n}\nfunction getCookie(c_name)\n{\nif (document.cookie.length>0)\n  {\n  c_start=document.cookie.indexOf(c_name + "=")\n  if (c_start!=-1)\n    { \n    c_start=c_start + c_name.length+1 \n    c_end=document.cookie.indexOf(";",c_start)\n    if (c_end==-1) c_end=document.cookie.length\n    return unescape(document.cookie.substring(c_start,c_end))\n    } \n  }\nreturn ""\n}\n</script>\n</pre>', '电商整理（三）-cookies & session', '', 'inherit', 'open', 'open', '', '33-revision', '', '', '2012-10-16 00:51:11', '2012-10-16 00:51:11', '', 33, 'http://codeseeking.sinaapp.com/?p=34', 0, 'revision', '', 0),
(33, 1, '2012-10-16 01:05:55', '2012-10-16 01:05:55', 'cookies &　session　的创建时机我算是纠结了下，并不是因为不好创建，而是前期知识量不足导致页面安排混乱进而在进一步编写联系的时候就纠结了，首先说说ASP的cookies & session创建和使用：\r\n<pre lang="asp" colla="+">\r\n<%\r\n  ''Create cookies''\r\n  Response.Cookie("name") = "cc"\r\n  ''Create Session''\r\n  Session("name") = "charley"\r\n  ''get the cookies''\r\n  Request.Cookie("name")\r\n  ''get the session''\r\n  Session("name")\r\n%>\r\n</pre>\r\nsession本来就是一次会话生存期（？）的，而简单利用Response.Cookie("")来创建的cookies也只保存一次会话，关闭页面再次登录就不含有此次cookies了，其实这样适合多选商品，而本质是cookies的过期时间没有设置，so...JAVASCRIPT版使用\r\n<pre lang="javascript" colla="+">\r\n<script type="text/javascript">\r\n//actually document.cookie = ...\r\n\r\nfunction setCookie(cname,cvalue,expiredays){\r\n	var exdate=new Date()\r\n	exdate.setDate(exdate.getDate()+expiredays)\r\n	document.cookie=cname+ "=" +escape(cvalue)+ ((expiredays==null) ? "" : ";expires="+exdate.toGMTString())\r\n}\r\nfunction getCookie(c_name)\r\n{\r\nif (document.cookie.length>0)\r\n  {\r\n  c_start=document.cookie.indexOf(c_name + "=")\r\n  if (c_start!=-1)\r\n    { \r\n    c_start=c_start + c_name.length+1 \r\n    c_end=document.cookie.indexOf(";",c_start)\r\n    if (c_end==-1) c_end=document.cookie.length\r\n    return unescape(document.cookie.substring(c_start,c_end))\r\n    } \r\n  }\r\nreturn ""\r\n}\r\n//删除cookie \r\nfunction DelCookie(name)\r\n{ \r\n  var exp = new Date(); \r\n  exp.setTime(exp.getTime() - 1); \r\n  var cval=getCookie(name); \r\n  if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString(); \r\n} \r\n</script>\r\n</pre>\r\n这样增加、查找、删除cookies就齐了，总体来说JAVASCRIPT可以简单的设置超时时间，因为JAVASCRIPT在自己的网页上是手动触发性的，即需要有特定的事件才会触发，继而创建一个有过期时间的cookies，而如果asp的话，即便能创建过期时间的，它也是固定的页面的某一部分，总要走，难回头。\r\nps：这里有一个小问题，或者说初学者同有的问题？---我总是想要在JAVASCRIPT中使用asp...在某些时候两者搀和着使用！（c函数的框框架架死不去啊！），然后小默同学给普及了下（是基础知识我知道啦！），JAVASCRIPT是在浏览器端的而ASP是在服务器端的，JAVASCRIPT是异步的，两者的联系不单单是调用就可以说清的...so separate them！', '电商整理（三）-cookies & session', '', 'publish', 'open', 'open', '', '%e7%94%b5%e5%95%86%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%89%ef%bc%89-cookies-session', '', '', '2012-10-16 01:05:55', '2012-10-16 01:05:55', '', 0, 'http://codeseeking.sinaapp.com/?p=33', 0, 'post', '', 0),
(17, 1, '2012-10-15 15:24:22', '2012-10-15 15:24:22', '首先，由于种种的原因，我还是回到了Sae ， 而且花了近一天来整这个纠结的wordpress，我没有技术，没有经验，但是我想我还是有那么一腔学习的“激情”的。\r\n\r\n经历了这一周的电商课设，再次感慨下“网页不是你想写，想写就能写！”，真心的，或者说它和程序又有着挺大的差异的（又或者是自己的不熟悉不了解不懂！？），程序的一段段大不了我留好借口，具体某一段的参数用形参传就好了么，但是网页有那么多的交互，那么多信息，真心让我乱了方寸。最终马马虎虎，坎坎坷坷的做完了基础，看着脆弱...凌乱...以及“鸡肋”网站，我冲动的把sae又翻出来，我想去记录这些，这些我不懂的，我学到的，和，我感慨的，总会有机会用到的吧，我觉得...\r\n\r\n再者，便是随之相关的我的考研之路吧，三年的学生工作最终也不会有什么直接结果，成绩的沉沉浮浮也让自己处在高不成低不就的尴尬地位，掂量自己的分量又没有那么大的自信或者说觉得自己还没有准备好去fighting，积累是必须的，不论是你花在了本科四年还是即将的研究生...都是一个积累能力自信的地方。看着同学的种种我也有悔恨也会有不甘或者担忧，但是，就像姚*说的，每个人有每个人的活法，或许我的积累会在我这一段痛苦又潇洒之后呢...\r\n\r\n我也曾经想过我花掉我我仅剩下的时间去好好积累，最终我放弃了，不是不愿意也不是没那个能力吧，我还是有时候说服不了自己看不住自己，我需要一个新的“高考”来让我重拾那个状态么！？不知道，我知道的是，我需要努力，我需要积累\r\n\r\n所以我又回来了，带着更认真和更负责人的心，希望我能整好这片空间，整好我的道路。\r\n\r\nmark：23：23 15/10/2012', 'Re Sae 随感', '', 'publish', 'open', 'open', '', 're-sae-%e9%9a%8f%e6%84%9f', '', '', '2012-10-15 15:24:22', '2012-10-15 15:24:22', '', 0, 'http://codeseeking.sinaapp.com/?p=17', 0, 'post', '', 0),
(18, 1, '2012-10-15 15:23:52', '2012-10-15 15:23:52', '首先，由于种种的原因，我还是回到了Sae ， 而且花了近一天来整这个纠结的wordpress，我没有技术，没有经验，但是我想我还是有那么一腔学习的“激情”的。\n\n经历了这一周的电商课设，再次感慨下“网页不是你想写，想写就能写！”，真心的，或者说它和程序又有着挺大的差异的（又或者是自己的不熟悉不了解不懂！？），程序的一段段大不了我留好借口，具体某一段的参数用形参传就好了么，但是网页有那么多的交互，那么多信息，真心让我乱了方寸。最终马马虎虎，坎坎坷坷的做完了基础，看着脆弱...凌乱...以及“鸡肋”网站，我冲动的把sae又翻出来，我想去记录这些，这些我不懂的，我学到的，和，我感慨的，总会有机会用到的吧，我觉得...\n\n再者，便是随之相关的我的考研之路吧，三年的学生工作最终也不会有什么直接结果，成绩的沉沉浮浮也让自己处在高不成低不就的尴尬地位，掂量自己的分量又没有那么大的自信或者说觉得自己还没有准备好去fighting，积累是必须的，不论是你花在了本科四年还是即将的研究生...都是一个积累能力自信的地方。看着同学的种种我也有悔恨也会有不甘或者担忧，但是，就像姚*说的，每个人有每个人的活法，或许我的积累会在我这一段痛苦又潇洒之后呢...\n\n我也曾经想过我花掉我我仅剩下的时间去好好积累，最终我放弃了，不是不愿意也不是没那个能力吧，我还是有时候说服不了自己看不住自己，我需要一个新的“高考”来让我重拾那个状态么！？不知道，我知道的是，我需要努力，我需要积累\n\n所以我又回来了，带着更认真和更负责人的心，希望我能整好这片空间，整好我的道路。\n\nmark：23、', 'Re Sae 随感', '', 'inherit', 'open', 'open', '', '17-revision', '', '', '2012-10-15 15:23:52', '2012-10-15 15:23:52', '', 17, 'http://codeseeking.sinaapp.com/?p=18', 0, 'revision', '', 0),
(19, 1, '2012-10-15 16:00:43', '2012-10-15 16:00:43', '提到筠姐，就离不开数据库，电商搁我们最初的想法就是买卖东西，东西放哪，钱放哪，用户搁哪？DataBase...\r\n鉴于起步选择，放弃了PHP+MySql的组合，选择了挺疼的ASP+IIS+SQL的配置，iis的配置网上一搜全是，控制面板-添加/删除程序-勾选-控制面板-管理工具-iis管理-ETC，sql安装的时候循规蹈矩来就好，除了设置密码那步看你怎么选有点说法外其他也没什么，asp么...没考虑，反正php我也不熟。\r\n在总体进入coding的阶段，第一步便是连接数据库，这里建议把连接的代码专门放到一个.asp文件中，这样可以省去很多代码段，看起来也简洁些,代码如下，你可以存放在conn.asp中，每次需要连接的页面在head前加上一句<pre lang="asp" colla="+"><!--#include file="conn.asp" --></pre>具体连接代码：\r\n<pre lang="asp" colla="+">\r\n<%\r\nconnstr="Driver={SQL Server};server=(local);uid=sa;database=dsdatabase;pwd=cc;"\r\nSet conn = Server.CreateObject("ADODB.Connection")\r\nconn.Open connstr\r\nif conn.State <> 1 then\r\n    Set conn = Nothing\r\n    Response.Write("database connection error...")\r\n    Response.End\r\nEnd if  \r\n%>\r\n</pre>\r\n如果没有返回错误怎说明你的连接成功了，之后你便可以增删改查得数据，联合查询出表格了，查询为例：\r\n<pre lang="asp" colla="+">\r\n<%\r\nset rs = Server.CreateObject("ADODB.recordset")\r\nsql = "SELECT * FROM users WHERE uname = ''" & unames & "''"\r\nrs.Open sql,conn,1,A\r\nrs.Open(sql,conn,1,A)\r\nA: 1-读取数据；3-表示新增删除数据\r\n</pre>\r\n这样便打开了数据库，并根据自己写的sql语句进行筛选数据，在rs记录集中，而对于rs这样的recordset对象的操作有：\r\n<pre lang="ASP" colla="+">\r\nrs.Fields.Count : Recordset完整字段数\r\nrs(i).Name : 第i个字段的名称，字段从0-rs.Fields.Count-1\r\nrs(i) : 第i个字段的数据\r\nrs("字段名") : 指定字段的数据\r\nrs.Record.Count : 数据记录的总数\r\nrs.EOF : 是否是最后一条记录\r\nrs.MoveFirst : rs.MoveLast : rs.MoveNext : rs.MovePrev\r\nrs.GetRows : 将数据放入数组中，事后会给出例子\r\n</pre>\r\n数据库的操作大概就是这些，不同的就是sql语句的具体不同，和Rs.Open sql,conn,1,A中的A的不同\r\nps：一句，由于是自己不是很熟悉，在使用dreamwear进行asp编程的时候，建立新的.asp文件将conn.asp包含进去的时候有时显示无法连接，最终解决的方法是1.将你的最初能连接的网页复制过去然后再修改 2.sdk默认建立的.asp中有的中原来的JAVASRIPT改成现在这样的 VBSCRIPT，如下<pre lang="ASP" colla="-"><%@LANGUAGE="JAVASCRIPT" CODEPAGE="936"%>  ---->  <%@LANGUAGE="VBSCRIPT" CODEPAGE="936"%> </pre>\r\nps2:一句，一般rs.recordset中便是你sql条件的全部记录，但是有一种时候不是，那就是在分页的时候，具体下一篇文章讲解\r\n\r\ntime mark 0:00 16/10/2012', '电商整理（一）-数据库篇', '', 'publish', 'open', 'open', '', '%e7%94%b5%e5%95%86%e6%95%b4%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87', '', '', '2012-10-15 16:02:06', '2012-10-15 16:02:06', '', 0, 'http://codeseeking.sinaapp.com/?p=19', 0, 'post', '', 0),
(20, 1, '2012-10-15 15:33:56', '2012-10-15 15:33:56', '提到筠姐，就离不开数据库，电商搁我们最初的想法就是买卖东西，东西放哪，钱放哪，用户搁哪？DataBase...\n鉴于起步选择，放弃了PHP+MySql的组合，选择了挺疼的ASP+IIS+SQL的配置，iis的配置网上一搜全是，控制面板-添加/删除程序-勾选-控制面板-管理工具-iis管理-ETC，sql安装的时候循规蹈矩来就好，除了设置密码那步看你怎么选有点说法外其他也没什么，asp么...没考虑，反正php我也不熟。\n在总体进入coding的阶段，第一步便是连接数据库，这里建议把连接的代码专门放到一个.asp文件中，这样可以省去很多代码段，看起来也简洁些\n<pre lang="asp" colla="+">\n<%\nconnstr="Driver={SQL Server};server=(local);uid=sa;database=dsdatabase;pwd=cc;"\nSet conn = Server.CreateObject("ADODB.Connection")\nconn.Open connstr\nif conn.State <> 1 then\n    Set conn = Nothing\n    Response.Write("database connection error...")\n    Response.End\nEnd if  \n%>\n</pre>', '电商整理（一）-数据库篇', '', 'inherit', 'open', 'open', '', '19-revision', '', '', '2012-10-15 15:33:56', '2012-10-15 15:33:56', '', 19, 'http://codeseeking.sinaapp.com/?p=20', 0, 'revision', '', 0),
(21, 1, '2012-10-15 15:34:56', '2012-10-15 15:34:56', '提到筠姐，就离不开数据库，电商搁我们最初的想法就是买卖东西，东西放哪，钱放哪，用户搁哪？DataBase...\n鉴于起步选择，放弃了PHP+MySql的组合，选择了挺疼的ASP+IIS+SQL的配置，iis的配置网上一搜全是，控制面板-添加/删除程序-勾选-控制面板-管理工具-iis管理-ETC，sql安装的时候循规蹈矩来就好，除了设置密码那步看你怎么选有点说法外其他也没什么，asp么...没考虑，反正php我也不熟。\n在总体进入coding的阶段，第一步便是连接数据库，这里建议把连接的代码专门放到一个.asp文件中，这样可以省去很多代码段，看起来也简洁些,代码如下，你可以存放在conn.asp中，每次需要连接的页面在head前jia''sha\n<pre lang="asp" colla="+">\n<%\nconnstr="Driver={SQL Server};server=(local);uid=sa;database=dsdatabase;pwd=cc;"\nSet conn = Server.CreateObject("ADODB.Connection")\nconn.Open connstr\nif conn.State <> 1 then\n    Set conn = Nothing\n    Response.Write("database connection error...")\n    Response.End\nEnd if  \n%>\n</pre>', '电商整理（一）-数据库篇', '', 'inherit', 'open', 'open', '', '19-revision-2', '', '', '2012-10-15 15:34:56', '2012-10-15 15:34:56', '', 19, 'http://codeseeking.sinaapp.com/?p=21', 0, 'revision', '', 0),
(22, 1, '2012-10-15 15:51:44', '2012-10-15 15:51:44', '提到筠姐，就离不开数据库，电商搁我们最初的想法就是买卖东西，东西放哪，钱放哪，用户搁哪？DataBase...\r\n鉴于起步选择，放弃了PHP+MySql的组合，选择了挺疼的ASP+IIS+SQL的配置，iis的配置网上一搜全是，控制面板-添加/删除程序-勾选-控制面板-管理工具-iis管理-ETC，sql安装的时候循规蹈矩来就好，除了设置密码那步看你怎么选有点说法外其他也没什么，asp么...没考虑，反正php我也不熟。\r\n在总体进入coding的阶段，第一步便是连接数据库，这里建议把连接的代码专门放到一个.asp文件中，这样可以省去很多代码段，看起来也简洁些,代码如下，你可以存放在conn.asp中，每次需要连接的页面在head前加上一句<pre lang="asp" colla="+"><!--#include file="conn.asp" --></pre>具体连接代码：\r\n<pre lang="asp" colla="+">\r\n<%\r\nconnstr="Driver={SQL Server};server=(local);uid=sa;database=dsdatabase;pwd=cc;"\r\nSet conn = Server.CreateObject("ADODB.Connection")\r\nconn.Open connstr\r\nif conn.State <> 1 then\r\n    Set conn = Nothing\r\n    Response.Write("database connection error...")\r\n    Response.End\r\nEnd if  \r\n%>\r\n</pre>\r\n如果没有返回错误怎说明你的连接成功了，之后你便可以增删改查得数据，联合查询出表格了，查询为例：\r\n<pre lang="asp" colla="+">\r\n<%\r\nset rs = Server.CreateObject("ADODB.recordset")\r\nsql = "SELECT * FROM users WHERE uname = ''" & unames & "''"\r\nrs.Open sql,conn,1,A\r\nrs.Open(sql,conn,1,A)\r\nA: 1-读取数据；3-表示新增删除数据\r\n</pre>\r\n这样便打开了数据库，并根据自己写的sql语句进行筛选数据，在rs记录集中，而对于rs这样的recordset对象的操作有：\r\n<pre lang="ASP" colla="+">\r\nrs.Fields.Count : Recordset完整字段数\r\nrs(i).Name : 第i个字段的名称，字段从0-rs.Fields.Count-1\r\nrs(i) : 第i个字段的数据\r\nrs("字段名") : 指定字段的数据\r\nrs.Record.Count : 数据记录的总数\r\nrs.EOF : 是否是最后一条记录\r\nrs.MoveFirst rs.MoveLast rs.MoveNext rs.MovePrev\r\nrs.GetRows : 将数据放入数组中，事后会给出例子\r\n</pre>', '电商整理（一）-数据库篇', '', 'inherit', 'open', 'open', '', '19-revision-3', '', '', '2012-10-15 15:51:44', '2012-10-15 15:51:44', '', 19, 'http://codeseeking.sinaapp.com/?p=22', 0, 'revision', '', 0),
(23, 1, '2012-10-15 16:00:43', '2012-10-15 16:00:43', '提到筠姐，就离不开数据库，电商搁我们最初的想法就是买卖东西，东西放哪，钱放哪，用户搁哪？DataBase...\r\n鉴于起步选择，放弃了PHP+MySql的组合，选择了挺疼的ASP+IIS+SQL的配置，iis的配置网上一搜全是，控制面板-添加/删除程序-勾选-控制面板-管理工具-iis管理-ETC，sql安装的时候循规蹈矩来就好，除了设置密码那步看你怎么选有点说法外其他也没什么，asp么...没考虑，反正php我也不熟。\r\n在总体进入coding的阶段，第一步便是连接数据库，这里建议把连接的代码专门放到一个.asp文件中，这样可以省去很多代码段，看起来也简洁些,代码如下，你可以存放在conn.asp中，每次需要连接的页面在head前加上一句<pre lang="asp" colla="+"><!--#include file="conn.asp" --></pre>具体连接代码：\r\n<pre lang="asp" colla="+">\r\n<%\r\nconnstr="Driver={SQL Server};server=(local);uid=sa;database=dsdatabase;pwd=cc;"\r\nSet conn = Server.CreateObject("ADODB.Connection")\r\nconn.Open connstr\r\nif conn.State <> 1 then\r\n    Set conn = Nothing\r\n    Response.Write("database connection error...")\r\n    Response.End\r\nEnd if  \r\n%>\r\n</pre>\r\n如果没有返回错误怎说明你的连接成功了，之后你便可以增删改查得数据，联合查询出表格了，查询为例：\r\n<pre lang="asp" colla="+">\r\n<%\r\nset rs = Server.CreateObject("ADODB.recordset")\r\nsql = "SELECT * FROM users WHERE uname = ''" & unames & "''"\r\nrs.Open sql,conn,1,A\r\nrs.Open(sql,conn,1,A)\r\nA: 1-读取数据；3-表示新增删除数据\r\n</pre>\r\n这样便打开了数据库，并根据自己写的sql语句进行筛选数据，在rs记录集中，而对于rs这样的recordset对象的操作有：\r\n<pre lang="ASP" colla="+">\r\nrs.Fields.Count : Recordset完整字段数\r\nrs(i).Name : 第i个字段的名称，字段从0-rs.Fields.Count-1\r\nrs(i) : 第i个字段的数据\r\nrs("字段名") : 指定字段的数据\r\nrs.Record.Count : 数据记录的总数\r\nrs.EOF : 是否是最后一条记录\r\nrs.MoveFirst : rs.MoveLast : rs.MoveNext : rs.MovePrev\r\nrs.GetRows : 将数据放入数组中，事后会给出例子\r\n</pre>\r\n数据库的操作大概就是这些，不同的就是sql语句的具体不同，和Rs.Open sql,conn,1,A中的A的不同\r\nps：一句，由于是自己不是很熟悉，在使用dreamwear进行asp编程的时候，建立新的.asp文件将conn.asp包含进去的时候有时显示无法连接，最终解决的方法是1.将你的最初能连接的网页复制过去然后再修改 2.sdk默认建立的.asp中有的中原来的JAVASRIPT改成现在这样的 VBSCRIPT，如下<pre lang="ASP" colla="-"><%@LANGUAGE="JAVASCRIPT" CODEPAGE="936"%>  ---->  <%@LANGUAGE="VBSCRIPT" CODEPAGE="936"%> </pre>\r\nps2:一句，一般rs.recordset中便是你sql条件的全部记录，但是有一种时候不是，那就是在分页的时候，具体下一篇文章讲解\r\n\r\ntime mark 0:00 16/10/2012', '电商整理（一）-数据库篇', '', 'inherit', 'open', 'open', '', '19-revision-4', '', '', '2012-10-15 16:00:43', '2012-10-15 16:00:43', '', 19, 'http://codeseeking.sinaapp.com/?p=23', 0, 'revision', '', 0),
(50, 1, '2013-03-13 07:32:08', '2013-03-13 07:32:08', '今天尝试配置了下premake4，虽然linux工程管理又很多，如make/cmake/automake...但是同学说这个简单这个方便这个跨平台什么什么的，好吧，试试吧，虽然有点疼。\r\n首先，http://industriousone.com/premake 下载最新版本的premake4，tar包解压后是可执行文件，记得把它放到默认搜索路径中去（usr/bin）这样在命令行才可以当命令用，不然就只能在这个解压的文件夹上使用，另外一个是源码包，里面又很多examples和一些配置。script文件夹在使用时需cp到工程文件夹里（ps：premake4.lua也是哦）\r\n这里只是premake4的一些事情，还有就是lua环境的配置，http://www.lua.org/ 在这下载最新的lua包，tar -xzvf解压，make..这里make需要注意选择自己的系统，"make xxx", where xxx is your platform name，这里可能显示can''t find -lxxx 指的是缺少xxx库，-l是参数 如premake时缺少 -lreadline ，通过sudo apt-cache search xx 可以从软件包列表里搜索，这里的库是 libreadline-dev..安装后即可。这样lua也配置好了。\r\n最后就是看例子学习了，唉，http://industriousone.com/scripting-premake讲的很好。\r\n\r\nps：Lua 5.1 Reference Manual ： http://www.lua.org/manual/5.1/\r\n    Scripting Reference ： http://industriousone.com/scripting-reference', 'premake4 for linux', '', 'publish', 'open', 'open', '', 'premake4-for-linux', '', '', '2013-03-13 07:35:19', '2013-03-13 07:35:19', '', 0, 'http://codeseeking.sinaapp.com/?p=50', 0, 'post', '', 0),
(25, 1, '2012-10-15 16:44:43', '2012-10-15 16:44:43', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\r\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\r\n<pre lang="ASP" colla="+">\r\n1-Response.Redirect("index.asp")\r\n2-Response.Redirect("index.asp?page=1")\r\n3-Response.Redirect("index.asp?page=1 & user = cc ")\r\n</pre>\r\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\r\n<pre lang="asp" colla="+">\r\n<%\r\n  inpage = trim(Request.QueryString("page"))\r\n  unames = trim(Request.QueryString("user"))\r\n%>\r\n</pre>\r\n这样便得到传送过来的参数的值并可以进行更多的判断了\r\nso：我们开始分页之旅\r\n<pre lang="asp" colla="-">\r\n<%\r\n  connstr="Driver={SQL Server};server=(local);uid=sa;database=dsdatabase;pwd=cc;"\r\n  Set conn = Server.CreateObject("ADODB.Connection")\r\n  conn.Open connstr\r\n  if conn.State <> 1 then\r\n      Set conn = Nothing\r\n      Response.Write "数据库连接出错！"\r\n      Response.Write "可能出错原因：数据库位置或名称不对、数据库损坏！"\r\n      Response.End\r\n  End if  \r\n%>\r\n<%\r\n  dim i,intpage,page,pre,last,filepath\r\n  intpage = 1\r\n  set rs = server.CreateObject("adodb.recordset")\r\n  sql = "select * from Goods"\r\n  rs.PageSize = 3\r\n  rs.CursorLocation = 3\r\n  rs.open sql,conn,0,2,1\r\n  pre = true\r\n  last = true\r\n  page = trim(Request.QueryString("page"))\r\n  if len(page) = 0 then\r\n 	inpage = 1\r\n	pre = false\r\n  else\r\n	if cint(page) =< 1 then\r\n        	intpage = 1\r\n		pre = false\r\n	else\r\n		if cint(page) >= rs.PageCount then\r\n			intpage = rs.PageCount\r\n			last = false\r\n		else\r\n			intpage = cint(page)\r\n		end if\r\n	end if\r\n  end if\r\n  if not rs.eof and intpage<>"" then\r\n	rs.absolutepage = intpage\r\n  end if\r\n%>\r\n**********循环内容开始*********\r\n<table border="0" cellpadding="0" cellspacing="1" bgcolor="#0000FF" width="80%" align="center">\r\n<input type="checkbox" id="mychk" name="mychk"  />\r\n<%\r\n  for i=0 to rs.pagesize-1\r\n  if rs.bof or rs.eof then exit for\r\n%>\r\n  <tr bgcolor="#FFFFFF" align="center">\r\n    <td><%=rs("Gname")%></td><td><%=rs("Gid")%></td><td><%=rs("Gprice")%></td>\r\n  </tr>\r\n<%\r\nrs.movenext()\r\nnext\r\n%>\r\n</table>\r\n**********循环显示的内容结束**********\r\n  <p align="center">\r\n    <a href="11.asp?page=1">首页</a>&nbsp;\r\n    <a href="11.asp?page=<%=intpage-1%>">前一页</a>&nbsp;\r\n    <a href="11.asp?page=<%=intpage+1%>">后一页</a>&nbsp;\r\n    <a href="11.asp?page=<%=rs.pagecount%>">末页</a>\r\n  </p>\r\n  <p align="center">现在是第<%=intpage%>页一共有<%=rs.pagecount%>页</p>\r\n</pre>\r\n其实不难看出，intpage作为参数传递，但实际控制的是sql自己，因为rs自身就带有rs.PageSize 和 rs.CursorLocation的属性\r\n<pre lang="ASP" colla="+">\r\n      rs.PageSize = 8         //（Yoko:这里设定每页显示的记录数\r\n      rs.CursorLocation = 3\r\n      rs.Open sql,conn,0,2,1   //（Yoko:''这里执行你查询SQL并获得结果记录集\r\n</pre>\r\n所以，只要我们在每次进入到循环内容操作前根据 intpage 传来的信息对 rs 的分页属性进行调整即可，如\r\n<pre lang="asp" colla="-">\r\npage = trim(Request.QueryString("page"))     \r\n      if len(page) = 0 then\r\n                  intpage = 1\r\n                  pre = false\r\n      else\r\n          if cint(page) =< 1 then\r\n               intpage = 1\r\n               pre = false\r\n          else\r\n              if cint(page) >= rs.PageCount then\r\n                  intpage = rs.PageCount\r\n                  last = false\r\n              else\r\n                   intpage = cint(page)\r\n             end if\r\n         end if\r\n      end if\r\n    if not rs.eof then\r\n         rs.AbsolutePage = intpage\r\n    end if\r\n</pre>\r\n这段判断就是分页的精髓了..\r\nps：分页其实套套模版改改变量调调需求就结束了，但是，分页带来的除了物品信息的动态更迭，还有页面的从新载入，那么，除了商品外的用户信息怎么处理呢？-用url?参数=值显然有点无脑加明显了，所以我们便用到asp中的cookies和session来记录，当然有些时候用url传送参数也可以方便我们进行一些“特殊的判断”，具体细节下一篇讲解。\r\n\r\ntime mark ： 0：44 16/10/2012 cc', '电商整理（二）-asp分页问题【数据库分页】', '', 'publish', 'open', 'open', '', '%e7%94%b5%e5%95%86%e6%95%b4%e7%90%86%ef%bc%88%e4%ba%8c%ef%bc%89-asp%e5%88%86%e9%a1%b5%e9%97%ae%e9%a2%98%e3%80%90%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e9%a1%b5%e3%80%91', '', '', '2012-10-15 16:44:43', '2012-10-15 16:44:43', '', 0, 'http://codeseeking.sinaapp.com/?p=25', 0, 'post', '', 0),
(26, 1, '2012-10-15 16:21:51', '2012-10-15 16:21:51', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\n<pre lang="ASP" colla="+">\n1-Response.Redirect("index.asp")\n2-Response.Redirect("index.asp?page=1")\n3-Response.Redirect("index.asp?page=1 & user = cc ")\n</pre>\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\n<per lang="asp" colla="-">\n  inpage = Request.QueryString("page")\n  uname = Request.QueryString("user")\n</pre>\n<pre lang="javascript" collar="-">\n  var inpage = trim(Request.QueryString)\n</pre>', '电商整理（二）-asp分页问题【数据库分页】', '', 'inherit', 'open', 'open', '', '25-revision', '', '', '2012-10-15 16:21:51', '2012-10-15 16:21:51', '', 25, 'http://codeseeking.sinaapp.com/?p=26', 0, 'revision', '', 0),
(31, 1, '2012-10-15 16:26:34', '2012-10-15 16:26:34', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\r\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\r\n<pre lang="ASP" colla="+">\r\n1-Response.Redirect("index.asp")\r\n2-Response.Redirect("index.asp?page=1")\r\n3-Response.Redirect("index.asp?page=1 & user = cc ")\r\n</pre>\r\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\r\n<pre lang="asp" colla="+">\r\n<%\r\n  inpage = trim(Request.QueryString("page"))\r\n  unames = trim(Request.QueryString("user"))\r\n%>\r\n</pre>', '电商整理（二）-asp分页问题【数据库分页】', '', 'inherit', 'open', 'open', '', '25-revision-6', '', '', '2012-10-15 16:26:34', '2012-10-15 16:26:34', '', 25, 'http://codeseeking.sinaapp.com/?p=31', 0, 'revision', '', 0),
(27, 1, '2012-10-15 16:22:26', '2012-10-15 16:22:26', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\r\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\r\n<pre lang="ASP" colla="+">\r\n1-Response.Redirect("index.asp")\r\n2-Response.Redirect("index.asp?page=1")\r\n3-Response.Redirect("index.asp?page=1 & user = cc ")\r\n</pre>\r\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\r\n<per lang="asp" colla="-">\r\n  inpage = trim(Request.QueryString("page"))\r\n  uname = trim(Request.QueryString("user"))\r\n</pre>\r\n<pre lang="javascript" collar="-">\r\n  var inpage = trim(Request.QueryString("page"));\r\n</pre>', '电商整理（二）-asp分页问题【数据库分页】', '', 'inherit', 'open', 'open', '', '25-revision-2', '', '', '2012-10-15 16:22:26', '2012-10-15 16:22:26', '', 25, 'http://codeseeking.sinaapp.com/?p=27', 0, 'revision', '', 0),
(28, 1, '2012-10-15 16:22:51', '2012-10-15 16:22:51', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\n<pre lang="ASP" colla="+">\n1-Response.Redirect("index.asp")\n2-Response.Redirect("index.asp?page=1")\n3-Response.Redirect("index.asp?page=1 & user = cc ")\n</pre>\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\n<pre lang="asp" colla="-">\n  inpage = trim(Request.QueryString("page"))\n  uname = trim(Request.QueryString("user"))\n</pre>\n<pre lang="javascript" collar="-">\n  var inpage = trim(Request.QueryString("page"));\n</pre>', '电商整理（二）-asp分页问题【数据库分页】', '', 'inherit', 'open', 'open', '', '25-revision-3', '', '', '2012-10-15 16:22:51', '2012-10-15 16:22:51', '', 25, 'http://codeseeking.sinaapp.com/?p=28', 0, 'revision', '', 0),
(29, 1, '2012-10-15 16:23:37', '2012-10-15 16:23:37', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\r\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\r\n<pre lang="ASP" colla="+">\r\n1-Response.Redirect("index.asp")\r\n2-Response.Redirect("index.asp?page=1")\r\n3-Response.Redirect("index.asp?page=1 & user = cc ")\r\n</pre>\r\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\r\n<pre lang="asp" colla="-">\r\n  inpage = trim(Request.QueryString("page"))\r\n  unames = trim(Request.QueryString("user"))\r\n</pre>\r\n<pre lang="JavaScript" collar="-">\r\n  var inpage = trim(Request.QueryString("page"))\r\n</pre>', '电商整理（二）-asp分页问题【数据库分页】', '', 'inherit', 'open', 'open', '', '25-revision-4', '', '', '2012-10-15 16:23:37', '2012-10-15 16:23:37', '', 25, 'http://codeseeking.sinaapp.com/?p=29', 0, 'revision', '', 0),
(30, 1, '2012-10-15 16:24:07', '2012-10-15 16:24:07', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\r\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\r\n<pre lang="ASP" colla="+">\r\n1-Response.Redirect("index.asp")\r\n2-Response.Redirect("index.asp?page=1")\r\n3-Response.Redirect("index.asp?page=1 & user = cc ")\r\n</pre>\r\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\r\n<pre lang="asp" colla="-">\r\n  inpage = trim(Request.QueryString("page"))\r\n  unames = trim(Request.QueryString("user"))\r\n</pre>\r\n<pre lang="JScript" collar="-">\r\n  var inpage = trim(Request.QueryString("page"))\r\n</pre>', '电商整理（二）-asp分页问题【数据库分页】', '', 'inherit', 'open', 'open', '', '25-revision-5', '', '', '2012-10-15 16:24:07', '2012-10-15 16:24:07', '', 25, 'http://codeseeking.sinaapp.com/?p=30', 0, 'revision', '', 0),
(32, 1, '2012-10-15 16:34:51', '2012-10-15 16:34:51', '如果你被逼无奈要写页面更新以便有下一页上一页的功能，那么，页面刷新但是数据需要变，如果动态的数据是从数据库里动态的取出来的话，那么，恭喜你，你找到了方法，就是分页。\r\n其实一开始我乍一听这个名字以为是像前端技术一样使浏览器一分为几的感觉，后来才知道它是控制rs.recordset “跳跃的”，每次只取出我想要的那部分，当然，其中也涉及到了利用url传参数的问题，so...我们先说说url传参。\r\n<pre lang="ASP" colla="+">\r\n1-Response.Redirect("index.asp")\r\n2-Response.Redirect("index.asp?page=1")\r\n3-Response.Redirect("index.asp?page=1 & user = cc ")\r\n</pre>\r\n上述的三句话都将页面重定向到 index.asp 去，但是很明显后面两种多了一些，这些便是原网页向index.asp传送的参数，1-是正常的，2-不仅正常而且传送了page参数且参数值为 1 ，3-不仅正常传page，还传送了user参数，如此，你在index.asp中若想找到这些参数，如下：\r\n<pre lang="asp" colla="+">\r\n<%\r\n  inpage = trim(Request.QueryString("page"))\r\n  unames = trim(Request.QueryString("user"))\r\n%>\r\n</pre>\r\n这样便得到传送过来的参数的值并可以进行更多的判断了\r\nso：我们开始分页之旅\r\n<pre lang="asp" colla="-">\r\n<%\r\n  connstr="Driver={SQL Server};server=(local);uid=sa;database=dsdatabase;pwd=cc;"\r\n  Set conn = Server.CreateObject("ADODB.Connection")\r\n  conn.Open connstr\r\n  if conn.State <> 1 then\r\n      Set conn = Nothing\r\n      Response.Write "数据库连接出错！"\r\n      Response.Write "可能出错原因：数据库位置或名称不对、数据库损坏！"\r\n      Response.End\r\n  End if  \r\n%>\r\n<%\r\n  dim i,intpage,page,pre,last,filepath\r\n  intpage = 1\r\n  set rs = server.CreateObject("adodb.recordset")\r\n  sql = "select * from Goods"\r\n  rs.PageSize = 3\r\n  rs.CursorLocation = 3\r\n  rs.open sql,conn,0,2,1\r\n  pre = true\r\n  last = true\r\n  page = trim(Request.QueryString("page"))\r\n  if len(page) = 0 then\r\n 	inpage = 1\r\n	pre = false\r\n  else\r\n	if cint(page) =< 1 then\r\n        	intpage = 1\r\n		pre = false\r\n	else\r\n		if cint(page) >= rs.PageCount then\r\n			intpage = rs.PageCount\r\n			last = false\r\n		else\r\n			intpage = cint(page)\r\n		end if\r\n	end if\r\n  end if\r\n  if not rs.eof and intpage<>"" then\r\n	rs.absolutepage = intpage\r\n  end if\r\n%>\r\n**********循环内容开始*********\r\n<table border="0" cellpadding="0" cellspacing="1" bgcolor="#0000FF" width="80%" align="center">\r\n<input type="checkbox" id="mychk" name="mychk"  />\r\n<%\r\n  for i=0 to rs.pagesize-1\r\n  if rs.bof or rs.eof then exit for\r\n%>\r\n  <tr bgcolor="#FFFFFF" align="center">\r\n    <td><%=rs("Gname")%></td><td><%=rs("Gid")%></td><td><%=rs("Gprice")%></td>\r\n  </tr>\r\n<%\r\nrs.movenext()\r\nnext\r\n%>\r\n</table>\r\n**********循环显示的内容结束**********\r\n  <p align="center">\r\n    <a href="11.asp?page=1">首页</a>&nbsp;\r\n    <a href="11.asp?page=<%=intpage-1%>">前一页</a>&nbsp;\r\n    <a href="11.asp?page=<%=intpage+1%>">后一页</a>&nbsp;\r\n    <a href="11.asp?page=<%=rs.pagecount%>">末页</a>\r\n  </p>\r\n  <p align="center">现在是第<%=intpage%>页一共有<%=rs.pagecount%>页</p>\r\n</pre>\r\n', '电商整理（二）-asp分页问题【数据库分页】', '', 'inherit', 'open', 'open', '', '25-revision-7', '', '', '2012-10-15 16:34:51', '2012-10-15 16:34:51', '', 25, 'http://codeseeking.sinaapp.com/?p=32', 0, 'revision', '', 0),
(37, 1, '2012-10-16 00:53:12', '2012-10-16 00:53:12', 'cookies &　session　的创建时机我算是纠结了下，并不是因为不好创建，而是前期知识量不足导致页面安排混乱进而在进一步编写联系的时候就纠结了，首先说说ASP的cookies & session创建和使用：\r\n<pre lang="asp" colla="+">\r\n<%\r\n  ''Create cookies''\r\n  Response.Cookie("name") = "cc"\r\n  ''Create Session''\r\n  Session("name") = "charley"\r\n  ''get the cookies''\r\n  Request.Cookie("name")\r\n  ''get the session''\r\n  Session("name")\r\n%>\r\n</pre>\r\nsession本来就是一次会话生存期（？）的，而简单利用Response.Cookie("")来创建的cookies也只保存一次会话，关闭页面再次登录就不含有此次cookies了，其实这样适合多选商品，而本质是cookies的过期时间没有设置，so...JAVASCRIPT版使用\r\n<pre lang="javascript" colla="+">\r\n<script type="text/javascript">\r\n//actually document.cookie = ...\r\n\r\nfunction setCookie(cname,cvalue,expiredays){\r\n	var exdate=new Date()\r\n	exdate.setDate(exdate.getDate()+expiredays)\r\n	document.cookie=cname+ "=" +escape(cvalue)+ ((expiredays==null) ? "" : ";expires="+exdate.toGMTString())\r\n}\r\nfunction getCookie(c_name)\r\n{\r\nif (document.cookie.length>0)\r\n  {\r\n  c_start=document.cookie.indexOf(c_name + "=")\r\n  if (c_start!=-1)\r\n    { \r\n    c_start=c_start + c_name.length+1 \r\n    c_end=document.cookie.indexOf(";",c_start)\r\n    if (c_end==-1) c_end=document.cookie.length\r\n    return unescape(document.cookie.substring(c_start,c_end))\r\n    } \r\n  }\r\nreturn ""\r\n}\r\n</script>\r\n</pre>', '电商整理（三）-cookies & session', '', 'inherit', 'open', 'open', '', '33-revision-4', '', '', '2012-10-16 00:53:12', '2012-10-16 00:53:12', '', 33, 'http://codeseeking.sinaapp.com/?p=37', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(38, 1, '2012-10-16 02:00:49', '2012-10-16 02:00:49', 'Firstly，还是要抱怨下，偷什么懒偷什么懒，被dreamwear的模版整死了吧，明明没有少做什么却疼的为了填补那点点的懒惰付出了多少...唉，不过前端真不是人写的，@小默的研究中心 ， 快回火星去吧...好了，切回正题：\r\n1.表格，看似简单的东西其实可以有很多中选项，终于知道为啥word单元格选项有那么多长一段了，基本的\r\n<pre lang="asp" colla="+">\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td><input type="text" /></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</pre>\r\n暂时用到的就这些，但是..不代表它的东西少\r\ntable： width/border/bgcolor and especially style="margin-top:25px "margin参数设置表格位置\r\ntr： 一行拉，一般也就表示一行，没多少参数\r\ntd： 一列，除却一般的align width height等参数 有个colspan="A"的参数，指定这列的宽度是按照之前的几列来算，就是合并单元格的意思！\r\n说到这，不得不提的就是前端虽然要好看，要有序，但是不要图绝对的框架，因为前端框架再漂亮都要向里面放数据的，而大量的数据需要循环，如果，如果，这时候你的框架的结构不适合或者循环不能的话...那么恭喜，你能体味到我现在的心情了。行列的结合用一种类对象的想法吧，尽量一次让数据都显示完，不要有回溯，那很麻烦。 (4)input type 常用的就是 ，这里ps句，每个控件什么如果你还会用到它的话可以记得给他一个id，这样在后面的讲解里可以方便你寻找到它。submit 提交表单，经测试不论你怎么在js中判断或者return它还是会提交，所以如果你钥匙判断text什么为空的话还是放到button 最后给个form1.Submit()就好，相较之下button就比较灵活了，onClick="func()" 可以灵活的设置点击函数，而input就是输入拉，在form里name就是action页面的Request.QueryString(name)的值，而hidden 只为你的form多传递一些你想传传不过去的值，希望你不懂~呵呵 2.数组 asp数组用的真不多，因为很多信息在cookies和session中，但是有些时候数组的优势还是很明显的 在database Rs.recordset 中，先看代码先\r\n<pre lang="asp" colla="+">\r\n<%\r\n  Dim MyArray\r\n  MyArray = rs.GetRows()\r\n  a = UBound(MyArray,1)\r\n  b = UBound(MyArray,2)\r\n  Response.Write(a)&"<br>"\r\n  Response.Write(b)\r\n%>\r\n</pre>\r\n这段代码中，有两个函数 rs.GetRows() &amp; UBound(array,A) ，前一个是将数据集rs中的记录放到数组中，每一项记录是一个MaArray[i]，而ubound函数则是返回数组的上下界，方便循环取出... \r\n3.遍历，code first\r\n<pre lang="ASP" colla="+"> \r\n        item_str = "(''''"\r\n	index = 0\r\n\r\n	for each cookie in Request.Cookies\r\n    	if Request.Cookies(cookie)<> "" then\r\n        	item_str = item_str & ",''" & cookie & "''"\r\n        	i = i+1\r\n    	end if\r\n	next\r\n\r\n	item_str = item_str & ")"\r\n	sql = "SELECT * FROM Goods WHERE Gname in " & item_str & ";"\r\n	\r\n	set rs = server.CreateObject("adodb.recordset")\r\n	rs.Open sql,conn,1,1\r\n</pre>\r\n这里同样写出了遍历cookies的方法，其实session和application的遍历一样\r\nps：循环建立表格...遍历session，和一点点的jquery &amp; 用js遍历cookies CretaeTable 3 中...\r\n<pre lang="asp"><script type="text/javascript" src="http://code.jquery.com/jquery-1.8.2.min.js"></script><script type="text/javascript" language="javascript">\r\n $(function(){   \r\n  $("input:checkbox").click(function(){     \r\n    alert($(this).parent().parent().find(''a'').text());\r\n   }); \r\n }); \r\n  //this->javascript''element  => $(this)->JQuery''s element\r\n\r\n	<% 	For Each item In Session.Contents  		Response.Write "Session("""&item&""") = " & Session(item)  	Next  	%>\r\n\r\n   function createTable() {\r\n       var t = document.createElement(''table'');\r\n       for (var i = 0; i < 10; i++) {\r\n        var r = t.insertRow(0);\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = r.insertCell(0);\r\n         c.innerHTML = i + '','' + j;\r\n        }\r\n       }\r\n\r\n       document.getElementById(''table1'').appendChild(t);\r\n       t.setAttribute(''border'', ''1'');\r\n   }\r\n\r\n   function createTable2() {\r\n       var t = document.createElement(''table'');\r\n       var b = document.createElement(''tbody'');\r\n       for (var i = 0; i < 20; i++) {\r\n        var r = document.createElement(''tr'');\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = document.createElement(''td'');\r\n         var m = document.createTextNode(i + '','' + j);\r\n         c.appendChild(m);\r\n         r.appendChild(c);\r\n        }\r\n        b.appendChild(r);\r\n       } \r\n       t.appendChild(b);\r\n       document.getElementById(''table1'').appendChild(t);\r\n      t.setAttribute(''border'', ''1'');\r\n   }\r\n   function createTable4() {\r\n    var data = new Array();\r\n    data.push(''<table border=1><tbody>'');\r\n       for (var i = 0; i < 20; i++) {\r\n        data.push(''<tr>'');\r\n        for (var j = 0; j < 5; j++) {\r\n         data.push(''\r\n<td>'' + i + '','' + j + ''</td>'');}\r\n         data.push(''</tr>'');}\r\n       data.push(''</tbody><table>'');\r\n       document.getElementById(''table1'').innerHTML = data.join('''');\r\n   }\r\n   function createTable3() {\r\n    var   aCookie   =   document.cookie.split( "; "); \r\n    for   (var   i=0;   i   <   aCookie.length;   i++) \r\n    { \r\n        var   aCrumb   =   aCookie[i].split( ''='' ); \r\n	// 渲染\r\n	// name cookie\r\n		ckname = aCrumb[0]\r\n		if(aCrumb[1]!=""){		\r\n		}\r\n	}\r\n	var data = '''';\r\n        data += ''<table border=1><tbody>'';\r\n       for (var i = 0; i < 20; i++) {\r\n        data += ''<tr>'';\r\n        for (var j = 0; j < 5; j++) {\r\n         data += ''<td>'' + i + '','' + j + ''</td>'';\r\n        }\r\n        data += ''</tr>'';\r\n       }\r\n       data += ''</tbody><table>'';\r\n       document.getElementById(''table1'').innerHTML = data;\r\n   }\r\n   function showFunctionRunTime(f) {\r\n    var t1 = new Date();\r\n    f();\r\n    var t2 = new Date();\r\n    alert(t2 - t1);\r\n   }</pre>\r\n// ]]></script></pre>', '电商整理（四）-表格、数组-杂项', '', 'publish', 'open', 'open', '', '%e7%94%b5%e5%95%86%e6%95%b4%e7%90%86%ef%bc%88%e5%9b%9b%ef%bc%89-%e8%a1%a8%e6%a0%bc%e3%80%81%e6%95%b0%e7%bb%84-%e6%9d%82%e9%a1%b9', '', '', '2012-10-16 02:11:48', '2012-10-16 02:11:48', '', 0, 'http://codeseeking.sinaapp.com/?p=38', 0, 'post', '', 0),
(39, 1, '2012-10-16 01:17:06', '2012-10-16 01:17:06', 'Firstly，还是要抱怨下，偷什么懒偷什么懒，被dreamwear的模版整死了吧，明明没有少做什么却疼的为了填补那点点的懒惰付出了多少...唉，不过前端真不是人写的，@小默的研究中心 ， 快回火星去吧...好了，切回正题：\n1.表格，看似简单的东西其实可以有很多中选项，终于知道为啥word单元格选项有那么多长一段了，基本的\n<pre lang="asp" colla="+">\n<table>\n  <tr>\n    <td>\n    \n</pre>', '电商整理（四）-表格、数组-杂项', '', 'inherit', 'open', 'open', '', '38-revision', '', '', '2012-10-16 01:17:06', '2012-10-16 01:17:06', '', 38, 'http://codeseeking.sinaapp.com/?p=39', 0, 'revision', '', 0),
(40, 1, '2012-10-16 01:18:06', '2012-10-16 01:18:06', 'Firstly，还是要抱怨下，偷什么懒偷什么懒，被dreamwear的模版整死了吧，明明没有少做什么却疼的为了填补那点点的懒惰付出了多少...唉，不过前端真不是人写的，@小默的研究中心 ， 快回火星去吧...好了，切回正题：\n1.表格，看似简单的东西其实可以有很多中选项，终于知道为啥word单元格选项有那么多长一段了，基本的\n<pre lang="asp" colla="+">\n<table>\n  <tr>\n    <td>\n      <input .. />\n      <% .. %>\n    </td>\n  </tr>\n</table>\n</pre>', '电商整理（四）-表格、数组-杂项', '', 'inherit', 'open', 'open', '', '38-revision-2', '', '', '2012-10-16 01:18:06', '2012-10-16 01:18:06', '', 38, 'http://codeseeking.sinaapp.com/?p=40', 0, 'revision', '', 0),
(43, 1, '2012-10-16 02:09:21', '2012-10-16 02:09:21', 'Firstly，还是要抱怨下，偷什么懒偷什么懒，被dreamwear的模版整死了吧，明明没有少做什么却疼的为了填补那点点的懒惰付出了多少...唉，不过前端真不是人写的，@小默的研究中心 ， 快回火星去吧...好了，切回正题：\r\n1.表格，看似简单的东西其实可以有很多中选项，终于知道为啥word单元格选项有那么多长一段了，基本的\r\n<pre lang="asp">\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td><input type="text" /></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</pre>\r\n暂时用到的就这些，但是..不代表它的东西少\r\ntable： width/border/bgcolor and especially style="margin-top:25px "margin参数设置表格位置\r\ntr： 一行拉，一般也就表示一行，没多少参数\r\ntd： 一列，除却一般的align width height等参数 有个colspan="A"的参数，指定这列的宽度是按照之前的几列来算，就是合并单元格的意思！\r\n说到这，不得不提的就是前端虽然要好看，要有序，但是不要图绝对的框架，因为前端框架再漂亮都要向里面放数据的，而大量的数据需要循环，如果，如果，这时候你的框架的结构不适合或者循环不能的话...那么恭喜，你能体味到我现在的心情了。行列的结合用一种类对象的想法吧，尽量一次让数据都显示完，不要有回溯，那很麻烦。 (4)input type 常用的就是 ，这里ps句，每个控件什么如果你还会用到它的话可以记得给他一个id，这样在后面的讲解里可以方便你寻找到它。submit 提交表单，经测试不论你怎么在js中判断或者return它还是会提交，所以如果你钥匙判断text什么为空的话还是放到button 最后给个form1.Submit()就好，相较之下button就比较灵活了，onClick="func()" 可以灵活的设置点击函数，而input就是输入拉，在form里name就是action页面的Request.QueryString(name)的值，而hidden 只为你的form多传递一些你想传传不过去的值，希望你不懂~呵呵 2.数组 asp数组用的真不多，因为很多信息在cookies和session中，但是有些时候数组的优势还是很明显的 在database Rs.recordset 中，先看代码先\r\n<pre lang="asp">\r\n这段代码中，有两个函数 rs.GetRows() &amp; UBound(array,A) ，前一个是将数据集rs中的记录放到数组中，每一项记录是一个MaArray[i]，而ubound函数则是返回数组的上下界，方便循环取出... \r\n3.遍历，code first\r\n<pre lang="ASP" colla="+"> \r\n        item_str = "(''''"\r\n	index = 0\r\n\r\n	for each cookie in Request.Cookies\r\n    	if Request.Cookies(cookie)<> "" then\r\n        	item_str = item_str & ",''" & cookie & "''"\r\n        	i = i+1\r\n    	end if\r\n	next\r\n\r\n	item_str = item_str & ")"\r\n	sql = "SELECT * FROM Goods WHERE Gname in " & item_str & ";"\r\n	\r\n	set rs = server.CreateObject("adodb.recordset")\r\n	rs.Open sql,conn,1,1\r\n</pre>\r\n这里同样写出了遍历cookies的方法，其实session和application的遍历一样\r\nps：循环建立表格...遍历session，和一点点的jquery &amp; 用js遍历cookies CretaeTable 3 中...\r\n<pre lang="asp"><script type="text/javascript" src="http://code.jquery.com/jquery-1.8.2.min.js"></script><script type="text/javascript" language="javascript">\r\n $(function(){   \r\n  $("input:checkbox").click(function(){     \r\n    alert($(this).parent().parent().find(''a'').text());\r\n   }); \r\n }); \r\n  //this->javascript''element  => $(this)->JQuery''s element\r\n\r\n	<% 	For Each item In Session.Contents  		Response.Write "Session("""&item&""") = " & Session(item)  	Next  	%>\r\n\r\n   function createTable() {\r\n       var t = document.createElement(''table'');\r\n       for (var i = 0; i < 10; i++) {\r\n        var r = t.insertRow(0);\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = r.insertCell(0);\r\n         c.innerHTML = i + '','' + j;\r\n        }\r\n       }\r\n\r\n       document.getElementById(''table1'').appendChild(t);\r\n       t.setAttribute(''border'', ''1'');\r\n   }\r\n\r\n   function createTable2() {\r\n       var t = document.createElement(''table'');\r\n       var b = document.createElement(''tbody'');\r\n       for (var i = 0; i < 20; i++) {\r\n        var r = document.createElement(''tr'');\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = document.createElement(''td'');\r\n         var m = document.createTextNode(i + '','' + j);\r\n         c.appendChild(m);\r\n         r.appendChild(c);\r\n        }\r\n        b.appendChild(r);\r\n       } \r\n       t.appendChild(b);\r\n       document.getElementById(''table1'').appendChild(t);\r\n      t.setAttribute(''border'', ''1'');\r\n   }\r\n   function createTable4() {\r\n    var data = new Array();\r\n    data.push(''<table border=1><tbody>'');\r\n       for (var i = 0; i < 20; i++) {\r\n        data.push(''<tr>'');\r\n        for (var j = 0; j < 5; j++) {\r\n         data.push(''\r\n<td>'' + i + '','' + j + ''</td>'');}\r\n         data.push(''</tr>'');}\r\n       data.push(''</tbody><table>'');\r\n       document.getElementById(''table1'').innerHTML = data.join('''');\r\n   }\r\n   function createTable3() {\r\n    var   aCookie   =   document.cookie.split( "; "); \r\n    for   (var   i=0;   i   <   aCookie.length;   i++) \r\n    { \r\n        var   aCrumb   =   aCookie[i].split( ''='' ); \r\n	// 渲染\r\n	// name cookie\r\n		ckname = aCrumb[0]\r\n		if(aCrumb[1]!=""){		\r\n		}\r\n	}\r\n	var data = '''';\r\n        data += ''<table border=1><tbody>'';\r\n       for (var i = 0; i < 20; i++) {\r\n        data += ''<tr>'';\r\n        for (var j = 0; j < 5; j++) {\r\n         data += ''<td>'' + i + '','' + j + ''</td>'';\r\n        }\r\n        data += ''</tr>'';\r\n       }\r\n       data += ''</tbody><table>'';\r\n       document.getElementById(''table1'').innerHTML = data;\r\n   }\r\n   function showFunctionRunTime(f) {\r\n    var t1 = new Date();\r\n    f();\r\n    var t2 = new Date();\r\n    alert(t2 - t1);\r\n   }</pre>\r\n// ]]></script></pre>', '电商整理（四）-表格、数组-杂项', '', 'inherit', 'open', 'open', '', '38-revision-4', '', '', '2012-10-16 02:09:21', '2012-10-16 02:09:21', '', 38, 'http://codeseeking.sinaapp.com/?p=43', 0, 'revision', '', 0),
(41, 1, '2012-10-16 02:11:39', '2012-10-16 02:11:39', 'Firstly，还是要抱怨下，偷什么懒偷什么懒，被dreamwear的模版整死了吧，明明没有少做什么却疼的为了填补那点点的懒惰付出了多少...唉，不过前端真不是人写的，@小默的研究中心 ， 快回火星去吧...好了，切回正题：\r\n1.表格，看似简单的东西其实可以有很多中选项，终于知道为啥word单元格选项有那么多长一段了，基本的\r\n<pre lang="asp" colla="+">\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td><input type="text" /></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</pre>\r\n暂时用到的就这些，但是..不代表它的东西少\r\ntable： width/border/bgcolor and especially style="margin-top:25px "margin参数设置表格位置\r\ntr： 一行拉，一般也就表示一行，没多少参数\r\ntd： 一列，除却一般的align width height等参数 有个colspan="A"的参数，指定这列的宽度是按照之前的几列来算，就是合并单元格的意思！\r\n说到这，不得不提的就是前端虽然要好看，要有序，但是不要图绝对的框架，因为前端框架再漂亮都要向里面放数据的，而大量的数据需要循环，如果，如果，这时候你的框架的结构不适合或者循环不能的话...那么恭喜，你能体味到我现在的心情了。行列的结合用一种类对象的想法吧，尽量一次让数据都显示完，不要有回溯，那很麻烦。 (4)input type 常用的就是 ，这里ps句，每个控件什么如果你还会用到它的话可以记得给他一个id，这样在后面的讲解里可以方便你寻找到它。submit 提交表单，经测试不论你怎么在js中判断或者return它还是会提交，所以如果你钥匙判断text什么为空的话还是放到button 最后给个form1.Submit()就好，相较之下button就比较灵活了，onClick="func()" 可以灵活的设置点击函数，而input就是输入拉，在form里name就是action页面的Request.QueryString(name)的值，而hidden 只为你的form多传递一些你想传传不过去的值，希望你不懂~呵呵 2.数组 asp数组用的真不多，因为很多信息在cookies和session中，但是有些时候数组的优势还是很明显的 在database Rs.recordset 中，先看代码先\r\n<pre lang="asp" colla="+">\r\n<%\r\n  Dim MyArray\r\n  MyArray = rs.GetRows()\r\n  a = UBound(MyArray,1)\r\n  b = UBound(MyArray,2)\r\n  Response.Write(a)&"<br>"\r\n  Response.Write(b)\r\n%>\r\n</pre>\r\n这段代码中，有两个函数 rs.GetRows() &amp; UBound(array,A) ，前一个是将数据集rs中的记录放到数组中，每一项记录是一个MaArray[i]，而ubound函数则是返回数组的上下界，方便循环取出... \r\n3.遍历，code first\r\n<pre lang="ASP" colla="+"> \r\n        item_str = "(''''"\r\n	index = 0\r\n\r\n	for each cookie in Request.Cookies\r\n    	if Request.Cookies(cookie)<> "" then\r\n        	item_str = item_str & ",''" & cookie & "''"\r\n        	i = i+1\r\n    	end if\r\n	next\r\n\r\n	item_str = item_str & ")"\r\n	sql = "SELECT * FROM Goods WHERE Gname in " & item_str & ";"\r\n	\r\n	set rs = server.CreateObject("adodb.recordset")\r\n	rs.Open sql,conn,1,1\r\n</pre>\r\n这里同样写出了遍历cookies的方法，其实session和application的遍历一样\r\nps：循环建立表格...遍历session，和一点点的jquery &amp; 用js遍历cookies CretaeTable 3 中...\r\n<pre lang="asp"><script type="text/javascript" src="http://code.jquery.com/jquery-1.8.2.min.js"></script><script type="text/javascript" language="javascript">\r\n $(function(){   \r\n  $("input:checkbox").click(function(){     \r\n    alert($(this).parent().parent().find(''a'').text());\r\n   }); \r\n }); \r\n  //this->javascript''element  => $(this)->JQuery''s element\r\n\r\n	<% 	For Each item In Session.Contents  		Response.Write "Session("""&item&""") = " & Session(item)  	Next  	%>\r\n\r\n   function createTable() {\r\n       var t = document.createElement(''table'');\r\n       for (var i = 0; i < 10; i++) {\r\n        var r = t.insertRow(0);\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = r.insertCell(0);\r\n         c.innerHTML = i + '','' + j;\r\n        }\r\n       }\r\n\r\n       document.getElementById(''table1'').appendChild(t);\r\n       t.setAttribute(''border'', ''1'');\r\n   }\r\n\r\n   function createTable2() {\r\n       var t = document.createElement(''table'');\r\n       var b = document.createElement(''tbody'');\r\n       for (var i = 0; i < 20; i++) {\r\n        var r = document.createElement(''tr'');\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = document.createElement(''td'');\r\n         var m = document.createTextNode(i + '','' + j);\r\n         c.appendChild(m);\r\n         r.appendChild(c);\r\n        }\r\n        b.appendChild(r);\r\n       } \r\n       t.appendChild(b);\r\n       document.getElementById(''table1'').appendChild(t);\r\n      t.setAttribute(''border'', ''1'');\r\n   }\r\n   function createTable4() {\r\n    var data = new Array();\r\n    data.push(''<table border=1><tbody>'');\r\n       for (var i = 0; i < 20; i++) {\r\n        data.push(''<tr>'');\r\n        for (var j = 0; j < 5; j++) {\r\n         data.push(''\r\n<td>'' + i + '','' + j + ''</td>'');}\r\n         data.push(''</tr>'');}\r\n       data.push(''</tbody><table>'');\r\n       document.getElementById(''table1'').innerHTML = data.join('''');\r\n   }\r\n   function createTable3() {\r\n    var   aCookie   =   document.cookie.split( "; "); \r\n    for   (var   i=0;   i   <   aCookie.length;   i++) \r\n    { \r\n        var   aCrumb   =   aCookie[i].split( ''='' ); \r\n	// 渲染\r\n	// name cookie\r\n		ckname = aCrumb[0]\r\n		if(aCrumb[1]!=""){		\r\n		}\r\n	}\r\n	var data = '''';\r\n        data += ''<table border=1><tbody>'';\r\n       for (var i = 0; i < 20; i++) {\r\n        data += ''<tr>'';\r\n        for (var j = 0; j < 5; j++) {\r\n         data += ''<td>'' + i + '','' + j + ''</td>'';\r\n        }\r\n        data += ''</tr>'';\r\n       }\r\n       data += ''</tbody><table>'';\r\n       document.getElementById(''table1'').innerHTML = data;\r\n   }\r\n   function showFunctionRunTime(f) {\r\n    var t1 = new Date();\r\n    f();\r\n    var t2 = new Date();\r\n    alert(t2 - t1);\r\n   }</pre>\r\n// ]]></script></pre>', '电商整理（四）-表格、数组-杂项', '', 'inherit', 'open', 'open', '', '38-autosave', '', '', '2012-10-16 02:11:39', '2012-10-16 02:11:39', '', 38, 'http://codeseeking.sinaapp.com/?p=41', 0, 'revision', '', 0),
(42, 1, '2012-10-16 02:00:49', '2012-10-16 02:00:49', 'Firstly，还是要抱怨下，偷什么懒偷什么懒，被dreamwear的模版整死了吧，明明没有少做什么却疼的为了填补那点点的懒惰付出了多少...唉，不过前端真不是人写的，@小默的研究中心 ， 快回火星去吧...好了，切回正题：\r\n1.表格，看似简单的东西其实可以有很多中选项，终于知道为啥word单元格选项有那么多长一段了，基本的\r\n<pre lang="asp" colla="+">\r\n<table>\r\n  <tr>\r\n    <td>\r\n      <input .. />\r\n      <% .. %>\r\n    </td>\r\n  </tr>\r\n</table>\r\n</pre>\r\n暂时用到的就这些，但是..不代表它的东西少\r\n(1)<table> width/border/bgcolor and especially style="margin-top:25px "margin参数设置表格位置\r\n(2)<tr> 一行拉，一般也就表示一行，没多少参数\r\n(3)<td> 一列，除却一般的align width height等参数 有个colspan="A"的参数，指定这列的宽度是按照之前的几列来算，就是合并单元格的意思！\r\n说到这，不得不提的就是前端虽然要好看，要有序，但是不要图绝对的框架，因为前端框架再漂亮都要向里面放数据的，而大量的数据需要循环，如果，如果，这时候你的框架<table>的结构不适合或者循环不能的话...那么恭喜，你能体味到我现在的心情了。行列的结合用一种类对象的想法吧，尽量一次让数据都显示完，不要有回溯，那很麻烦。\r\n(4)<input> type 常用的就是 <submit/button/text/hidden>，这里ps句，每个控件什么如果你还会用到它的话可以记得给他一个id，这样在后面的讲解里可以方便你寻找到它。submit 提交表单，经测试不论你怎么在js中判断或者return它还是会提交，所以如果你钥匙判断text什么为空的话还是放到button 最后给个form1.Submit()就好，相较之下button就比较灵活了，onClick="func()" 可以灵活的设置点击函数，而input就是输入拉，在form里name就是action页面的Request.QueryString(name)的值，而hidden 只为你的form多传递一些你想传传不过去的值，希望你不懂~呵呵 \r\n2.数组\r\nasp数组用的真不多，因为很多信息在cookies和session中，但是有些时候数组的优势还是很明显的\r\n在database  Rs.recordset 中，先看代码先\r\n<pre lang="asp" colla="+">\r\n<%\r\n  //connect to db & sql omitted\r\n  Dim MyArray\r\n  MyArray = rs.GetRows()\r\n  a = UBound(MyArray,1)\r\n  b = UBound(MyArray,2)\r\n  Response.Write(a)&"<br>"\r\n  Response.Write(b)\r\n%>\r\n</pre>\r\n这段代码中，有两个函数 rs.GetRows() & UBound(array,A) ，前一个是将数据集rs中的记录放到数组中，每一项记录是一个MaArray[i]，而ubound函数则是返回数组的上下界，方便循环取出...\r\n3.遍历，code first\r\n<pre lang="ASP" colla="+">\r\n<%\r\n	item_str = "(''''"\r\n	index = 0\r\n	for each cookie in Request.Cookies\r\n    	if Request.Cookies(cookie)<> "" then\r\n        	item_str = item_str & ",''" & cookie & "''"\r\n        	i = i+1\r\n    	end if\r\n	next\r\n	item_str = item_str & ")"\r\n	sql = "SELECT * FROM Goods WHERE Gname in " & item_str & ";"\r\n	set rs = server.CreateObject("adodb.recordset")\r\n	rs.Open sql,conn,1,1\r\n%>\r\n</pre>\r\n这里同样写出了遍历cookies的方法，其实session和application的遍历一样\r\nps：循环建立表格...遍历session，和一点点的jquery & 用js遍历cookies CretaeTable 3 中...\r\n<pre lang = "asp" colla="-">\r\n<script type="text/javascript" src="http://code.jquery.com/jquery-1.8.2.min.js"></script>\r\n<script language="javascript">\r\n$(function(){\r\n  $("input:checkbox").click(function(){\r\n    alert($(this).parent().parent().find(''a'').text());\r\n  });\r\n});\r\nthis->javascript''element  => $(this)->JQuery''s element\r\n\r\n	<%\r\n	For Each item In Session.Contents \r\n		Response.Write "Session("""&item&""") = " & Session(item) \r\n	Next \r\n	%>\r\n\r\n   function createTable() {\r\n       var t = document.createElement(''table'');\r\n       for (var i = 0; i < 10; i++) {\r\n        var r = t.insertRow(0);\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = r.insertCell(0);\r\n         c.innerHTML = i + '','' + j;\r\n        }\r\n       }\r\n       \r\n       document.getElementById(''table1'').appendChild(t);\r\n       t.setAttribute(''border'', ''1'');\r\n   }\r\n   \r\n   function createTable2() {\r\n       var t = document.createElement(''table'');\r\n       var b = document.createElement(''tbody'');\r\n       for (var i = 0; i < 20; i++) {\r\n        var r = document.createElement(''tr'');\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = document.createElement(''td'');\r\n         var m = document.createTextNode(i + '','' + j);\r\n         c.appendChild(m);\r\n         r.appendChild(c);\r\n        }\r\n        b.appendChild(r);\r\n       } \r\n       t.appendChild(b);\r\n       document.getElementById(''table1'').appendChild(t);\r\n      t.setAttribute(''border'', ''1'');\r\n   }\r\n   function createTable4() {\r\n    var data = new Array();\r\n    data.push(''<table border=1><tbody>'');\r\n       for (var i = 0; i < 20; i++) {\r\n        data.push(''<tr>'');\r\n        for (var j = 0; j < 5; j++) {\r\n         data.push(''<td>'' + i + '','' + j + ''</td>'');\r\n        }\r\n        data.push(''</tr>'');\r\n       }\r\n       data.push(''</tbody><table>'');\r\n       \r\n       document.getElementById(''table1'').innerHTML = data.join('''');\r\n   }\r\n   function createTable3() {\r\n    var   aCookie   =   document.cookie.split( "; "); \r\n    for   (var   i=0;   i   <   aCookie.length;   i++) \r\n    { \r\n        var   aCrumb   =   aCookie[i].split( ''='' ); \r\n	// 渲染\r\n	// name cookie\r\n		ckname = aCrumb[0]\r\n		if(aCrumb[1]!=""){		\r\n		}\r\n	}\r\n	var data = '''';\r\n    data += ''<table border=1><tbody>'';\r\n       for (var i = 0; i < 20; i++) {\r\n        data += ''<tr>'';\r\n        for (var j = 0; j < 5; j++) {\r\n         data += ''<td>'' + i + '','' + j + ''</td>'';\r\n        }\r\n        data += ''</tr>'';\r\n       }\r\n       data += ''</tbody><table>'';\r\n       \r\n       document.getElementById(''table1'').innerHTML = data;\r\n   }\r\n   function showFunctionRunTime(f) {\r\n    var t1 = new Date();\r\n    f();\r\n    var t2 = new Date();\r\n    alert(t2 - t1);\r\n   }\r\n</pre>', '电商整理（四）-表格、数组-杂项', '', 'inherit', 'open', 'open', '', '38-revision-3', '', '', '2012-10-16 02:00:49', '2012-10-16 02:00:49', '', 38, 'http://codeseeking.sinaapp.com/?p=42', 0, 'revision', '', 0),
(44, 1, '2012-10-16 02:09:55', '2012-10-16 02:09:55', 'Firstly，还是要抱怨下，偷什么懒偷什么懒，被dreamwear的模版整死了吧，明明没有少做什么却疼的为了填补那点点的懒惰付出了多少...唉，不过前端真不是人写的，@小默的研究中心 ， 快回火星去吧...好了，切回正题：\r\n1.表格，看似简单的东西其实可以有很多中选项，终于知道为啥word单元格选项有那么多长一段了，基本的\r\n<pre lang="asp" colla="+">\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td><input type="text" /></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</pre>\r\n暂时用到的就这些，但是..不代表它的东西少\r\ntable： width/border/bgcolor and especially style="margin-top:25px "margin参数设置表格位置\r\ntr： 一行拉，一般也就表示一行，没多少参数\r\ntd： 一列，除却一般的align width height等参数 有个colspan="A"的参数，指定这列的宽度是按照之前的几列来算，就是合并单元格的意思！\r\n说到这，不得不提的就是前端虽然要好看，要有序，但是不要图绝对的框架，因为前端框架再漂亮都要向里面放数据的，而大量的数据需要循环，如果，如果，这时候你的框架的结构不适合或者循环不能的话...那么恭喜，你能体味到我现在的心情了。行列的结合用一种类对象的想法吧，尽量一次让数据都显示完，不要有回溯，那很麻烦。 (4)input type 常用的就是 ，这里ps句，每个控件什么如果你还会用到它的话可以记得给他一个id，这样在后面的讲解里可以方便你寻找到它。submit 提交表单，经测试不论你怎么在js中判断或者return它还是会提交，所以如果你钥匙判断text什么为空的话还是放到button 最后给个form1.Submit()就好，相较之下button就比较灵活了，onClick="func()" 可以灵活的设置点击函数，而input就是输入拉，在form里name就是action页面的Request.QueryString(name)的值，而hidden 只为你的form多传递一些你想传传不过去的值，希望你不懂~呵呵 2.数组 asp数组用的真不多，因为很多信息在cookies和session中，但是有些时候数组的优势还是很明显的 在database Rs.recordset 中，先看代码先\r\n<pre lang="asp">\r\n这段代码中，有两个函数 rs.GetRows() &amp; UBound(array,A) ，前一个是将数据集rs中的记录放到数组中，每一项记录是一个MaArray[i]，而ubound函数则是返回数组的上下界，方便循环取出... \r\n3.遍历，code first\r\n<pre lang="ASP" colla="+"> \r\n        item_str = "(''''"\r\n	index = 0\r\n\r\n	for each cookie in Request.Cookies\r\n    	if Request.Cookies(cookie)<> "" then\r\n        	item_str = item_str & ",''" & cookie & "''"\r\n        	i = i+1\r\n    	end if\r\n	next\r\n\r\n	item_str = item_str & ")"\r\n	sql = "SELECT * FROM Goods WHERE Gname in " & item_str & ";"\r\n	\r\n	set rs = server.CreateObject("adodb.recordset")\r\n	rs.Open sql,conn,1,1\r\n</pre>\r\n这里同样写出了遍历cookies的方法，其实session和application的遍历一样\r\nps：循环建立表格...遍历session，和一点点的jquery &amp; 用js遍历cookies CretaeTable 3 中...\r\n<pre lang="asp"><script type="text/javascript" src="http://code.jquery.com/jquery-1.8.2.min.js"></script><script type="text/javascript" language="javascript">\r\n $(function(){   \r\n  $("input:checkbox").click(function(){     \r\n    alert($(this).parent().parent().find(''a'').text());\r\n   }); \r\n }); \r\n  //this->javascript''element  => $(this)->JQuery''s element\r\n\r\n	<% 	For Each item In Session.Contents  		Response.Write "Session("""&item&""") = " & Session(item)  	Next  	%>\r\n\r\n   function createTable() {\r\n       var t = document.createElement(''table'');\r\n       for (var i = 0; i < 10; i++) {\r\n        var r = t.insertRow(0);\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = r.insertCell(0);\r\n         c.innerHTML = i + '','' + j;\r\n        }\r\n       }\r\n\r\n       document.getElementById(''table1'').appendChild(t);\r\n       t.setAttribute(''border'', ''1'');\r\n   }\r\n\r\n   function createTable2() {\r\n       var t = document.createElement(''table'');\r\n       var b = document.createElement(''tbody'');\r\n       for (var i = 0; i < 20; i++) {\r\n        var r = document.createElement(''tr'');\r\n        for (var j = 0; j < 5; j++) {\r\n         var c = document.createElement(''td'');\r\n         var m = document.createTextNode(i + '','' + j);\r\n         c.appendChild(m);\r\n         r.appendChild(c);\r\n        }\r\n        b.appendChild(r);\r\n       } \r\n       t.appendChild(b);\r\n       document.getElementById(''table1'').appendChild(t);\r\n      t.setAttribute(''border'', ''1'');\r\n   }\r\n   function createTable4() {\r\n    var data = new Array();\r\n    data.push(''<table border=1><tbody>'');\r\n       for (var i = 0; i < 20; i++) {\r\n        data.push(''<tr>'');\r\n        for (var j = 0; j < 5; j++) {\r\n         data.push(''\r\n<td>'' + i + '','' + j + ''</td>'');}\r\n         data.push(''</tr>'');}\r\n       data.push(''</tbody><table>'');\r\n       document.getElementById(''table1'').innerHTML = data.join('''');\r\n   }\r\n   function createTable3() {\r\n    var   aCookie   =   document.cookie.split( "; "); \r\n    for   (var   i=0;   i   <   aCookie.length;   i++) \r\n    { \r\n        var   aCrumb   =   aCookie[i].split( ''='' ); \r\n	// 渲染\r\n	// name cookie\r\n		ckname = aCrumb[0]\r\n		if(aCrumb[1]!=""){		\r\n		}\r\n	}\r\n	var data = '''';\r\n        data += ''<table border=1><tbody>'';\r\n       for (var i = 0; i < 20; i++) {\r\n        data += ''<tr>'';\r\n        for (var j = 0; j < 5; j++) {\r\n         data += ''<td>'' + i + '','' + j + ''</td>'';\r\n        }\r\n        data += ''</tr>'';\r\n       }\r\n       data += ''</tbody><table>'';\r\n       document.getElementById(''table1'').innerHTML = data;\r\n   }\r\n   function showFunctionRunTime(f) {\r\n    var t1 = new Date();\r\n    f();\r\n    var t2 = new Date();\r\n    alert(t2 - t1);\r\n   }</pre>\r\n// ]]></script></pre>', '电商整理（四）-表格、数组-杂项', '', 'inherit', 'open', 'open', '', '38-revision-5', '', '', '2012-10-16 02:09:55', '2012-10-16 02:09:55', '', 38, 'http://codeseeking.sinaapp.com/?p=44', 0, 'revision', '', 0),
(46, 1, '2012-10-15 06:34:48', '2012-10-15 06:34:48', '', '自动草稿', '', 'inherit', 'open', 'open', '', '3-revision', '', '', '2012-10-15 06:34:48', '2012-10-15 06:34:48', '', 3, '', 0, 'revision', '', 0),
(48, 1, '2013-02-08 12:22:44', '2013-02-08 12:22:44', '我爱的人-陈小春\r\n我没那种命-陈小春\r\n再遇见-苏打绿\r\n喜欢寂寞-苏打绿', '音乐-更新', '', 'publish', 'open', 'open', '', '%e9%9f%b3%e4%b9%90-%e6%9b%b4%e6%96%b0', '', '', '2014-05-21 08:18:08', '2014-05-21 08:18:08', '', 0, 'http://codeseeking.sinaapp.com/?p=48', 0, 'post', '', 0),
(49, 1, '2013-02-08 12:22:15', '2013-02-08 12:22:15', '', '自动草稿', '', 'inherit', 'open', 'open', '', '48-revision', '', '', '2013-02-08 12:22:15', '2013-02-08 12:22:15', '', 48, '', 0, 'revision', '', 0),
(51, 1, '2013-03-13 07:10:04', '2013-03-13 07:10:04', '', 'premake4 for linux', '', 'inherit', 'open', 'open', '', '50-revision', '', '', '2013-03-13 07:10:04', '2013-03-13 07:10:04', '', 50, 'http://codeseeking.sinaapp.com/?p=51', 0, 'revision', '', 0),
(52, 1, '2013-03-13 07:31:30', '2013-03-13 07:31:30', '今天尝试配置了下premake4，虽然linux工程管理又很多，如make/cmake/automake...但是同学说这个简单这个方便这个跨平台什么什么的，好吧，试试吧，虽然有点疼。\n首先，http://industriousone.com/premake 下载最新版本的premake4，tar包解压后是可执行文件，记得把它放到默认搜索路径中去（usr/bin）这样在命令行才可以当命令用，不然就只能在这个解压的文件夹上使用，另外一个是源码包，里面又很多examples和一些配置。script文件夹在使用时需cp到工程文件夹里（ps：premake4.lua也是哦）\n这里只是premake4的一些事情，还有就是lua环境的配置，http://www.lua.org/ 在这下载最新的lua包，tar -xzvf解压，make..这里make需要注意选择自己的系统，"make xxx", where xxx is your platform name，这里可能显示can''t find -lxxx 指的是缺少xxx库，-l是参数 如premake时缺少 -lreadline ，通过sudo apt-cache search xx 可以从软件包列表里搜索，这里的库是 libreadline-dev..安装后即可。这样lua也配置好了。\n最后就是', 'premake4 for linux', '', 'inherit', 'open', 'open', '', '50-revision-2', '', '', '2013-03-13 07:31:30', '2013-03-13 07:31:30', '', 50, 'http://codeseeking.sinaapp.com/?p=52', 0, 'revision', '', 0),
(53, 1, '2013-03-13 07:32:08', '2013-03-13 07:32:08', '今天尝试配置了下premake4，虽然linux工程管理又很多，如make/cmake/automake...但是同学说这个简单这个方便这个跨平台什么什么的，好吧，试试吧，虽然有点疼。\r\n首先，http://industriousone.com/premake 下载最新版本的premake4，tar包解压后是可执行文件，记得把它放到默认搜索路径中去（usr/bin）这样在命令行才可以当命令用，不然就只能在这个解压的文件夹上使用，另外一个是源码包，里面又很多examples和一些配置。script文件夹在使用时需cp到工程文件夹里（ps：premake4.lua也是哦）\r\n这里只是premake4的一些事情，还有就是lua环境的配置，http://www.lua.org/ 在这下载最新的lua包，tar -xzvf解压，make..这里make需要注意选择自己的系统，"make xxx", where xxx is your platform name，这里可能显示can''t find -lxxx 指的是缺少xxx库，-l是参数 如premake时缺少 -lreadline ，通过sudo apt-cache search xx 可以从软件包列表里搜索，这里的库是 libreadline-dev..安装后即可。这样lua也配置好了。\r\n最后就是看例子学习了，唉，http://industriousone.com/scripting-premake讲的很好。', 'premake4 for linux', '', 'inherit', 'open', 'open', '', '50-revision-3', '', '', '2013-03-13 07:32:08', '2013-03-13 07:32:08', '', 50, 'http://codeseeking.sinaapp.com/?p=53', 0, 'revision', '', 0),
(54, 1, '2013-03-13 07:34:32', '2013-03-13 07:34:32', '今天尝试配置了下premake4，虽然linux工程管理又很多，如make/cmake/automake...但是同学说这个简单这个方便这个跨平台什么什么的，好吧，试试吧，虽然有点疼。\r\n首先，http://industriousone.com/premake 下载最新版本的premake4，tar包解压后是可执行文件，记得把它放到默认搜索路径中去（usr/bin）这样在命令行才可以当命令用，不然就只能在这个解压的文件夹上使用，另外一个是源码包，里面又很多examples和一些配置。script文件夹在使用时需cp到工程文件夹里（ps：premake4.lua也是哦）\r\n这里只是premake4的一些事情，还有就是lua环境的配置，http://www.lua.org/ 在这下载最新的lua包，tar -xzvf解压，make..这里make需要注意选择自己的系统，"make xxx", where xxx is your platform name，这里可能显示can''t find -lxxx 指的是缺少xxx库，-l是参数 如premake时缺少 -lreadline ，通过sudo apt-cache search xx 可以从软件包列表里搜索，这里的库是 libreadline-dev..安装后即可。这样lua也配置好了。\r\n最后就是看例子学习了，唉，http://industriousone.com/scripting-premake讲的很好。\r\n\r\nps：Lua 5.1 Reference Manual ： <a href="http://www.lua.org/manual/5.1/" title="Lua 5.1 Reference Manual " target="_blank"></a>http://www.lua.org/manual/5.1/\r\n    Scripting Reference ： http://industriousone.com/scripting-reference', 'premake4 for linux', '', 'inherit', 'open', 'open', '', '50-autosave', '', '', '2013-03-13 07:34:32', '2013-03-13 07:34:32', '', 50, 'http://codeseeking.sinaapp.com/?p=54', 0, 'revision', '', 0),
(55, 1, '2013-03-13 07:33:50', '2013-03-13 07:33:50', '今天尝试配置了下premake4，虽然linux工程管理又很多，如make/cmake/automake...但是同学说这个简单这个方便这个跨平台什么什么的，好吧，试试吧，虽然有点疼。\r\n首先，http://industriousone.com/premake 下载最新版本的premake4，tar包解压后是可执行文件，记得把它放到默认搜索路径中去（usr/bin）这样在命令行才可以当命令用，不然就只能在这个解压的文件夹上使用，另外一个是源码包，里面又很多examples和一些配置。script文件夹在使用时需cp到工程文件夹里（ps：premake4.lua也是哦）\r\n这里只是premake4的一些事情，还有就是lua环境的配置，http://www.lua.org/ 在这下载最新的lua包，tar -xzvf解压，make..这里make需要注意选择自己的系统，"make xxx", where xxx is your platform name，这里可能显示can''t find -lxxx 指的是缺少xxx库，-l是参数 如premake时缺少 -lreadline ，通过sudo apt-cache search xx 可以从软件包列表里搜索，这里的库是 libreadline-dev..安装后即可。这样lua也配置好了。\r\n最后就是看例子学习了，唉，http://industriousone.com/scripting-premake讲的很好。\r\n\r\nps：Lua 5.1 Reference Manual ： http://www.lua.org/manual/5.1/\r\n    Scripting Reference ： http://industriousone.com/scripting-reference', 'premake4 for linux', '', 'inherit', 'open', 'open', '', '50-revision-4', '', '', '2013-03-13 07:33:50', '2013-03-13 07:33:50', '', 50, 'http://codeseeking.sinaapp.com/?p=55', 0, 'revision', '', 0),
(64, 1, '2013-04-11 07:46:58', '2013-04-11 07:46:58', '', '终端快捷键', '', 'inherit', 'open', 'open', '', '63-revision', '', '', '2013-04-11 07:46:58', '2013-04-11 07:46:58', '', 63, 'http://codeseeking.sinaapp.com/?p=64', 0, 'revision', '', 0),
(56, 1, '2013-03-13 07:34:55', '2013-03-13 07:34:55', '今天尝试配置了下premake4，虽然linux工程管理又很多，如make/cmake/automake...但是同学说这个简单这个方便这个跨平台什么什么的，好吧，试试吧，虽然有点疼。\r\n首先，http://industriousone.com/premake 下载最新版本的premake4，tar包解压后是可执行文件，记得把它放到默认搜索路径中去（usr/bin）这样在命令行才可以当命令用，不然就只能在这个解压的文件夹上使用，另外一个是源码包，里面又很多examples和一些配置。script文件夹在使用时需cp到工程文件夹里（ps：premake4.lua也是哦）\r\n这里只是premake4的一些事情，还有就是lua环境的配置，http://www.lua.org/ 在这下载最新的lua包，tar -xzvf解压，make..这里make需要注意选择自己的系统，"make xxx", where xxx is your platform name，这里可能显示can''t find -lxxx 指的是缺少xxx库，-l是参数 如premake时缺少 -lreadline ，通过sudo apt-cache search xx 可以从软件包列表里搜索，这里的库是 libreadline-dev..安装后即可。这样lua也配置好了。\r\n最后就是看例子学习了，唉，http://industriousone.com/scripting-premake讲的很好。\r\n\r\nps：Lua 5.1 Reference Manual ： <a href="http://www.lua.org/manual/5.1/" title="Lua 5.1 Reference Manual " target="_blank"></a>http://www.lua.org/manual/5.1/\r\n    Scripting Reference ： http://industriousone.com/scripting-reference', 'premake4 for linux', '', 'inherit', 'open', 'open', '', '50-revision-5', '', '', '2013-03-13 07:34:55', '2013-03-13 07:34:55', '', 50, 'http://codeseeking.sinaapp.com/?p=56', 0, 'revision', '', 0),
(58, 1, '2013-03-28 01:58:41', '2013-03-28 01:58:41', '一、BMP文件结构  \r\n   \r\n  BMP文件组成  \r\n  BMP文件由文件头、位图信息头、颜色信息和图形数据四部分组成。    \r\n  BMP文件头  \r\n  BMP文件头数据结构含有BMP文件的类型、文件大小和位图起始位置等信息。    \r\n  其结构定义如下:  \r\n  typedef   struct   tagBITMAPFILEHEADER  \r\n  {  \r\n  WORDbfType;   //   位图文件的类型，必须为BM  \r\n  DWORD   bfSize;   //   位图文件的大小，以字节为单位    \r\n  WORDbfReserved1;   //   位图文件保留字，必须为0  \r\n  WORDbfReserved2;   //   位图文件保留字，必须为0  \r\n  DWORD   bfOffBits;   //   位图数据的起始位置，以相对于位图  \r\n  //   文件头的偏移量表示，以字节为单位  \r\n  }   BITMAPFILEHEADER;  \r\n   \r\n   \r\n  3.   位图信息头  \r\n   \r\n   \r\n  BMP位图信息头数据用于说明位图的尺寸等信息。  \r\n  typedef   struct   tagBITMAPINFOHEADER{  \r\n  DWORD   biSize;   //   本结构所占用字节数  \r\n  LONGbiWidth;   //   位图的宽度，以像素为单位  \r\n  LONGbiHeight;   //   位图的高度，以像素为单位  \r\n  WORD   biPlanes;   //   目标设备的级别，必须为1  \r\n  WORD   biBitCount//   每个像素所需的位数，必须是1(双色),  \r\n  //   4(16色)，8(256色)或24(真彩色)之一  \r\n  DWORD   biCompression;   //   位图压缩类型，必须是   0(不压缩),  \r\n  //   1(BI_RLE8压缩类型)或2(BI_RLE4压缩类型)之一  \r\n  DWORD   biSizeImage;   //   位图的大小，以字节为单位  \r\n  LONGbiXPelsPerMeter;   //   位图水平分辨率，每米像素数  \r\n  LONGbiYPelsPerMeter;   //   位图垂直分辨率，每米像素数  \r\n  DWORD   biClrUsed;//   位图实际使用的颜色表中的颜色数  \r\n  DWORD   biClrImportant;//   位图显示过程中重要的颜色数  \r\n  }   BITMAPINFOHEADER;  \r\n   \r\n   \r\n  4.   颜色表  \r\n   \r\n  　　颜色表用于说明位图中的颜色，它有若干个表项，每一个表项是一个RGBQUAD类型的结构，定义一种颜色。RGBQUAD结构的定义如下:  \r\n  typedef   struct   tagRGBQUAD   {  \r\n  BYTErgbBlue;//   蓝色的亮度(值范围为0-255)  \r\n  BYTErgbGreen;   //   绿色的亮度(值范围为0-255)  \r\n  BYTErgbRed;   //   红色的亮度(值范围为0-255)  \r\n  BYTErgbReserved;//   保留，必须为0  \r\n  }   RGBQUAD;  \r\n  颜色表中RGBQUAD结构数据的个数有biBitCount来确定:  \r\n  当biBitCount=1,4,8时，分别有2,16,256个表项;  \r\n  当biBitCount=24时，没有颜色表项。  \r\n  位图信息头和颜色表组成位图信息，BITMAPINFO结构定义如下:  \r\n  typedef   struct   tagBITMAPINFO   {  \r\n  BITMAPINFOHEADER   bmiHeader;   //   位图信息头  \r\n  RGBQUAD   bmiColors[1];   //   颜色表  \r\n  }   BITMAPINFO;  \r\n   \r\n   \r\n  5.   位图数据  \r\n  　　位图数据记录了位图的每一个像素值，记录顺序是在扫描行内是从左到右,扫描行之间是从下到上。位图的一个像素值所占的字节数:  \r\n  当biBitCount=1时，8个像素占1个字节;  \r\n  当biBitCount=4时，2个像素占1个字节;  \r\n  当biBitCount=8时，1个像素占1个字节;  \r\n  当biBitCount=24时,1个像素占3个字节;  \r\n  Windows规定一个扫描行所占的字节数必须是  \r\n  4的倍数(即以long为单位),不足的以0填充，  \r\n  一个扫描行所占的字节数计算方法:  \r\n  DataSizePerLine=   (biWidth*   biBitCount+31)/8;    \r\n  //   一个扫描行所占的字节数  \r\n  DataSizePerLine=   DataSizePerLine/4*4;   //   字节数必须是4的倍数  \r\n  位图数据的大小(不压缩情况下):  \r\n  DataSize=   DataSizePerLine*   biHeight; ', 'BMP图像格式', '', 'publish', 'open', 'open', '', 'bmp%e5%9b%be%e5%83%8f%e6%a0%bc%e5%bc%8f', '', '', '2013-03-28 01:58:41', '2013-03-28 01:58:41', '', 0, 'http://codeseeking.sinaapp.com/?p=58', 0, 'post', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(59, 1, '2013-03-28 01:58:32', '2013-03-28 01:58:32', '一、BMP文件结构  \n   \n  BMP文件组成  \n  BMP文件由文件头、位图信息头、颜色信息和图形数据四部分组成。    \n  BMP文件头  \n  BMP文件头数据结构含有BMP文件的类型、文件大小和位图起始位置等信息。    \n  其结构定义如下:  \n  typedef   struct   tagBITMAPFILEHEADER  \n  {  \n  WORDbfType;   //   位图文件的类型，必须为BM  \n  DWORD   bfSize;   //   位图文件的大小，以字节为单位    \n  WORDbfReserved1;   //   位图文件保留字，必须为0  \n  WORDbfReserved2;   //   位图文件保留字，必须为0  \n  DWORD   bfOffBits;   //   位图数据的起始位置，以相对于位图  \n  //   文件头的偏移量表示，以字节为单位  \n  }   BITMAPFILEHEADER;  \n   \n   \n  3.   位图信息头  \n   \n   \n  BMP位图信息头数据用于说明位图的尺寸等信息。  \n  typedef   struct   tagBITMAPINFOHEADER{  \n  DWORD   biSize;   //   本结构所占用字节数  \n  LONGbiWidth;   //   位图的宽度，以像素为单位  \n  LONGbiHeight;   //   位图的高度，以像素为单位  \n  WORD   biPlanes;   //   目标设备的级别，必须为1  \n  WORD   biBitCount//   每个像素所需的位数，必须是1(双色),  \n  //   4(16色)，8(256色)或24(真彩色)之一  \n  DWORD   biCompression;   //   位图压缩类型，必须是   0(不压缩),  \n  //   1(BI_RLE8压缩类型)或2(BI_RLE4压缩类型)之一  \n  DWORD   biSizeImage;   //   位图的大小，以字节为单位  \n  LONGbiXPelsPerMeter;   //   位图水平分辨率，每米像素数  \n  LONGbiYPelsPerMeter;   //   位图垂直分辨率，每米像素数  \n  DWORD   biClrUsed;//   位图实际使用的颜色表中的颜色数  \n  DWORD   biClrImportant;//   位图显示过程中重要的颜色数  \n  }   BITMAPINFOHEADER;  \n   \n   \n  4.   颜色表  \n   \n  　　颜色表用于说明位图中的颜色，它有若干个表项，每一个表项是一个RGBQUAD类型的结构，定义一种颜色。RGBQUAD结构的定义如下:  \n  typedef   struct   tagRGBQUAD   {  \n  BYTErgbBlue;//   蓝色的亮度(值范围为0-255)  \n  BYTErgbGreen;   //   绿色的亮度(值范围为0-255)  \n  BYTErgbRed;   //   红色的亮度(值范围为0-255)  \n  BYTErgbReserved;//   保留，必须为0  \n  }   RGBQUAD;  \n  颜色表中RGBQUAD结构数据的个数有biBitCount来确定:  \n  当biBitCount=1,4,8时，分别有2,16,256个表项;  \n  当biBitCount=24时，没有颜色表项。  \n  位图信息头和颜色表组成位图信息，BITMAPINFO结构定义如下:  \n  typedef   struct   tagBITMAPINFO   {  \n  BITMAPINFOHEADER   bmiHeader;   //   位图信息头  \n  RGBQUAD   bmiColors[1];   //   颜色表  \n  }   BITMAPINFO;  \n   \n   \n  5.   位图数据  \n  　　位图数据记录了位图的每一个像素值，记录顺序是在扫描行内是从左到右,扫描行之间是从下到上。位图的一个像素值所占的字节数:  \n  当biBitCount=1时，8个像素占1个字节;  \n  当biBitCount=4时，2个像素占1个字节;  \n  当biBitCount=8时，1个像素占1个字节;  \n  当biBitCount=24时,1个像素占3个字节;  \n  Windows规定一个扫描行所占的字节数必须是  \n  4的倍数(即以long为单位),不足的以0填充，  \n  一个扫描行所占的字节数计算方法:  \n  DataSizePerLine=   (biWidth*   biBitCount+31)/8;    \n  //   一个扫描行所占的字节数  \n  DataSizePerLine=   DataSizePerLine/4*4;   //   字节数必须是4的倍数  \n  位图数据的大小(不压缩情况下):  \n  DataSize=   DataSizePerLine*   biHeight; ', 'BMP图像格式', '', 'inherit', 'open', 'open', '', '58-revision', '', '', '2013-03-28 01:58:32', '2013-03-28 01:58:32', '', 58, 'http://codeseeking.sinaapp.com/?p=59', 0, 'revision', '', 0),
(60, 1, '2013-03-28 02:29:54', '2013-03-28 02:29:54', 'http://book.51cto.com/art/200903/112713.htm', 'BMP图像分析', '', 'publish', 'open', 'open', '', 'bmp%e5%9b%be%e5%83%8f%e5%88%86%e6%9e%90', '', '', '2013-03-28 02:29:54', '2013-03-28 02:29:54', '', 0, 'http://codeseeking.sinaapp.com/?p=60', 0, 'post', '', 0),
(61, 1, '2013-03-28 02:29:27', '2013-03-28 02:29:27', '', '自动草稿', '', 'inherit', 'open', 'open', '', '60-revision', '', '', '2013-03-28 02:29:27', '2013-03-28 02:29:27', '', 60, 'http://codeseeking.sinaapp.com/?p=61', 0, 'revision', '', 0),
(63, 1, '2013-04-11 07:47:12', '2013-04-11 07:47:12', 'Shift+Ctrl+T:新建标签页\r\nShift+Ctrl+W:关闭标签页\r\nCtrl+PageUp:前一标签页\r\nCtrl+PageDown:后一标签页\r\nShift+Ctrl+PageUp:标签页左移\r\nShift+Ctrl+PageDown:标签页右移\r\nAlt+1:切换到标签页1\r\nAlt+2:切换到标签页2\r\nAlt+3:切换到标签页3\r\n\r\nShift+Ctrl+N:新建窗口\r\nShift+Ctrl+Q:关闭终端\r\n\r\n终端中的复制／粘贴:\r\nShift+Ctrl+C:复制\r\nShift+Ctrl+V:粘贴\r\n\r\n终端改变大小：\r\nF11：全屏\r\nCtrl+plus:放大\r\nCtrl+minus:减小\r\nCtrl+0:原始大小', '终端快捷键', '', 'publish', 'open', 'open', '', '%e7%bb%88%e7%ab%af%e5%bf%ab%e6%8d%b7%e9%94%ae', '', '', '2013-04-11 07:47:12', '2013-04-11 07:47:12', '', 0, 'http://codeseeking.sinaapp.com/?p=63', 0, 'post', '', 0),
(65, 1, '2013-04-18 01:13:45', '2013-04-18 01:13:45', '数据类型 	         32位 	 64位\r\n char 	         1 	 1\r\n int 	         4 	 4\r\n long            4 	 8\r\n float 	         4 	 4\r\n double 	 8 	 8\r\n long double 	 12 	 16\r\n long long 	 8 	 8', '32位和64位数据类型', '', 'publish', 'open', 'open', '', '32%e4%bd%8d%e5%92%8c64%e4%bd%8d%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b', '', '', '2013-04-18 01:13:45', '2013-04-18 01:13:45', '', 0, 'http://codeseeking.sinaapp.com/?p=65', 0, 'post', '', 0),
(66, 1, '2013-04-18 01:12:58', '2013-04-18 01:12:58', '数据类型 	      32位 	 64位\n char 	      1 	 1\n int 	      4 	 4\n long         4 	 8\n float 	      4 	 4\n double 	 8 	 8\n long double 	 12 	 16\n long long 	8 	8', '', '', 'inherit', 'open', 'open', '', '65-revision', '', '', '2013-04-18 01:12:58', '2013-04-18 01:12:58', '', 65, 'http://codeseeking.sinaapp.com/?p=66', 0, 'revision', '', 0),
(67, 1, '2013-04-18 01:38:59', '2013-04-18 01:38:59', '<pre lang="c" colla="-">\r\n#include<stdio.h>\r\n#define N 100\r\nvoid main()\r\n{\r\n  int x,y,yu,i,zen;\r\n  int num[N+3];\r\n  printf("请输入被除数！\\n");\r\n  scanf("%d",&x);\r\n  printf("请输入除数！\\n");\r\n  scanf("%d",&y);\r\n  zen=x/y;\r\n  num[1]=''.'';\r\n  for(i=2;i<=N+2;i++){\r\n    yu=x%y;\r\n    num[i]=(yu*10)/y;\r\n    x=yu*10%y;\r\n  }\r\n  printf("%d.",zen);\r\n  for(i=2;i<=N+2;i++){\r\n    printf("%d",num[i]);\r\n    if(i%5==0) printf("\\n");\r\n  }\r\n}//此程序求两整数相除精确到小数点后100位！\r\n</pre>', '疼。求小数点后100位', '', 'publish', 'open', 'open', '', '%e7%96%bc%e3%80%82%e6%b1%82%e5%b0%8f%e6%95%b0%e7%82%b9%e5%90%8e100%e4%bd%8d', '', '', '2013-04-23 17:47:52', '2013-04-23 17:47:52', '', 0, 'http://codeseeking.sinaapp.com/?p=67', 0, 'post', '', 0),
(68, 1, '2013-04-18 01:38:53', '2013-04-18 01:38:53', '#include<stdio.h>\n#define N 100\nmain()\n{int x,y,yu,i,zen;\nint num[N+3];\nprintf("请输入被除数！\\n");\nscanf("%d",&x);\nprintf("请输入除数！\\n");\nscanf("%d",&y);\nzen=x/y;\nnum[1]=''.'';\nfor(i=2;i<=N+2;i++)\n{yu=x%y;\nnum[i]=(yu*10)/y;\nx=yu*10%y;\n}\n\nprintf("%d.",zen);\nfor(i=2;i<=N+2;i++)\n{printf("%d",num[i]);\nif(i%5==0) printf("\\n");\n}\n\n}//此程序求两整数相除精确到小数点后100位！', '疼。求小数点后100位', '', 'inherit', 'open', 'open', '', '67-revision', '', '', '2013-04-18 01:38:53', '2013-04-18 01:38:53', '', 67, 'http://codeseeking.sinaapp.com/?p=68', 0, 'revision', '', 0),
(72, 1, '2013-04-23 17:39:44', '2013-04-23 17:39:44', '<pre lang="c" colla="-">\r\n#define BYTE unsigned char\r\n#include<stdio.h>  \r\n#include<stdlib.h>\r\n#include<string.h>  \r\n#include<sys/types.h>  \r\n#include<iostream>    \r\n#pragma pack(2)  \r\nusing namespace std;  \r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n    u_int16_t bfType; //数据地址为 0 - "BM"  \r\n    u_int32_t bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n    u_int16_t bfReserved1;   //DA 6 - 文件保留字 0\r\n    u_int16_t bfReserved2;   //DA 8 - 文件保留字 0\r\n    u_int32_t bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;   \r\n                     \r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n    u_int32_t biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n    u_int32_t biWidth;   //DA 18\r\n    u_int32_t biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n    u_int16_t biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n    u_int16_t biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n    u_int32_t biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n    u_int32_t biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n    u_int32_t biXPelsPerMeter;   //DA 38\r\n    u_int32_t biYPelsPerMeter;   //DA 42 分辨率\r\n    u_int32_t biClrUsed;   //DA 46 颜色变址数\r\n    u_int32_t biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER;  \r\n\r\ntypedef struct tagRGBQUAD{\r\n		BYTE rgbBlue;\r\n		BYTE rgbGreen;\r\n		BYTE rgbRed;\r\n		BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nvoid showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n                                                                   \r\nvoid showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}   \r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n		FILE *fp = fopen(argv[1], "rb");  \r\n		BITMAPFILEHEADER head;  \r\n		BITMAPINFODEADER info;\r\n		RGBQUAD colors;	\r\n		int palesize = 0;\r\n\r\n		printf("%d--%d--%d\\n",sizeof(BITMAPFILEHEADER),sizeof(BITMAPINFOHEADER),sizeof(RGBQUAD));\r\n		fread(&head, 1, sizeof(BITMAPFILEHEADER), fp);  \r\n		fread(&info, 1, sizeof(BITMAPINFODEADER), fp);  \r\n		switch(info.biBitCount){\r\n		    case 1:\r\n			palesize = 2;\r\n			break;\r\n		    case 4:\r\n			palesize = 16;\r\n			break;\r\n		    case 8:\r\n			palesize = 256;\r\n			break;\r\n		}\r\n		if(palesize){\r\n		    	cout<<"存在RGBQUAD.."<<endl;\r\n			fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n		}else{\r\n			cout<<"不存在RGBQUAD.."<<endl;\r\n		}\r\n\r\n		showBmpHead(head);  \r\n		showBmpInforHead(info);  \r\n		//showRgbtag(colors);\r\n		int PicData = info.biSizeImage;\r\n		if(PicData%64)\r\n			PicData = PicData+PicData%64;\r\n		char *PicS;\r\n		PicS = (char*)new char[PicData];\r\n	        //PicS = (char*)malloc(PicData);	\r\n		memset(PicS,0,PicData);\r\n		fread(PicS,1,PicData,fp);\r\n		fclose(fp);  \r\n		return 0;  \r\n}   \r\n</pre>', 'pack.', '', 'publish', 'open', 'open', '', '72', '', '', '2013-04-23 17:45:36', '2013-04-23 17:45:36', '', 0, 'http://codeseeking.sinaapp.com/?p=72', 0, 'post', '', 0),
(77, 1, '2013-04-23 17:43:04', '2013-04-23 17:43:04', '<pre lang = "c" colla = "+">\r\nint x = 1;\r\nprintf("lang"）；\r\n</pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-5', '', '', '2013-04-23 17:43:04', '2013-04-23 17:43:04', '', 72, 'http://codeseeking.sinaapp.com/?p=77', 0, 'revision', '', 0),
(102, 1, '2013-04-30 18:11:32', '2013-04-30 18:11:32', '调整后的main\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	Arrydisplay(nk);	\r\n	\r\n	//获得灰度值\r\n	picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++){\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	}\r\n	printf("PicGrayValue is %d \\n",picG);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\r\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);\r\n		\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum - 1){\r\n			while((Knew == KL)|(picheck[Knew]!=0))\r\n				Knew = (Knew + 1)%bnum;\r\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\r\n			picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\r\n			picheck[KL] = 1;\r\n		}\r\n		d = LSB(LCL[0]);\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(3*(y+d))%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}\r\n		//memcpy(cpics+eachtime*k,CK,eachtime);\r\n		for(int m=0 ; m<16 ; m++)\r\n			pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n	}\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("cpicC.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>', '置乱扩散调整', '', 'publish', 'open', 'open', 'c7722731', '%e7%bd%ae%e4%b9%b1%e6%89%a9%e6%95%a3%e8%b0%83%e6%95%b4', '', '', '2013-04-30 21:42:24', '2013-04-30 21:42:24', '', 0, 'http://codeseeking.sinaapp.com/?p=102', 0, 'post', '', 0),
(79, 1, '2013-04-23 17:43:25', '2013-04-23 17:43:25', '<pre lang = "c" colla = "+">\r\nint x = 1;\r\nprintf("lang"）；\r\n<pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-6', '', '', '2013-04-23 17:43:25', '2013-04-23 17:43:25', '', 72, 'http://codeseeking.sinaapp.com/?p=79', 0, 'revision', '', 0),
(80, 1, '2013-04-23 17:43:44', '2013-04-23 17:43:44', '<pre lang="asp" colla="+">\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td><input type="text" /></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-7', '', '', '2013-04-23 17:43:44', '2013-04-23 17:43:44', '', 72, 'http://codeseeking.sinaapp.com/?p=80', 0, 'revision', '', 0),
(81, 1, '2013-04-23 17:44:04', '2013-04-23 17:44:04', '<pre lang="c" colla="+">\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td><input type="text" /></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-8', '', '', '2013-04-23 17:44:04', '2013-04-23 17:44:04', '', 72, 'http://codeseeking.sinaapp.com/?p=81', 0, 'revision', '', 0),
(82, 1, '2013-04-23 17:44:25', '2013-04-23 17:44:25', '<pre lang="c" colla="+">\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n    u_int16_t bfType; //数据地址为 0 - "BM"  \r\n    u_int32_t bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n    u_int16_t bfReserved1;   //DA 6 - 文件保留字 0\r\n    u_int16_t bfReserved2;   //DA 8 - 文件保留字 0\r\n    u_int32_t bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;   \r\n</pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-9', '', '', '2013-04-23 17:44:25', '2013-04-23 17:44:25', '', 72, 'http://codeseeking.sinaapp.com/?p=82', 0, 'revision', '', 0),
(73, 1, '2013-04-23 17:39:38', '2013-04-23 17:39:38', '<pre lang="C++" colla="+">\n#define BYTE unsigned char\n#include<stdio.h>  \n#include<stdlib.h>\n#include<string.h>  \n#include<sys/types.h>  \n#include<iostream>    \n#pragma pack(2)  \nusing namespace std;  \ntypedef struct BITMAPFILEHEADER  \n{   \n    u_int16_t bfType; //数据地址为 0 - "BM"  \n    u_int32_t bfSize; //DA 2 - 定义文件大小，字节为单位  \n    u_int16_t bfReserved1;   //DA 6 - 文件保留字 0\n    u_int16_t bfReserved2;   //DA 8 - 文件保留字 0\n    u_int32_t bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\n}BITMAPFILEHEADER;   \n                     \ntypedef struct BITMAPINFOHEADER  \n{   \n    u_int32_t biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\n    u_int32_t biWidth;   //DA 18\n    u_int32_t biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\n    u_int16_t biPlanes;   //DA 26 目标设备的平面数 必须为1\n    u_int16_t biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\n    u_int32_t biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \n    u_int32_t biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\n    u_int32_t biXPelsPerMeter;   //DA 38\n    u_int32_t biYPelsPerMeter;   //DA 42 分辨率\n    u_int32_t biClrUsed;   //DA 46 颜色变址数\n    u_int32_t biClrImportant;  //DA 50 重要颜色变址数 \n}BITMAPINFODEADER;  \n\ntypedef struct tagRGBQUAD{\n		BYTE rgbBlue;\n		BYTE rgbGreen;\n		BYTE rgbRed;\n		BYTE rgbReserved;\n}RGBQUAD;\n\nvoid showRgbtag(RGBQUAD &colors){\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\n		cout<<"Green:"<<colors.rgbGreen<<endl;\n		cout<<"Red:"<<colors.rgbRed<<endl;\n}\n                                                                   \nvoid showBmpHead(BITMAPFILEHEADER &pBmpHead){    \n    cout<<"位图文件头:"<<endl;    \n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \n}    \n                                                          \nvoid showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \n    cout<<"位图信息头:"<<endl;    \n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \n}   \n\nint main( int argc, char **argv )  \n{  \n		FILE *fp = fopen(argv[1], "rb");  \n		BITMAPFILEHEADER head;  \n		BITMAPINFODEADER info;\n		RGBQUAD colors;	\n		int palesize = 0;\n\n		printf("%d--%d--%d\\n",sizeof(BITMAPFILEHEADER),sizeof(BITMAPINFOHEADER),sizeof(RGBQUAD));\n		fread(&head, 1, sizeof(BITMAPFILEHEADER), fp);  \n		fread(&info, 1, sizeof(BITMAPINFODEADER), fp);  \n		switch(info.biBitCount){\n		    case 1:\n			palesize = 2;\n			break;\n		    case 4:\n			palesize = 16;\n			break;\n		    case 8:\n			palesize = 256;\n			break;\n		}\n		if(palesize){\n		    	cout<<"存在RGBQUAD.."<<endl;\n			fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\n		}else{\n			cout<<"不存在RGBQUAD.."<<endl;\n		}\n\n		showBmpHead(head);  \n		showBmpInforHead(info);  \n		//showRgbtag(colors);\n		int PicData = info.biSizeImage;\n		if(PicData%64)\n			PicData = PicData+PicData%64;\n		char *PicS;\n		PicS = (char*)new char[PicData];\n	        //PicS = (char*)malloc(PicData);	\n		memset(PicS,0,PicData);\n		fread(PicS,1,PicData,fp);\n		fclose(fp);  \n		return 0;  \n} \n</pre>', '', '', 'inherit', 'open', 'open', '', '72-revision', '', '', '2013-04-23 17:39:38', '2013-04-23 17:39:38', '', 72, 'http://codeseeking.sinaapp.com/?p=73', 0, 'revision', '', 0),
(74, 1, '2013-04-23 17:39:44', '2013-04-23 17:39:44', '<pre lang="C++" colla="+">\r\n#define BYTE unsigned char\r\n#include<stdio.h>  \r\n#include<stdlib.h>\r\n#include<string.h>  \r\n#include<sys/types.h>  \r\n#include<iostream>    \r\n#pragma pack(2)  \r\nusing namespace std;  \r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n    u_int16_t bfType; //数据地址为 0 - "BM"  \r\n    u_int32_t bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n    u_int16_t bfReserved1;   //DA 6 - 文件保留字 0\r\n    u_int16_t bfReserved2;   //DA 8 - 文件保留字 0\r\n    u_int32_t bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;   \r\n                     \r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n    u_int32_t biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n    u_int32_t biWidth;   //DA 18\r\n    u_int32_t biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n    u_int16_t biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n    u_int16_t biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n    u_int32_t biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n    u_int32_t biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n    u_int32_t biXPelsPerMeter;   //DA 38\r\n    u_int32_t biYPelsPerMeter;   //DA 42 分辨率\r\n    u_int32_t biClrUsed;   //DA 46 颜色变址数\r\n    u_int32_t biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER;  \r\n\r\ntypedef struct tagRGBQUAD{\r\n		BYTE rgbBlue;\r\n		BYTE rgbGreen;\r\n		BYTE rgbRed;\r\n		BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nvoid showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n                                                                   \r\nvoid showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}   \r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n		FILE *fp = fopen(argv[1], "rb");  \r\n		BITMAPFILEHEADER head;  \r\n		BITMAPINFODEADER info;\r\n		RGBQUAD colors;	\r\n		int palesize = 0;\r\n\r\n		printf("%d--%d--%d\\n",sizeof(BITMAPFILEHEADER),sizeof(BITMAPINFOHEADER),sizeof(RGBQUAD));\r\n		fread(&head, 1, sizeof(BITMAPFILEHEADER), fp);  \r\n		fread(&info, 1, sizeof(BITMAPINFODEADER), fp);  \r\n		switch(info.biBitCount){\r\n		    case 1:\r\n			palesize = 2;\r\n			break;\r\n		    case 4:\r\n			palesize = 16;\r\n			break;\r\n		    case 8:\r\n			palesize = 256;\r\n			break;\r\n		}\r\n		if(palesize){\r\n		    	cout<<"存在RGBQUAD.."<<endl;\r\n			fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n		}else{\r\n			cout<<"不存在RGBQUAD.."<<endl;\r\n		}\r\n\r\n		showBmpHead(head);  \r\n		showBmpInforHead(info);  \r\n		//showRgbtag(colors);\r\n		int PicData = info.biSizeImage;\r\n		if(PicData%64)\r\n			PicData = PicData+PicData%64;\r\n		char *PicS;\r\n		PicS = (char*)new char[PicData];\r\n	        //PicS = (char*)malloc(PicData);	\r\n		memset(PicS,0,PicData);\r\n		fread(PicS,1,PicData,fp);\r\n		fclose(fp);  \r\n		return 0;  \r\n} \r\n</pre>', '', '', 'inherit', 'open', 'open', '', '72-revision-2', '', '', '2013-04-23 17:39:44', '2013-04-23 17:39:44', '', 72, 'http://codeseeking.sinaapp.com/?p=74', 0, 'revision', '', 0),
(76, 1, '2013-04-23 17:41:54', '2013-04-23 17:41:54', '<pre lang="c++" colla="-">\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n    u_int16_t bfType; //数据地址为 0 - "BM"  \r\n    u_int32_t bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n    u_int16_t bfReserved1;   //DA 6 - 文件保留字 0\r\n    u_int16_t bfReserved2;   //DA 8 - 文件保留字 0\r\n    u_int32_t bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;   \r\n                     \r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n    u_int32_t biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n    u_int32_t biWidth;   //DA 18\r\n    u_int32_t biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n    u_int16_t biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n    u_int16_t biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n    u_int32_t biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n    u_int32_t biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n    u_int32_t biXPelsPerMeter;   //DA 38\r\n    u_int32_t biYPelsPerMeter;   //DA 42 分辨率\r\n    u_int32_t biClrUsed;   //DA 46 颜色变址数\r\n    u_int32_t biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER;  \r\n\r\ntypedef struct tagRGBQUAD{\r\n		BYTE rgbBlue;\r\n		BYTE rgbGreen;\r\n		BYTE rgbRed;\r\n		BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nvoid showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n                                                                   \r\nvoid showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}   \r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n		FILE *fp = fopen(argv[1], "rb");  \r\n		BITMAPFILEHEADER head;  \r\n		BITMAPINFODEADER info;\r\n		RGBQUAD colors;	\r\n		int palesize = 0;\r\n\r\n		printf("%d--%d--%d\\n",sizeof(BITMAPFILEHEADER),sizeof(BITMAPINFOHEADER),sizeof(RGBQUAD));\r\n		fread(&head, 1, sizeof(BITMAPFILEHEADER), fp);  \r\n		fread(&info, 1, sizeof(BITMAPINFODEADER), fp);  \r\n		switch(info.biBitCount){\r\n		    case 1:\r\n			palesize = 2;\r\n			break;\r\n		    case 4:\r\n			palesize = 16;\r\n			break;\r\n		    case 8:\r\n			palesize = 256;\r\n			break;\r\n		}\r\n		if(palesize){\r\n		    	cout<<"存在RGBQUAD.."<<endl;\r\n			fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n		}else{\r\n			cout<<"不存在RGBQUAD.."<<endl;\r\n		}\r\n\r\n		showBmpHead(head);  \r\n		showBmpInforHead(info);  \r\n		//showRgbtag(colors);\r\n		int PicData = info.biSizeImage;\r\n		if(PicData%64)\r\n			PicData = PicData+PicData%64;\r\n		char *PicS;\r\n		PicS = (char*)new char[PicData];\r\n	        //PicS = (char*)malloc(PicData);	\r\n		memset(PicS,0,PicData);\r\n		fread(PicS,1,PicData,fp);\r\n		fclose(fp);  \r\n		return 0;  \r\n} \r\n</pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-4', '', '', '2013-04-23 17:41:54', '2013-04-23 17:41:54', '', 72, 'http://codeseeking.sinaapp.com/?p=76', 0, 'revision', '', 0),
(75, 1, '2013-04-23 17:40:35', '2013-04-23 17:40:35', '<pre lang="c++" colla="-">\r\n#define BYTE unsigned char\r\n#include<stdio.h>  \r\n#include<stdlib.h>\r\n#include<string.h>  \r\n#include<sys/types.h>  \r\n#include<iostream>    \r\n#pragma pack(2)  \r\nusing namespace std;  \r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n    u_int16_t bfType; //数据地址为 0 - "BM"  \r\n    u_int32_t bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n    u_int16_t bfReserved1;   //DA 6 - 文件保留字 0\r\n    u_int16_t bfReserved2;   //DA 8 - 文件保留字 0\r\n    u_int32_t bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;   \r\n                     \r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n    u_int32_t biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n    u_int32_t biWidth;   //DA 18\r\n    u_int32_t biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n    u_int16_t biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n    u_int16_t biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n    u_int32_t biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n    u_int32_t biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n    u_int32_t biXPelsPerMeter;   //DA 38\r\n    u_int32_t biYPelsPerMeter;   //DA 42 分辨率\r\n    u_int32_t biClrUsed;   //DA 46 颜色变址数\r\n    u_int32_t biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER;  \r\n\r\ntypedef struct tagRGBQUAD{\r\n		BYTE rgbBlue;\r\n		BYTE rgbGreen;\r\n		BYTE rgbRed;\r\n		BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nvoid showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n                                                                   \r\nvoid showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}   \r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n		FILE *fp = fopen(argv[1], "rb");  \r\n		BITMAPFILEHEADER head;  \r\n		BITMAPINFODEADER info;\r\n		RGBQUAD colors;	\r\n		int palesize = 0;\r\n\r\n		printf("%d--%d--%d\\n",sizeof(BITMAPFILEHEADER),sizeof(BITMAPINFOHEADER),sizeof(RGBQUAD));\r\n		fread(&head, 1, sizeof(BITMAPFILEHEADER), fp);  \r\n		fread(&info, 1, sizeof(BITMAPINFODEADER), fp);  \r\n		switch(info.biBitCount){\r\n		    case 1:\r\n			palesize = 2;\r\n			break;\r\n		    case 4:\r\n			palesize = 16;\r\n			break;\r\n		    case 8:\r\n			palesize = 256;\r\n			break;\r\n		}\r\n		if(palesize){\r\n		    	cout<<"存在RGBQUAD.."<<endl;\r\n			fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n		}else{\r\n			cout<<"不存在RGBQUAD.."<<endl;\r\n		}\r\n\r\n		showBmpHead(head);  \r\n		showBmpInforHead(info);  \r\n		//showRgbtag(colors);\r\n		int PicData = info.biSizeImage;\r\n		if(PicData%64)\r\n			PicData = PicData+PicData%64;\r\n		char *PicS;\r\n		PicS = (char*)new char[PicData];\r\n	        //PicS = (char*)malloc(PicData);	\r\n		memset(PicS,0,PicData);\r\n		fread(PicS,1,PicData,fp);\r\n		fclose(fp);  \r\n		return 0;  \r\n} \r\n</pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-3', '', '', '2013-04-23 17:40:35', '2013-04-23 17:40:35', '', 72, 'http://codeseeking.sinaapp.com/?p=75', 0, 'revision', '', 0),
(83, 1, '2013-04-23 17:44:48', '2013-04-23 17:44:48', '<pre lang="c" colla="+">\r\n#define BYTE unsigned char\r\n#include<stdio.h>  \r\n#include<stdlib.h>\r\n#include<string.h>  \r\n#include<sys/types.h>  \r\n#include<iostream>    \r\n#pragma pack(2)  \r\nusing namespace std;  \r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n    u_int16_t bfType; //数据地址为 0 - "BM"  \r\n    u_int32_t bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n    u_int16_t bfReserved1;   //DA 6 - 文件保留字 0\r\n    u_int16_t bfReserved2;   //DA 8 - 文件保留字 0\r\n    u_int32_t bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;   \r\n                     \r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n    u_int32_t biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n    u_int32_t biWidth;   //DA 18\r\n    u_int32_t biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n    u_int16_t biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n    u_int16_t biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n    u_int32_t biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n    u_int32_t biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n    u_int32_t biXPelsPerMeter;   //DA 38\r\n    u_int32_t biYPelsPerMeter;   //DA 42 分辨率\r\n    u_int32_t biClrUsed;   //DA 46 颜色变址数\r\n    u_int32_t biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER;  \r\n\r\ntypedef struct tagRGBQUAD{\r\n		BYTE rgbBlue;\r\n		BYTE rgbGreen;\r\n		BYTE rgbRed;\r\n		BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nvoid showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n                                                                   \r\nvoid showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}   \r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n		FILE *fp = fopen(argv[1], "rb");  \r\n		BITMAPFILEHEADER head;  \r\n		BITMAPINFODEADER info;\r\n		RGBQUAD colors;	\r\n		int palesize = 0;\r\n\r\n		printf("%d--%d--%d\\n",sizeof(BITMAPFILEHEADER),sizeof(BITMAPINFOHEADER),sizeof(RGBQUAD));\r\n		fread(&head, 1, sizeof(BITMAPFILEHEADER), fp);  \r\n		fread(&info, 1, sizeof(BITMAPINFODEADER), fp);  \r\n		switch(info.biBitCount){\r\n		    case 1:\r\n			palesize = 2;\r\n			break;\r\n		    case 4:\r\n			palesize = 16;\r\n			break;\r\n		    case 8:\r\n			palesize = 256;\r\n			break;\r\n		}\r\n		if(palesize){\r\n		    	cout<<"存在RGBQUAD.."<<endl;\r\n			fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n		}else{\r\n			cout<<"不存在RGBQUAD.."<<endl;\r\n		}\r\n\r\n		showBmpHead(head);  \r\n		showBmpInforHead(info);  \r\n		//showRgbtag(colors);\r\n		int PicData = info.biSizeImage;\r\n		if(PicData%64)\r\n			PicData = PicData+PicData%64;\r\n		char *PicS;\r\n		PicS = (char*)new char[PicData];\r\n	        //PicS = (char*)malloc(PicData);	\r\n		memset(PicS,0,PicData);\r\n		fread(PicS,1,PicData,fp);\r\n		fclose(fp);  \r\n		return 0;  \r\n}   \r\n</pre>', 'bmp读取', '', 'inherit', 'open', 'open', '', '72-revision-10', '', '', '2013-04-23 17:44:48', '2013-04-23 17:44:48', '', 72, '', 0, 'revision', '', 0),
(84, 1, '2013-04-23 17:47:12', '2013-04-23 17:47:12', '<pre lang="c" colla="-">\n#include<stdio.h>\n#define N 100\nvoid main()\n{\n  int x,y,yu,i,zen;\n  int num[N+3];\n  printf("请输入被除数！\\n");\n  scanf("%d",&x);\n  printf("请输入除数！\\n");\n  scanf("%d",&y);\n  zen=x/y;\n  num[1]=''.'';\n  for(i=2;i<=N+2;i++)\n  {\n    yu=x%y;\n   num[i]=(yu*10)/y;\nx=yu*10%y;\n}\n\nprintf("%d.",zen);\nfor(i=2;i<=N+2;i++)\n{printf("%d",num[i]);\nif(i%5==0) printf("\\n");\n}\n\n}//此程序求两整数相除精确到小数点后100位！', '疼。求小数点后100位', '', 'inherit', 'open', 'open', '', '67-autosave', '', '', '2013-04-23 17:47:12', '2013-04-23 17:47:12', '', 67, 'http://codeseeking.sinaapp.com/?p=84', 0, 'revision', '', 0),
(85, 1, '2013-04-18 01:38:59', '2013-04-18 01:38:59', '#include<stdio.h>\r\n#define N 100\r\nmain()\r\n{int x,y,yu,i,zen;\r\nint num[N+3];\r\nprintf("请输入被除数！\\n");\r\nscanf("%d",&x);\r\nprintf("请输入除数！\\n");\r\nscanf("%d",&y);\r\nzen=x/y;\r\nnum[1]=''.'';\r\nfor(i=2;i<=N+2;i++)\r\n{yu=x%y;\r\nnum[i]=(yu*10)/y;\r\nx=yu*10%y;\r\n}\r\n\r\nprintf("%d.",zen);\r\nfor(i=2;i<=N+2;i++)\r\n{printf("%d",num[i]);\r\nif(i%5==0) printf("\\n");\r\n}\r\n\r\n}//此程序求两整数相除精确到小数点后100位！', '疼。求小数点后100位', '', 'inherit', 'open', 'open', '', '67-revision-2', '', '', '2013-04-18 01:38:59', '2013-04-18 01:38:59', '', 67, 'http://codeseeking.sinaapp.com/?p=85', 0, 'revision', '', 0),
(86, 1, '2013-04-25 05:30:55', '2013-04-25 05:30:55', '取整函数test1：\r\n<pre lang="c" colla="-">\r\n#include <stdio.h>\r\n#include <math.h>\r\nvoid main(){\r\n	int a;\r\n	a = floor(2.5);\r\n	int b;\r\n	b= floor(-2.5);\r\n	printf("%d\\n%d\\n",a,b);\r\n	return ;\r\n}\r\n</pre>\r\n取位test2：\r\n<pre lang="c" colla="-">\r\n#include <stdio.h>\r\n#include <string.h>\r\ntypedef unsigned char byte;\r\nvoid main(){\r\n    float x =25.1/256;\r\n    int y;\r\n    memcpy(&y,&x,4);\r\n    printf("小数->整数：%d\\n",y);\r\n    y = y&0x00ff0000;\r\n    printf("摘取指定位：%d\\n",y);\r\n    byte c[4];\r\n    memcpy(c,&y,4);\r\n    printf("16-0x-:1-%x\\t2-%x\\t3-%x\\t4-%x\\t\\n",c[1],c[2],c[3],c[4]);\r\n    printf("10-0d-:1-%d\\t2-%d\\t3-%d\\t4-%d\\t\\n",c[1],c[2],c[3],c[4]);\r\n}\r\n</pre>\r\n位操作test3：\r\n<pre lang="c" colla="-">\r\n#include <stdio.h>\r\nvoid main(){\r\n	int a = 1;\r\n	int b = 2;\r\n	int c = 4;\r\n	int i;\r\n	i = a & b;\r\n	printf("%d\\n",i);\r\n	i = a | b;\r\n	printf("%d\\n",i);\r\n	i = a ^ b;\r\n	printf("%d\\n",i);\r\n	printf("%d\\n",~a);\r\n}\r\n</pre>', 'ETCcoding', '', 'publish', 'open', 'open', '', 'etccoding', '', '', '2013-04-25 05:31:56', '2013-04-25 05:31:56', '', 0, 'http://codeseeking.sinaapp.com/?p=86', 0, 'post', '', 0),
(87, 1, '2013-04-25 05:29:23', '2013-04-25 05:29:23', '取整函数test1：\n<pre lang="c++" colla="-">\n#include <stdio.h>\n#include <math.h>\nvoid main(){\n	int a;\n	a = floor(2.5);\n	int b;\n	b= floor(-2.5);\n	printf("%d\\n%d\\n",a,b);\n	return ;\n}\n</pre>\n取位test2：\n#include <stdio.h>\n#include <string.h>\ntypedef unsigned char byte;\nvoid main(){\n    float x =25.1/256;\n    int y;\n    memcpy(&y,&x,4);\n    printf("小数->整数：%d\\n",y);\n    y = y&0x00ff0000;\n    printf("摘取指定位：%d\\n",y);\n    byte c[4];\n    memcpy(c,&y,4);\n    printf("16-0x-:1-%x\\t2-%x\\t3-%x\\t4-%x\\t\\n",c[1],c[2],c[3],c[4]);\n    printf("10-0d-:1-%d\\t2-%d\\t3-%d\\t4-%d\\t\\n",c[1],c[2],c[3],c[4]);\n}', 'ETCcoding', '', 'inherit', 'open', 'open', '', '86-revision', '', '', '2013-04-25 05:29:23', '2013-04-25 05:29:23', '', 86, '', 0, 'revision', '', 0),
(88, 1, '2013-04-25 05:30:55', '2013-04-25 05:30:55', '取整函数test1：\r\n<pre lang="c++" colla="-">\r\n#include <stdio.h>\r\n#include <math.h>\r\nvoid main(){\r\n	int a;\r\n	a = floor(2.5);\r\n	int b;\r\n	b= floor(-2.5);\r\n	printf("%d\\n%d\\n",a,b);\r\n	return ;\r\n}\r\n</pre>\r\n取位test2：\r\n<pre lang="c++" colla="-">\r\n#include <stdio.h>\r\n#include <string.h>\r\ntypedef unsigned char byte;\r\nvoid main(){\r\n    float x =25.1/256;\r\n    int y;\r\n    memcpy(&y,&x,4);\r\n    printf("小数->整数：%d\\n",y);\r\n    y = y&0x00ff0000;\r\n    printf("摘取指定位：%d\\n",y);\r\n    byte c[4];\r\n    memcpy(c,&y,4);\r\n    printf("16-0x-:1-%x\\t2-%x\\t3-%x\\t4-%x\\t\\n",c[1],c[2],c[3],c[4]);\r\n    printf("10-0d-:1-%d\\t2-%d\\t3-%d\\t4-%d\\t\\n",c[1],c[2],c[3],c[4]);\r\n}\r\n</pre>\r\n位操作test3：\r\n<pre lang="c++" colla="-">\r\n#include <stdio.h>\r\nvoid main(){\r\n	int a = 1;\r\n	int b = 2;\r\n	int c = 4;\r\n	int i;\r\n	i = a & b;\r\n	printf("%d\\n",i);\r\n	i = a | b;\r\n	printf("%d\\n",i);\r\n	i = a ^ b;\r\n	printf("%d\\n",i);\r\n	printf("%d\\n",~a);\r\n}\r\n</pre>', 'ETCcoding', '', 'inherit', 'open', 'open', '', '86-revision-2', '', '', '2013-04-25 05:30:55', '2013-04-25 05:30:55', '', 86, 'http://codeseeking.sinaapp.com/?p=88', 0, 'revision', '', 0),
(89, 1, '2013-04-27 14:25:02', '2013-04-27 14:25:02', '剪切文本：\r\n用v选中文本之后可以按y进行复制，如果按d就表示剪切，之后按p进行粘贴。\r\n剪切一行：dd\r\n剪切当前行光标所在的位置到行尾：d$\r\n剪切当前行光标所在的位置到行首：d^\r\n前切三行：3dd,即从当前行+下两行被剪切了。\r\n2.剪切1-10行到20行\r\n：1，10 m 20', 'vim 剪切', '', 'publish', 'open', 'open', '', 'vim-%e5%89%aa%e5%88%87', '', '', '2013-04-27 14:25:02', '2013-04-27 14:25:02', '', 0, 'http://codeseeking.sinaapp.com/?p=89', 0, 'post', '', 0),
(90, 1, '2013-04-27 14:24:33', '2013-04-27 14:24:33', '剪切文本：\n用v选中文本之后可以按y进行复制，如果按d就表示剪切，之后按p进行粘贴。\n剪切一行：dd\n剪切当前行光标所在的位置到行尾：d$\n剪切当前行光标所在的位置到行首：d^\n前切三行：3dd,即从当前行+下两行被剪切了。\n2.剪切1-10行到20行\n：1，10 么', 'vim 剪切', '', 'inherit', 'open', 'open', '', '89-revision', '', '', '2013-04-27 14:24:33', '2013-04-27 14:24:33', '', 89, 'http://codeseeking.sinaapp.com/?p=90', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(92, 1, '2013-04-27 17:50:20', '2013-04-27 17:50:20', '<pre lang="c" colla="-">\r\nvoid Xprod(char k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	//y = 8*xi*xi*xi*xi - 8*x*x + 1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	y = 3.9999 * xi * ( 1 - xi);\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n</pre>\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	char KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	\r\n	//获得灰度值\r\n	picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++)\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	printf("PicGrayValue is %d \\n",picG);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	/*for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	\r\n	return 0;  \r\n}\r\n</pre>\r\n<pre lang="c" colla="-">\r\n#define N 16\r\n#define e 0.05\r\n#define BYTE unsigned char\r\n#define WORD u_int16_t\r\n#define DWORD u_int32_t\r\n//typedef unsigned char BYTE;\r\n//typedef u_int16_t WORD;\r\n//typedef u_int32_t DWORD;\r\n\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n	WORD bfType; //数据地址为 0 - "BM"  \r\n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n	WORD bfReserved1;   //DA 6 - 文件保留字 0\r\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\r\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;\r\n\r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n	DWORD biWidth;   //DA 18\r\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n	DWORD biXPelsPerMeter;   //DA 38\r\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\r\n	DWORD biClrUsed;   //DA 46 颜色变址数\r\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER; \r\n\r\ntypedef struct tagRGBQUAD{\r\n	BYTE rgbBlue;\r\n	BYTE rgbGreen;\r\n	BYTE rgbRed;\r\n	BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nclass bmpreader{\r\npublic:\r\n	BITMAPFILEHEADER head;\r\n	BITMAPINFODEADER info;\r\n	RGBQUAD colors;\r\n	int picH,picW,csize;\r\n	int Bnum;\r\n	BYTE *PicS;\r\n	bmpreader(char *picaddr);\r\n	void showRgbtag(RGBQUAD &colors);\r\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\r\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\r\n};\r\n\r\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n\r\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}\r\n\r\nbmpreader::bmpreader(char *picaddr){\r\n	FILE *fp = fopen(picaddr, "rb");  	\r\n	int palesize = 0;\r\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \r\n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \r\n	switch(info.biBitCount){\r\n	    case 1:\r\n		palesize = 2;\r\n		break;\r\n	    case 4:\r\n		palesize = 16;\r\n		break;\r\n	    case 8:\r\n		palesize = 256;\r\n		break;\r\n	}\r\n	if(palesize){\r\n	    	cout<<"存在RGBQUAD.."<<endl;\r\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n	}else{\r\n		cout<<"不存在RGBQUAD.."<<endl;\r\n	}\r\n	//showBmpHead(head);  \r\n	//showBmpInforHead(info);  \r\n	//showRgbtag(colors);\r\n	int PicData = info.biSizeImage;\r\n	if(!palesize){\r\n		int tempsize = info.biBitCount/8;\r\n		tempsize = tempsize*64;\r\n		if(PicData%tempsize){\r\n			PicData = PicData + PicData%tempsize;\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n		}\r\n		Bnum = PicData/tempsize;\r\n	}else{\r\n		if(PicData%64){\r\n			PicData = PicData + PicData%64;\r\n			cout<<PicData<<"---"<<"64"<<endl;\r\n		}	\r\n		Bnum = PicData/64;\r\n	}\r\n        //PicS = (char*)malloc(PicData);\r\n	csize = PicData;\r\n	picH = info.biHeight;\r\n	picW = info.biWidth;\r\n	PicS = (unsigned char*)new unsigned char[PicData];\r\n	memset(PicS,0,PicData);\r\n	fread(PicS,1,info.biSizeImage,fp);\r\n	if(feof(fp) == 0)\r\n	    cout<<"All in.."<<endl;\r\n	fclose(fp);  \r\n}\r\n</pre>', '序列产生', '', 'publish', 'open', 'open', 'c7722731', '%e5%ba%8f%e5%88%97%e4%ba%a7%e7%94%9f', '', '', '2013-04-27 17:55:25', '2013-04-27 17:55:25', '', 0, 'http://codeseeking.sinaapp.com/?p=92', 0, 'post', '', 0),
(93, 1, '2013-04-27 17:48:29', '2013-04-27 17:48:29', '', '序列产生', '', 'inherit', 'open', 'open', '', '92-revision', '', '', '2013-04-27 17:48:29', '2013-04-27 17:48:29', '', 92, 'http://codeseeking.sinaapp.com/?p=93', 0, 'revision', '', 0),
(94, 1, '2013-04-27 17:48:48', '2013-04-27 17:48:48', '<pre lang="c" colla="-">\r\n#include\r\n</pre>', '序列产生', '', 'inherit', 'open', 'open', '', '92-revision-2', '', '', '2013-04-27 17:48:48', '2013-04-27 17:48:48', '', 92, 'http://codeseeking.sinaapp.com/?p=94', 0, 'revision', '', 0),
(95, 1, '2013-04-27 17:52:19', '2013-04-27 17:52:19', '<pre lang="c" colla="-">\nvoid Xprod(char k[16],float pk[16]){\n	for(int i = 0;i < 16;i++){\n	    pk[i] = ((int)k[i]+0.1)/256;\n	}\n}\n\nvoid Arrydisplay(float arr[16]){\n	for(int i = 0;i<16;i++){\n		cout<<i<<"-:-"<<arr[i]<<"  ";\n	}\n	cout<<endl;\n}\nfloat f(float xi,float x){\n	float y;\n	//y = 8*xi*xi*xi*xi - 8*x*x + 1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\n	y = 3.9999 * xi * ( 1 - xi);\n	return y;	\n}\n\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\n	for(int i = 0;i < times;i++){\n		for(int j = 0;j < 16;j++){\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\n		}\n		for(int k = 0;k<16;k++)\n		    pk[k] = nk[k];\n	}\n}\n\nvoid RLSplit(float nk,WORD tempL[16],int j){\n	int y;\n	memcpy(&y,&nk,4);\n	y = y&0x00ffff00;\n	unsigned int tk;\n	memcpy(&tk,&y,4);\n	tk = tk>>8;\n	memcpy(&tempL[j],&tk,2);\n}\n\nWORD F(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = (((a&b)|((~a)&c))+d)%256;\n	return tempx;\n}\nWORD G(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = (((a&c)|((~c)&b))+d)%256;\n	return tempx;\n}\nWORD H(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = ((a^b^c)+d)%256;\n	return tempx;\n}\nWORD I(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = ((b^(a|(~c)))+d)%256;\n	return tempx;\n}\n\n\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\n	for(int i = 0;i < 4;i++){\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\n	}	\n}\n\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\n    	WORD tpk;\n	for(int k = 0;k < 16;k++){\n		//RL[16*i+k] = tempL[k]&0x00ff;\n		tpk = tempL[k]&0x00ff;\n		memcpy(&RL[16*i+k],&tpk,2);\n	}	\n}\n\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\n    	WORD tempL[16];\n	WORD tmpL[16];\n	for(int i = 0;i < eachtime/16 ;i++){\n		for(int j = 0;j < 16;j++){\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\n			RLSplit(nk[j],tempL,j);\n		}\n		SLProd(tempL,tmpL);\n		RLSave(i,tmpL,RL);\n		memset(tempL,0,16*sizeof(WORD));\n		for(int k = 0;k<16;k++)\n		    pk[k] = nk[k];\n	}\n}\n</pre>\n<pre lang="c" colla="-">\nint main( int argc, char **argv )  \n{  \n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\n	char KeyInput[16];//输入的密钥，传送走的密钥\n	float pk[16];//迭代前的各个盒子值\n	float nk[16];//迭代后的各个盒子值\n	int picH = pict.picH;\n	int picW = pict.picW;//原始图的高宽\n	int picS = pict.csize;//填充后的整体大小\n	unsigned char picG;//可能的灰度值，整体的\n	int KL;//置换中的对比值\n	int r;\n	int bnum = pict.Bnum;//分块数\n	int eachtime = picS/bnum;\n	printf("each time = %d\\n",eachtime);\n	BYTE cpics[picS];//加密后\n	memset(cpics,0,picS);\n	BYTE RL[eachtime];//每次的随机序列\n	memset(RL,0,eachtime);\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\n	//cin>>Xinput;\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\n	cin>>KeyInput;\n\n	//获得x初始盒子，迭代times次，消除。。\n	Xprod(KeyInput,pk);\n	NKProd(pk,nk,Xinput,50);\n	\n	//获得灰度值\n	picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\n	for(int i = 1;i < picW * picH;i++)\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\n	printf("PicGrayValue is %d \\n",picG);\n\n	//计算KL等信息\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\n	printf("PicKL %d \\n",KL);\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\n\n	//产生一块用的随机序列～\n	\n	RLProd(pk,nk,RL,eachtime,Xinput);\n	/*for(int s = 0;s <eachtime;s++){\n		printf("%x\\t",RL[s]);\n		if((s%10 == 0)&&(s!=0))\n		    printf("\\n");\n	}\n	printf("\\n");*/\n	RLProd(pk,nk,RL,eachtime,Xinput);\n	\n	return 0;  \n}\n</pre>\n<pre lang="c" colla="-">\n\n</pre>', '序列产生', '', 'inherit', 'open', 'open', '', '92-autosave', '', '', '2013-04-27 17:52:19', '2013-04-27 17:52:19', '', 92, 'http://codeseeking.sinaapp.com/?p=95', 0, 'revision', '', 0),
(96, 1, '2013-04-27 17:50:20', '2013-04-27 17:50:20', '<pre lang="c" colla="-">\r\nvoid Xprod(char k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	//y = 8*xi*xi*xi*xi - 8*x*x + 1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	y = 3.9999 * xi * ( 1 - xi);\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n</pre>', '序列产生', '', 'inherit', 'open', 'open', '', '92-revision-3', '', '', '2013-04-27 17:50:20', '2013-04-27 17:50:20', '', 92, 'http://codeseeking.sinaapp.com/?p=96', 0, 'revision', '', 0),
(97, 1, '2013-04-27 17:52:50', '2013-04-27 17:52:50', '<pre lang="c" colla="-">\r\nvoid Xprod(char k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	//y = 8*xi*xi*xi*xi - 8*x*x + 1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	y = 3.9999 * xi * ( 1 - xi);\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n</pre>\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	char KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	\r\n	//获得灰度值\r\n	picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++)\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	printf("PicGrayValue is %d \\n",picG);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	/*for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	\r\n	return 0;  \r\n}\r\n</pre>\r\n<pre lang="c" colla="-">\r\n#define N 16\r\n#define e 0.05\r\n#define BYTE unsigned char\r\n#define WORD u_int16_t\r\n#define DWORD u_int32_t\r\n//typedef unsigned char BYTE;\r\n//typedef u_int16_t WORD;\r\n//typedef u_int32_t DWORD;\r\n\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n	WORD bfType; //数据地址为 0 - "BM"  \r\n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n	WORD bfReserved1;   //DA 6 - 文件保留字 0\r\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\r\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;\r\n\r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n	DWORD biWidth;   //DA 18\r\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n	DWORD biXPelsPerMeter;   //DA 38\r\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\r\n	DWORD biClrUsed;   //DA 46 颜色变址数\r\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER; \r\n\r\ntypedef struct tagRGBQUAD{\r\n	BYTE rgbBlue;\r\n	BYTE rgbGreen;\r\n	BYTE rgbRed;\r\n	BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nclass bmpreader{\r\npublic:\r\n	BITMAPFILEHEADER head;\r\n	BITMAPINFODEADER info;\r\n	RGBQUAD colors;\r\n	int picH,picW,csize;\r\n	int Bnum;\r\n	BYTE *PicS;\r\n	bmpreader(char *picaddr);\r\n	void showRgbtag(RGBQUAD &colors);\r\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\r\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\r\n};\r\n\r\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n\r\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}\r\n\r\nbmpreader::bmpreader(char *picaddr){\r\n	FILE *fp = fopen(picaddr, "rb");  	\r\n	int palesize = 0;\r\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \r\n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \r\n	switch(info.biBitCount){\r\n	    case 1:\r\n		palesize = 2;\r\n		break;\r\n	    case 4:\r\n		palesize = 16;\r\n		break;\r\n	    case 8:\r\n		palesize = 256;\r\n		break;\r\n	}\r\n	if(palesize){\r\n	    	cout<<"存在RGBQUAD.."<<endl;\r\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n	}else{\r\n		cout<<"不存在RGBQUAD.."<<endl;\r\n	}\r\n	//showBmpHead(head);  \r\n	//showBmpInforHead(info);  \r\n	//showRgbtag(colors);\r\n	int PicData = info.biSizeImage;\r\n	if(!palesize){\r\n		int tempsize = info.biBitCount/8;\r\n		tempsize = tempsize*64;\r\n		if(PicData%tempsize){\r\n			PicData = PicData + PicData%tempsize;\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n		}\r\n		Bnum = PicData/tempsize;\r\n	}else{\r\n		if(PicData%64){\r\n			PicData = PicData + PicData%64;\r\n			cout<<PicData<<"---"<<"64"<<endl;\r\n		}	\r\n		Bnum = PicData/64;\r\n	}\r\n        //PicS = (char*)malloc(PicData);\r\n	csize = PicData;\r\n	picH = info.biHeight;\r\n	picW = info.biWidth;\r\n	PicS = (unsigned char*)new unsigned char[PicData];\r\n	memset(PicS,0,PicData);\r\n	fread(PicS,1,info.biSizeImage,fp);\r\n	if(feof(fp) == 0)\r\n	    cout<<"All in.."<<endl;\r\n	fclose(fp);  \r\n}\r\n</pre>', '序列产生', '', 'inherit', 'open', 'open', '', '92-revision-4', '', '', '2013-04-27 17:52:50', '2013-04-27 17:52:50', '', 92, 'http://codeseeking.sinaapp.com/?p=97', 0, 'revision', '', 0),
(98, 1, '2013-04-27 17:53:41', '2013-04-27 17:53:41', '<pre lang="c" colla="-">\r\nvoid Xprod(char k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	//y = 8*xi*xi*xi*xi - 8*x*x + 1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	y = 3.9999 * xi * ( 1 - xi);\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n</pre>\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	char KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	\r\n	//获得灰度值\r\n	picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++)\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	printf("PicGrayValue is %d \\n",picG);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	/*for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	\r\n	return 0;  \r\n}\r\n</pre>\r\n<pre lang="c" colla="-">\r\n#define N 16\r\n#define e 0.05\r\n#define BYTE unsigned char\r\n#define WORD u_int16_t\r\n#define DWORD u_int32_t\r\n//typedef unsigned char BYTE;\r\n//typedef u_int16_t WORD;\r\n//typedef u_int32_t DWORD;\r\n\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n	WORD bfType; //数据地址为 0 - "BM"  \r\n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n	WORD bfReserved1;   //DA 6 - 文件保留字 0\r\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\r\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;\r\n\r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n	DWORD biWidth;   //DA 18\r\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n	DWORD biXPelsPerMeter;   //DA 38\r\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\r\n	DWORD biClrUsed;   //DA 46 颜色变址数\r\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER; \r\n\r\ntypedef struct tagRGBQUAD{\r\n	BYTE rgbBlue;\r\n	BYTE rgbGreen;\r\n	BYTE rgbRed;\r\n	BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nclass bmpreader{\r\npublic:\r\n	BITMAPFILEHEADER head;\r\n	BITMAPINFODEADER info;\r\n	RGBQUAD colors;\r\n	int picH,picW,csize;\r\n	int Bnum;\r\n	BYTE *PicS;\r\n	bmpreader(char *picaddr);\r\n	void showRgbtag(RGBQUAD &colors);\r\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\r\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\r\n};\r\n\r\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n\r\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}\r\n\r\nbmpreader::bmpreader(char *picaddr){\r\n	FILE *fp = fopen(picaddr, "rb");  	\r\n	int palesize = 0;\r\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \r\n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \r\n	switch(info.biBitCount){\r\n	    case 1:\r\n		palesize = 2;\r\n		break;\r\n	    case 4:\r\n		palesize = 16;\r\n		break;\r\n	    case 8:\r\n		palesize = 256;\r\n		break;\r\n	}\r\n	if(palesize){\r\n	    	cout<<"存在RGBQUAD.."<<endl;\r\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n	}else{\r\n		cout<<"不存在RGBQUAD.."<<endl;\r\n	}\r\n	//showBmpHead(head);  \r\n	//showBmpInforHead(info);  \r\n	//showRgbtag(colors);\r\n	int PicData = info.biSizeImage;\r\n	if(!palesize){\r\n		int tempsize = info.biBitCount/8;\r\n		tempsize = tempsize*64;\r\n		if(PicData%tempsize){\r\n			PicData = PicData + PicData%tempsize;\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n		}\r\n		Bnum = PicData/tempsize;\r\n	}else{\r\n		if(PicData%64){\r\n			PicData = PicData + PicData%64;\r\n			cout<<PicData<<"---"<<"64"<<endl;\r\n		}	\r\n		Bnum = PicData/64;\r\n	}\r\n        //PicS = (char*)malloc(PicData);\r\n	csize = PicData;\r\n	picH = info.biHeight;\r\n	picW = info.biWidth;\r\n	PicS = (unsigned char*)new unsigned char[PicData];\r\n	memset(PicS,0,PicData);\r\n	fread(PicS,1,info.biSizeImage,fp);\r\n	if(feof(fp) == 0)\r\n	    cout<<"All in.."<<endl;\r\n	fclose(fp);  \r\n}\r\n</pre>', '序列产生', '', 'inherit', 'open', 'open', '', '92-revision-5', '', '', '2013-04-27 17:53:41', '2013-04-27 17:53:41', '', 92, 'http://codeseeking.sinaapp.com/?p=98', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(108, 1, '2013-05-06 06:32:30', '2013-05-06 06:32:30', 'pichandle.c\r\n<pre lang="c" colla="-">\r\n#include "pichandle.h"\r\n/*void Xprod(char k[16],float pk[16]);//根据输入的序列产生最早的x0\r\nvoid NKProd(float pk[16],float nk[16],float xinput,float e,int times);//初始迭代times次，消除初始影响\r\nfloat f(float xi,float x);//局部混沌函数\r\nvoid RLProd(float *pk,float *nk,char *RL);//正常迭代，每次产生64字节随机序列\r\nvoid RLSplit(float nk,char *RL,int i,int j);//取位函数*/\r\n\r\nvoid Xprod(BYTE k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	y = 8*xi*xi*xi*xi-8*xi*xi+1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	if(y < 0)\r\n	    y = -y;\r\n	//y = 3.9999 * xi * ( 1 - xi);\r\n	//y = 4 * xi * xi * xi - 3 * xi;\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nBYTE cycL(BYTE a,BYTE b){\r\n    a = (a>>(8 - b))|(a<<b);\r\n    return a;\r\n}\r\n\r\nBYTE LSB(BYTE c){\r\n	BYTE tc = c & 0x07;\r\n	return tc;\r\n}\r\n\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d Num = %d\\n",eachtime,bnum);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	//获得灰度值\r\n	/*picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++){\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	}\r\n	printf("PicGrayValue is %d \\n",picG);*/\r\n	picG = 0xff;\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\r\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);*/\r\n				    	//CK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^BK[3*(8*i+j)+n];\r\n					RSR = LSB(LCL[3*j+n]);\r\n					RSL = cycL(BK[3*(8*i+j)+n],RSR);\r\n					CK[3*(8*i+j)+n] = RSL^RL[3*(8*i+j)+n];\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum - 1){\r\n			while((Knew == KL)|(picheck[Knew]!=0))\r\n				Knew = (Knew + 1)%bnum;\r\n			//cout<<Knew<<"  ";\r\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\r\n			picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\r\n			picheck[KL] = 1;\r\n		}\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(3*(y+d))%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		//memcpy(cpics+eachtime*k,CK,eachtime);\r\n		for(int m=0 ; m<16 ; m++)\r\n			pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("cpic.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>\r\npichandle.h\r\n<pre lang="c" colla="-">\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <sys/types.h>\r\n#include<iostream>\r\n#pragma pack(2)\r\n\r\nusing namespace std;\r\n\r\n#define N 16\r\n#define e 0.05\r\n#define BYTE unsigned char\r\n#define WORD u_int16_t\r\n#define DWORD u_int32_t\r\n//typedef unsigned char BYTE;\r\n//typedef u_int16_t WORD;\r\n//typedef u_int32_t DWORD;\r\n\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n	WORD bfType; //数据地址为 0 - "BM"  \r\n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n	WORD bfReserved1;   //DA 6 - 文件保留字 0\r\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\r\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;\r\n\r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n	DWORD biWidth;   //DA 18\r\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n	DWORD biXPelsPerMeter;   //DA 38\r\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\r\n	DWORD biClrUsed;   //DA 46 颜色变址数\r\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER; \r\n\r\ntypedef struct tagRGBQUAD{\r\n	BYTE rgbBlue;\r\n	BYTE rgbGreen;\r\n	BYTE rgbRed;\r\n	BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nclass bmpreader{\r\npublic:\r\n	BITMAPFILEHEADER head;\r\n	BITMAPINFODEADER info;\r\n	RGBQUAD colors;\r\n	int picH,picW,csize;\r\n	int Bnum;\r\n	BYTE *PicS;\r\n	bmpreader(char *picaddr);\r\n	void showRgbtag(RGBQUAD &colors);\r\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\r\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\r\n};\r\n\r\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n\r\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}\r\n\r\nbmpreader::bmpreader(char *picaddr){\r\n	FILE *fp = fopen(picaddr, "rb");  	\r\n	int palesize = 0;\r\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \r\n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \r\n	switch(info.biBitCount){\r\n	    case 1:\r\n		palesize = 2;\r\n		break;\r\n	    case 4:\r\n		palesize = 16;\r\n		break;\r\n	    case 8:\r\n		palesize = 256;\r\n		break;\r\n	}\r\n	if(palesize){\r\n	    	cout<<"存在RGBQUAD.."<<endl;\r\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n	}else{\r\n		cout<<"不存在RGBQUAD.."<<endl;\r\n	}\r\n	showBmpHead(head);  \r\n	showBmpInforHead(info);  \r\n	//showRgbtag(colors);\r\n	int PicData = info.biSizeImage;\r\n	if(!palesize){\r\n		int tempsize = info.biBitCount/8;\r\n		tempsize = tempsize*64;\r\n		if(PicData%tempsize){\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n			PicData = PicData + (tempsize-PicData%tempsize);\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n		}\r\n		Bnum = PicData/tempsize;\r\n	}else{\r\n		if(PicData%64){\r\n			PicData = PicData + PicData%64;\r\n			cout<<PicData<<"---"<<"64"<<endl;\r\n		}	\r\n		Bnum = PicData/64;\r\n	}\r\n        //PicS = (char*)malloc(PicData);\r\n	csize = PicData;\r\n	picH = info.biHeight;\r\n	picW = info.biWidth;\r\n	PicS = (unsigned char*)new unsigned char[PicData];\r\n	memset(PicS,0,PicData);\r\n	fread(PicS,1,info.biSizeImage,fp);\r\n	if(feof(fp) == 0)\r\n	    cout<<"All in.."<<endl;\r\n	fclose(fp);  \r\n}\r\n\r\n\r\n/*void Xprod(char *k,float *pk);//根据输入的序列产生最早的x0\r\nvoid NKProd(float *pk,float *nk,int times);//初始迭代times次，消除初始影响\r\nfloat f(float xi,float x);//局部混沌函数\r\nvoid RLProd(float *pk,float *nk,char *RL);//正常迭代，每次产生64字节随机序列\r\nvoid RLSplit(float *nk,char *RL,int i,int j);//取位函数*/\r\n</pre>\r\nrepic.h\r\n<pre lang="c" colla="-">\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <sys/types.h>\r\n#include<iostream>\r\n#pragma pack(2)\r\n\r\nusing namespace std;\r\n\r\n#define N 16\r\n#define e 0.05\r\n#define BYTE unsigned char\r\n#define WORD u_int16_t\r\n#define DWORD u_int32_t\r\n//typedef unsigned char BYTE;\r\n//typedef u_int16_t WORD;\r\n//typedef u_int32_t DWORD;\r\n\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n	WORD bfType; //数据地址为 0 - "BM"  \r\n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n	WORD bfReserved1;   //DA 6 - 文件保留字 0\r\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\r\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;\r\n\r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n	DWORD biWidth;   //DA 18\r\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n	DWORD biXPelsPerMeter;   //DA 38\r\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\r\n	DWORD biClrUsed;   //DA 46 颜色变址数\r\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER; \r\n\r\ntypedef struct tagRGBQUAD{\r\n	BYTE rgbBlue;\r\n	BYTE rgbGreen;\r\n	BYTE rgbRed;\r\n	BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nclass bmpreader{\r\npublic:\r\n	BITMAPFILEHEADER head;\r\n	BITMAPINFODEADER info;\r\n	RGBQUAD colors;\r\n	int picH,picW,csize;\r\n	int Bnum;\r\n	BYTE *PicS;\r\n	bmpreader(char *picaddr);\r\n	void showRgbtag(RGBQUAD &colors);\r\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\r\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\r\n};\r\n\r\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n\r\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    //cout<<"位图文件头:"<<endl;    \r\n    //cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    //cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    //cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    //cout<<"位图信息头:"<<endl;    \r\n    //cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    //cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n    //cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n    //cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n    cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n    //cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n    cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n    //cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n    //cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n    //cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n    //cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}\r\n\r\nbmpreader::bmpreader(char *picaddr){\r\n	FILE *fp = fopen(picaddr, "rb");  	\r\n	int palesize = 0;\r\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \r\n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \r\n	switch(info.biBitCount){\r\n	    case 1:\r\n		palesize = 2;\r\n		break;\r\n	    case 4:\r\n		palesize = 16;\r\n		break;\r\n	    case 8:\r\n		palesize = 256;\r\n		break;\r\n	}\r\n	if(palesize){\r\n	    	cout<<"存在RGBQUAD.."<<endl;\r\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n	}else{\r\n		cout<<"不存在RGBQUAD.."<<endl;\r\n	}\r\n	//showBmpHead(head);  \r\n	//showBmpInforHead(info);  \r\n	//showRgbtag(colors);\r\n	int PicData = info.biSizeImage;\r\n	if(!palesize){\r\n		int tempsize = info.biBitCount/8;\r\n		tempsize = tempsize*64;\r\n		if(PicData%tempsize){\r\n			PicData = PicData + PicData%tempsize;\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n		}\r\n		Bnum = PicData/tempsize;\r\n	}else{\r\n		if(PicData%64){\r\n			PicData = PicData + PicData%64;\r\n			cout<<PicData<<"---"<<"64"<<endl;\r\n		}	\r\n		Bnum = PicData/64;\r\n	}\r\n        //PicS = (char*)malloc(PicData);\r\n	csize = PicData;\r\n	picH = info.biHeight;\r\n	picW = info.biWidth;\r\n	PicS = (unsigned char*)new unsigned char[PicData];\r\n	memset(PicS,0,PicData);\r\n	fread(PicS,1,info.biSizeImage,fp);\r\n	if(feof(fp) == 0)\r\n	    cout<<"All in.."<<endl;\r\n	fclose(fp);  \r\n}\r\n</pre>\r\nrepic.c\r\n<pre lang="c" colla="-">\r\n#include "repic.h"\r\n\r\nvoid Xprod(BYTE k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	y = 8*xi*xi*xi*xi - 8*x*x + 1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	if(y < 0)\r\n	    y =-y;\r\n	//y = 3.9999 * xi * ( 1 - xi);\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nBYTE cycR(BYTE a,BYTE b){\r\n    a = (a<<(8 - b))|(a>>b);\r\n    return a;\r\n}\r\n\r\nBYTE LSB(BYTE c){\r\n	BYTE tc = c & 0x07;\r\n	return tc;\r\n}\r\n\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	picG = 0xff;\r\n	//cout<<"Please input the PicGreyvalue"<<endl;\r\n	//cin>>picG;\r\n	//printf("PicGrayValue is %d \\n",picG);\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n	    	Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum-1){\r\n		while((Knew == KL)|(picheck[Knew]!=0))\r\n			Knew = (Knew + 1)%bnum;\r\n		//cout<<Knew<<"  ";\r\n		memcpy(CK,pict.PicS+eachtime*Knew,eachtime);\r\n		picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(CK,pict.PicS+eachtime*KL,eachtime);\r\n			picheck[KL] = 1;\r\n		}\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					RSL = cycR(CK[3*(8*i+j)+n],RSR);\r\n					BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^(RSL-LCL[3*j+n]+picG)%picG;*/\r\n				    	//BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^CK[3*(8*i+j)+n];\r\n					RSR = LSB(LCL[3*j+n]);\r\n					RSL = CK[3*(8*i+j)+n]^RL[3*(8*i+j)+n];\r\n					BK[3*(8*i+j)+n] = cycR(RSL,RSR);\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		memcpy(cpics+eachtime*k,BK,eachtime);\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(y+d)%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		for(int m=0 ; m<16 ; m++)\r\n		    pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n\r\n	picS = picH*picW*3;\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("repic.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>', 'pichandle&repic for last', '', 'publish', 'open', 'open', 'char7722731', 'pichandlerepic-for-last', '', '', '2014-05-21 08:21:55', '2014-05-21 08:21:55', '', 0, 'http://codeseeking.sinaapp.com/?p=108', 0, 'post', '', 0),
(100, 1, '2013-04-28 16:38:21', '2013-04-28 16:38:21', '真心有时候觉得编写电视剧的人太厉害了，让我们总在为认为是该在一起的人不在一起的扼腕叹息的时候却一直给的些许的希望而看下去，虽然最后结果已经知道了。有些时候有些事情真的没法说。', '电视剧有感', '', 'publish', 'open', 'open', '', '%e7%94%b5%e8%a7%86%e5%89%a7%e6%9c%89%e6%84%9f', '', '', '2013-04-28 16:38:21', '2013-04-28 16:38:21', '', 0, 'http://codeseeking.sinaapp.com/?p=100', 0, 'post', '', 0),
(101, 1, '2013-04-28 16:37:39', '2013-04-28 16:37:39', '真心有时候觉得编写电视剧的人太厉害了，让我们总在为认为是该在一起的人不在一起的扼腕叹息的时候却一直给只', '电视剧有感', '', 'inherit', 'open', 'open', '', '100-revision', '', '', '2013-04-28 16:37:39', '2013-04-28 16:37:39', '', 100, 'http://codeseeking.sinaapp.com/?p=101', 0, 'revision', '', 0),
(103, 1, '2013-04-30 18:11:12', '2013-04-30 18:11:12', '调整后的main\n<pre lang="c" colla="-">\nint main( int argc, char **argv )  \n{  \n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\n	float pk[16];//迭代前的各个盒子值\n	float nk[16];//迭代后的各个盒子值\n	int picH = pict.picH;\n	int picW = pict.picW;//原始图的高宽\n	int picS = pict.csize;//填充后的整体大小\n	unsigned char picG;//可能的灰度值，整体的\n	int KL;//置换中的对比值\n	int r;\n	int bnum = pict.Bnum;//分块数\n	int eachtime = picS/bnum;\n	printf("each time = %d\\n",eachtime);\n	BYTE cpics[picS];//加密后\n	memset(cpics,0,picS);\n	BYTE RL[eachtime];//每次的随机序列\n	memset(RL,0,eachtime);\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\n	//cin>>Xinput;\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\n	cin>>KeyInput;\n\n	//获得x初始盒子，迭代times次，消除。。\n	Xprod(KeyInput,pk);\n	NKProd(pk,nk,Xinput,50);\n	Arrydisplay(nk);	\n	\n	//获得灰度值\n	picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\n	for(int i = 1;i < picW * picH;i++){\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\n	}\n	printf("PicGrayValue is %d \\n",picG);\n\n	//计算KL等信息\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\n	printf("PicKL %d \\n",KL);\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\n\n	//产生一块用的随机序列～\n	RLProd(pk,nk,RL,eachtime,Xinput);\n	//正常序列产生和循环移位与取位函数测试输出\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\n	for(int s = 0;s <eachtime;s++){\n		printf("%x\\t",RL[s]);\n		if((s%10 == 0)&&(s!=0))\n		    printf("\\n");\n	}\n	printf("\\n");*/\n	\n	BYTE LCL[24];\n	BYTE picheck[bnum];\n	BYTE BK[eachtime];\n	BYTE CK[eachtime];\n	BYTE RSL,RSR;\n	int Knew;\n	int d,tx;\n	memset(picheck,0,bnum);\n	memcpy(LCL,KeyInput+8,8);\n	memcpy(LCL+8,KeyInput+8,8);\n	memcpy(LCL+16,KeyInput+8,8);\n	for(int k = 0;k < bnum ; k++){\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\n		for(int i = 0 ; i < 8 ; i ++){\n			for(int j = 0 ; j < 8 ; j++){\n				for(int n = 0 ; n < 3 ; n++){\n					RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);\n		\n				}\n			}\n			memcpy(LCL,CK+8*i,24);\n		}\n		Knew = (int)(nk[0]*bnum);\n		if(k != bnum - 1){\n			while((Knew == KL)|(picheck[Knew]!=0))\n				Knew = (Knew + 1)%bnum;\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\n			picheck[Knew] = 1;\n		}else{\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\n			picheck[KL] = 1;\n		}\n		d = LSB(LCL[0]);\n		for(int y = 0 ; y < 4 ; y ++){\n			if(LCL[y]>LCL[(3*(y+d))%8]){\n				tx = nk[y];\n				nk[y] = nk[(y+d)%8];\n				nk[(y+d)%8] = tx;	\n			}\n		}\n		//memcpy(cpics+eachtime*k,CK,eachtime);\n		for(int m=0 ; m<16 ; m++)\n			pk[m] = nk[m];\n		RLProd(pk,nk,RL,eachtime,Xinput);\n	}\n	pict.info.biSizeImage = picS;\n	pict.head.bfSize = picS + 54;\n	FILE *rfp = fopen("cpicC.bmp","wb");\n	fwrite(&pict.head,1,14,rfp);\n	fwrite(&pict.info,1,40,rfp);\n	fwrite(cpics,1,picS,rfp);\n	fclose(rfp);\n	return 0;  \n}\n</pre>', '置乱扩散调整', '', 'inherit', 'open', 'open', '', '102-revision', '', '', '2013-04-30 18:11:12', '2013-04-30 18:11:12', '', 102, 'http://codeseeking.sinaapp.com/?p=103', 0, 'revision', '', 0),
(116, 1, '2013-05-09 16:05:06', '2013-05-09 16:05:06', 'http://eigen.tuxfamily.org/', 'matrices, vectors, numerical solvers, and related algorithms', '', 'publish', 'open', 'open', '', 'matrices-vectors-numerical-solvers-and-related-algorithms', '', '', '2013-05-09 16:05:06', '2013-05-09 16:05:06', '', 0, 'http://codeseeking.sinaapp.com/?p=116', 0, 'post', '', 0),
(105, 1, '2013-04-30 21:41:21', '2013-04-30 21:41:21', '加密：\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	\r\n	//获得灰度值\r\n	/*picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++){\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	}\r\n	printf("PicGrayValue is %d \\n",picG);*/\r\n	picG = 0xff;\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\r\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);*/\r\n				    	CK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^BK[3*(8*i+j)+n];\r\n		\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum - 1){\r\n			while((Knew == KL)|(picheck[Knew]!=0))\r\n				Knew = (Knew + 1)%bnum;\r\n			//cout<<Knew<<"  ";\r\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\r\n			picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\r\n			picheck[KL] = 1;\r\n		}\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(3*(y+d))%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		//memcpy(cpics+eachtime*k,CK,eachtime);\r\n		for(int m=0 ; m<16 ; m++)\r\n			pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("cpicC.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>\r\n解密：\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	picG = 0xff;\r\n	//cout<<"Please input the PicGreyvalue"<<endl;\r\n	//cin>>picG;\r\n	//printf("PicGrayValue is %d \\n",picG);\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n	    	Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum-1){\r\n		while((Knew == KL)|(picheck[Knew]!=0))\r\n			Knew = (Knew + 1)%bnum;\r\n		//cout<<Knew<<"  ";\r\n		memcpy(CK,pict.PicS+eachtime*Knew,eachtime);\r\n		picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(CK,pict.PicS+eachtime*KL,eachtime);\r\n			picheck[KL] = 1;\r\n		}\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					RSL = cycR(CK[3*(8*i+j)+n],RSR);\r\n					BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^(RSL-LCL[3*j+n]+picG)%picG;*/\r\n				    	BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^CK[3*(8*i+j)+n];\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		memcpy(cpics+eachtime*k,BK,eachtime);\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(y+d)%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		for(int m=0 ; m<16 ; m++)\r\n		    pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n\r\n	picS = picH*picW*3;\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("repic.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>', '加解密 之 Double main()', '', 'publish', 'open', 'open', 'cc123123', 'double-main', '', '', '2014-05-21 08:20:55', '2014-05-21 08:20:55', '', 0, 'http://codeseeking.sinaapp.com/?p=105', 0, 'post', '', 0),
(106, 1, '2013-04-30 21:40:31', '2013-04-30 21:40:31', '加密：\n<pre lang="c" colla="-">\n\n</pre>\n解密：\n<pre lang="c" colla="-">\n\n</pre>', 'Double main()', '', 'inherit', 'open', 'open', '', '105-revision', '', '', '2013-04-30 21:40:31', '2013-04-30 21:40:31', '', 105, 'http://codeseeking.sinaapp.com/?p=106', 0, 'revision', '', 0),
(107, 1, '2013-04-30 18:11:32', '2013-04-30 18:11:32', '调整后的main\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	Arrydisplay(nk);	\r\n	\r\n	//获得灰度值\r\n	picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++){\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	}\r\n	printf("PicGrayValue is %d \\n",picG);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\r\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);\r\n		\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum - 1){\r\n			while((Knew == KL)|(picheck[Knew]!=0))\r\n				Knew = (Knew + 1)%bnum;\r\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\r\n			picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\r\n			picheck[KL] = 1;\r\n		}\r\n		d = LSB(LCL[0]);\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(3*(y+d))%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}\r\n		//memcpy(cpics+eachtime*k,CK,eachtime);\r\n		for(int m=0 ; m<16 ; m++)\r\n			pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n	}\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("cpicC.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>', '置乱扩散调整', '', 'inherit', 'open', 'open', '', '102-revision-2', '', '', '2013-04-30 18:11:32', '2013-04-30 18:11:32', '', 102, 'http://codeseeking.sinaapp.com/?p=107', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(109, 1, '2013-05-06 06:31:09', '2013-05-06 06:31:09', 'pichandle.c\n<pre lang="c" colla="-">\n#include "pichandle.h"\n/*void Xprod(char k[16],float pk[16]);//根据输入的序列产生最早的x0\nvoid NKProd(float pk[16],float nk[16],float xinput,float e,int times);//初始迭代times次，消除初始影响\nfloat f(float xi,float x);//局部混沌函数\nvoid RLProd(float *pk,float *nk,char *RL);//正常迭代，每次产生64字节随机序列\nvoid RLSplit(float nk,char *RL,int i,int j);//取位函数*/\n\nvoid Xprod(BYTE k[16],float pk[16]){\n	for(int i = 0;i < 16;i++){\n	    pk[i] = ((int)k[i]+0.1)/256;\n	}\n}\n\nvoid Arrydisplay(float arr[16]){\n	for(int i = 0;i<16;i++){\n		cout<<i<<"-:-"<<arr[i]<<"  ";\n	}\n	cout<<endl;\n}\nfloat f(float xi,float x){\n	float y;\n	y = 8*xi*xi*xi*xi-8*xi*xi+1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\n	if(y < 0)\n	    y = -y;\n	//y = 3.9999 * xi * ( 1 - xi);\n	//y = 4 * xi * xi * xi - 3 * xi;\n	return y;	\n}\n\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\n	for(int i = 0;i < times;i++){\n		for(int j = 0;j < 16;j++){\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\n		}\n		for(int k = 0;k<16;k++)\n		    pk[k] = nk[k];\n	}\n}\n\nvoid RLSplit(float nk,WORD tempL[16],int j){\n	int y;\n	memcpy(&y,&nk,4);\n	y = y&0x00ffff00;\n	unsigned int tk;\n	memcpy(&tk,&y,4);\n	tk = tk>>8;\n	memcpy(&tempL[j],&tk,2);\n}\n\nWORD F(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = (((a&b)|((~a)&c))+d)%256;\n	return tempx;\n}\nWORD G(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = (((a&c)|((~c)&b))+d)%256;\n	return tempx;\n}\nWORD H(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = ((a^b^c)+d)%256;\n	return tempx;\n}\nWORD I(WORD a,WORD b,WORD c,WORD d){\n	WORD tempx;\n	tempx = ((b^(a|(~c)))+d)%256;\n	return tempx;\n}\n\n\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\n	for(int i = 0;i < 4;i++){\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\n	}	\n}\n\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\n    	WORD tpk;\n	for(int k = 0;k < 16;k++){\n		//RL[16*i+k] = tempL[k]&0x00ff;\n		tpk = tempL[k]&0x00ff;\n		memcpy(&RL[16*i+k],&tpk,2);\n	}	\n}\n\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\n    	WORD tempL[16];\n	WORD tmpL[16];\n	for(int i = 0;i < eachtime/16 ;i++){\n		for(int j = 0;j < 16;j++){\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\n			RLSplit(nk[j],tempL,j);\n		}\n		SLProd(tempL,tmpL);\n		RLSave(i,tmpL,RL);\n		memset(tempL,0,16*sizeof(WORD));\n		for(int k = 0;k<16;k++)\n		    pk[k] = nk[k];\n	}\n}\n\nBYTE cycL(BYTE a,BYTE b){\n    a = (a>>(8 - b))|(a<<b);\n    return a;\n}\n\nBYTE LSB(BYTE c){\n	BYTE tc = c & 0x07;\n	return tc;\n}\n\n\nint main( int argc, char **argv )  \n{  \n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\n	float pk[16];//迭代前的各个盒子值\n	float nk[16];//迭代后的各个盒子值\n	int picH = pict.picH;\n	int picW = pict.picW;//原始图的高宽\n	int picS = pict.csize;//填充后的整体大小\n	unsigned char picG;//可能的灰度值，整体的\n	int KL;//置换中的对比值\n	int r;\n	int bnum = pict.Bnum;//分块数\n	int eachtime = picS/bnum;\n	printf("each time = %d Num = %d\\n",eachtime,bnum);\n	BYTE cpics[picS];//加密后\n	memset(cpics,0,picS);\n	BYTE RL[eachtime];//每次的随机序列\n	memset(RL,0,eachtime);\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\n	//cin>>Xinput;\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\n	cin>>KeyInput;\n\n	//获得x初始盒子，迭代times次，消除。。\n	Xprod(KeyInput,pk);\n	NKProd(pk,nk,Xinput,50);\n	//获得灰度值\n	/*picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\n	for(int i = 1;i < picW * picH;i++){\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\n	}\n	printf("PicGrayValue is %d \\n",picG);*/\n	picG = 0xff;\n\n	//计算KL等信息\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\n	printf("PicKL %d \\n",KL);\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\n\n	//产生一块用的随机序列～\n	RLProd(pk,nk,RL,eachtime,Xinput);\n	//正常序列产生和循环移位与取位函数测试输出\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\n	for(int s = 0;s <eachtime;s++){\n		printf("%x\\t",RL[s]);\n		if((s%10 == 0)&&(s!=0))\n		    printf("\\n");\n	}\n	printf("\\n");*/\n	\n	BYTE LCL[24];\n	BYTE picheck[bnum];\n	BYTE BK[eachtime];\n	BYTE CK[eachtime];\n	BYTE RSL,RSR;\n	int Knew;\n	int d,tx;\n	memset(picheck,0,bnum);\n	memcpy(LCL,KeyInput+8,8);\n	memcpy(LCL+8,KeyInput+8,8);\n	memcpy(LCL+16,KeyInput+8,8);\n	for(int k = 0;k < bnum ; k++){\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\n		for(int i = 0 ; i < 8 ; i ++){\n			for(int j = 0 ; j < 8 ; j++){\n				for(int n = 0 ; n < 3 ; n++){\n					/*RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);*/\n				    	//CK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^BK[3*(8*i+j)+n];\n					RSR = LSB(LCL[3*j+n]);\n					RSL = cycL(BK[3*(8*i+j)+n],RSR);\n					CK[3*(8*i+j)+n] = RSL^RL[3*(8*i+j)+n];\n				}\n			}\n			memcpy(LCL,CK+8*i,24);\n		}\n		Knew = (int)(nk[0]*bnum);\n		if(k != bnum - 1){\n			while((Knew == KL)|(picheck[Knew]!=0))\n				Knew = (Knew + 1)%bnum;\n			//cout<<Knew<<"  ";\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\n			picheck[Knew] = 1;\n		}else{\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\n			picheck[KL] = 1;\n		}\n		/*d = LSB(LCL[0]);\n		//cout<<d<<"  ";\n		for(int y = 0 ; y < 4 ; y ++){\n			if(LCL[y]>LCL[(3*(y+d))%8]){\n				tx = nk[y];\n				nk[y] = nk[(y+d)%8];\n				nk[(y+d)%8] = tx;	\n			}\n		}*/\n		//memcpy(cpics+eachtime*k,CK,eachtime);\n		for(int m=0 ; m<16 ; m++)\n			pk[m] = nk[m];\n		RLProd(pk,nk,RL,eachtime,Xinput);\n		//Arrydisplay(nk);\n	}\n	pict.info.biSizeImage = picS;\n	pict.head.bfSize = picS + 54;\n	FILE *rfp = fopen("cpic.bmp","wb");\n	fwrite(&pict.head,1,14,rfp);\n	fwrite(&pict.info,1,40,rfp);\n	fwrite(cpics,1,picS,rfp);\n	fclose(rfp);\n	return 0;  \n}\n</pre>\npichandle.h\n<pre lang="c" colla="-">\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <sys/types.h>\n#include<iostream>\n#pragma pack(2)\n\nusing namespace std;\n\n#define N 16\n#define e 0.05\n#define BYTE unsigned char\n#define WORD u_int16_t\n#define DWORD u_int32_t\n//typedef unsigned char BYTE;\n//typedef u_int16_t WORD;\n//typedef u_int32_t DWORD;\n\ntypedef struct BITMAPFILEHEADER  \n{   \n	WORD bfType; //数据地址为 0 - "BM"  \n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \n	WORD bfReserved1;   //DA 6 - 文件保留字 0\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\n}BITMAPFILEHEADER;\n\ntypedef struct BITMAPINFOHEADER  \n{   \n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\n	DWORD biWidth;   //DA 18\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\n	DWORD biXPelsPerMeter;   //DA 38\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\n	DWORD biClrUsed;   //DA 46 颜色变址数\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \n}BITMAPINFODEADER; \n\ntypedef struct tagRGBQUAD{\n	BYTE rgbBlue;\n	BYTE rgbGreen;\n	BYTE rgbRed;\n	BYTE rgbReserved;\n}RGBQUAD;\n\nclass bmpreader{\npublic:\n	BITMAPFILEHEADER head;\n	BITMAPINFODEADER info;\n	RGBQUAD colors;\n	int picH,picW,csize;\n	int Bnum;\n	BYTE *PicS;\n	bmpreader(char *picaddr);\n	void showRgbtag(RGBQUAD &colors);\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\n};\n\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\n		cout<<"Green:"<<colors.rgbGreen<<endl;\n		cout<<"Red:"<<colors.rgbRed<<endl;\n}\n\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \n    cout<<"位图文件头:"<<endl;    \n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \n}    \n                                                          \nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \n    cout<<"位图信息头:"<<endl;    \n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \n}\n\nbmpreader::bmpreader(char *picaddr){\n	FILE *fp = fopen(picaddr, "rb");  	\n	int palesize = 0;\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \n	switch(info.biBitCount){\n	    case 1:\n		palesize = 2;\n		break;\n	    case 4:\n		palesize = 16;\n		break;\n	    case 8:\n		palesize = 256;\n		break;\n	}\n	if(palesize){\n	    	cout<<"存在RGBQUAD.."<<endl;\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\n	}else{\n		cout<<"不存在RGBQUAD.."<<endl;\n	}\n	showBmpHead(head);  \n	showBmpInforHead(info);  \n	//showRgbtag(colors);\n	int PicData = info.biSizeImage;\n	if(!palesize){\n		int tempsize = info.biBitCount/8;\n		tempsize = tempsize*64;\n		if(PicData%tempsize){\n			cout<<PicData<<"----"<<tempsize<<endl;\n			PicData = PicData + (tempsize-PicData%tempsize);\n			cout<<PicData<<"----"<<tempsize<<endl;\n		}\n		Bnum = PicData/tempsize;\n	}else{\n		if(PicData%64){\n			PicData = PicData + PicData%64;\n			cout<<PicData<<"---"<<"64"<<endl;\n		}	\n		Bnum = PicData/64;\n	}\n        //PicS = (char*)malloc(PicData);\n	csize = PicData;\n	picH = info.biHeight;\n	picW = info.biWidth;\n	PicS = (unsigned char*)new unsigned char[PicData];\n	memset(PicS,0,PicData);\n	fread(PicS,1,info.biSizeImage,fp);\n	if(feof(fp) == 0)\n	    cout<<"All in.."<<endl;\n	fclose(fp);  \n}\n\n\n/*void Xprod(char *k,float *pk);//根据输入的序列产生最早的x0\nvoid NKProd(float *pk,float *nk,int times);//初始迭代times次，消除初始影响\nfloat f(float xi,float x);//局部混沌函数\nvoid RLProd(float *pk,float *nk,char *RL);//正常迭代，每次产生64字节随机序列\nvoid RLSplit(float *nk,char *RL,int i,int j);//取位函数*/\n</pre>\nrepic.h\n<pre lang="c" colla="-">\n</re', 'pichandle&repic for last', '', 'inherit', 'open', 'open', '', '108-revision', '', '', '2013-05-06 06:31:09', '2013-05-06 06:31:09', '', 108, 'http://codeseeking.sinaapp.com/?p=109', 0, 'revision', '', 0),
(110, 1, '2013-05-07 01:25:04', '2013-05-07 01:25:04', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\r\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\r\n\r\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\r\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\r\n\r\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\r\n $ cp id_rsa* key_backup\r\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"</pre>这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\r\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>然后，在登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。\r\n5.test,输入<pre lang="shell" colla="+">ssh -T git@github.com</pre>，如果提示hi，what what what 就说明设置成功了。如果是Permission denied (publickey). 那就是密钥对的事，根据github官网上的Q&A，首先检查下是否存在～/.ssh 然后考虑是不是复制时出的问题，vim的设置会导致从vim中复制出来的含有换行符等，最后，也是我的问题所在是公钥正确的设置了，但是自己机器的私钥没有设置，<pre lang="shell" colla="+">$ ssh-add -l</pre>如果显示The agent has no identities.则说明没有私钥，你说官网也是，光说去看看，也没说没有怎么办，不过稍微想想，之前的xxx & xxx.pub就不难知道，<pre lang="shell" colla="+">$ ssh-add xxx</pre>将私钥添加进去，再-l的时候就会显示了，这个问题在你调整公钥私钥文件位置的时候也会出现，所以出现Permission denied (publickey).尝试上述。\r\n这样，在提示登录成功的时候就可以准备同步你和github仓库了！\r\n\r\nps：貌似git还得设置下用户信息，官方步骤有，那就设置下吧<pre lang="shell" colla="+">$ git config --global user.name "defnngj"//给自己起个用户名\r\n$ git config --global user.email  "defnngj@gmail.com"//填写自己的邮箱</pre>由于我找不到所谓的api token所以就设置了这两句，够用了。\r\n\r\nThen,let''s play with it now:\r\nif you create a new project , how can you post it to github?\r\n<pre lang="shell" colla="+">\r\n假设你创建好了一个项目，并切换到项目的根目录下面：\r\n$ git status   //查看当前项目下所有文的状态，如果第一次，你会发现都红颜色的，因为它还没有交给git/github管理。\r\n$ git add .   //（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。\r\nPs:git的强大之处就是有一个本地仓库的概念，在没有网络的情况下可以先将更新的内容提交到本地仓库。\r\n$ git commit –m”new natter ”  //对你更新或修改了哪些内容做一个描述。\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//如果你是第一次提交项目，这一句非常重要，这是你本地的当前的项目与远程的哪个仓库建立连接。\r\nPs: origin可以改为别人的名字，但是在你下一次push（提交）时，也要用你修改之后的名字。\r\n$ git remote -v  //查看你当前项目远程连接的是哪个仓库地址。\r\n$ git push -u origin master  //将本地的项目提交到远程仓库中。\r\n</pre>\r\nif you get home,don''t you want to get the project from the github?\r\n<pre lang="shell" colla="+">\r\n如果你是第一次想把github上面的项目克隆到本地或者要克隆别人的项目到地。\r\n$ git clone git@github.com:defnngj/hibernate-demo.git  //在git下面切换到想存放此项目的文件目录下，运行这条命令就可以将项目克隆下来。\r\n\r\n假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？\r\n$ git fetch origin    //取得远程更新，这里可以看做是准备要取了\r\n$ git merge origin/master  //把更新的内容合并到本地分支/master\r\n</pre>\r\nif you delete some files,how can you update to github?\r\n<pre lang="shell" colla="+">\r\n假如远程仓库中已经存了aaa这个文件，我fetch了下来，并删除了aaa这个文件，想再push上到远程仓库中，并使远程仓库中的项目被新的修改覆盖（也是是远程仓库中的aaa也被删除）\r\n$ git status   //可以看到我们删除的哪些文件\r\n$ git add .   //删除之后的文件提交git管理。\r\n$ git rm   src/com/hzh/hibernate/dao/aaa.java    //移除我们删除的那个文件，不然git不允许我们往远程仓库提交。\r\nPs: 如果你想删除的是某个目录（java包），这里想移除整个目录的内容。\r\n$ git rm  src/com/hzh/hibernate/bbb/ -r   // -r 会把bbb/目录下的所有内容一次性移动。\r\n</pre>\r\nif 远程创建了一个新仓库，本地创建了一个新项目，如何使新的项目与仓库对应起来？\r\n<pre lang="shell" colla="+">\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//还是这个命令，在你push项目之前加上这一句就OK了。\r\ngit@github.com:defnngj/hibernate-demo.git 就是你常见的新仓库的地址啊。git切换到新项目下，在push之前，加上这一句，我们创建的新仓库就与新项目建立了连接。\r\n</pre>', 'linux github 设置', '', 'publish', 'open', 'open', '', 'linux-github-%e8%ae%be%e7%bd%ae', '', '', '2014-05-20 01:52:08', '2014-05-20 01:52:08', '', 0, 'http://codeseeking.sinaapp.com/?p=110', 0, 'post', '', 0),
(111, 1, '2013-05-07 01:15:53', '2013-05-07 01:15:53', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\n\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\n\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\n $ cp id_rsa* key_backup\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>,ran', 'linux github 设置', '', 'inherit', 'open', 'open', '', '110-revision', '', '', '2013-05-07 01:15:53', '2013-05-07 01:15:53', '', 110, 'http://codeseeking.sinaapp.com/?p=111', 0, 'revision', '', 0),
(112, 1, '2013-05-07 01:16:25', '2013-05-07 01:16:25', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\r\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\r\n\r\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\r\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\r\n\r\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\r\n $ cp id_rsa* key_backup\r\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\r\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>然后，在登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。', 'linux github 设置', '', 'inherit', 'open', 'open', '', '110-revision-2', '', '', '2013-05-07 01:16:25', '2013-05-07 01:16:25', '', 110, 'http://codeseeking.sinaapp.com/?p=112', 0, 'revision', '', 0),
(113, 1, '2013-05-07 01:39:07', '2013-05-07 01:39:07', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\n\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\n\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\n $ cp id_rsa* key_backup\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"</pre>这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>然后，在登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。\n5.test,输入<pre lang="shell" colla="+">ssh git@github.com</pre>，如果提示hi，what what what 就说明设置成功了。如果是Permission denied (publickey). 那就是密钥对的事，根据github官网上的Q&A，首先检查下是否存在～/.ssh 然后考虑是不是复制时出的问题，vim的设置会导致从vim中复制出来的含有换行符等，最后，也是我的问题所在是公钥正确的设置了，但是自己机器的私钥没有设置，<pre lang="shell" colla="+">$ ssh-add -l</pre>如果显示The agent has no identities.则说明没有私钥，你说官网也是，光说去看看，也没说没有怎么办，不过稍微想想，之前的xxx & xxx.pub就不难知道，<pre lang="shell" colla="+">$ ssh-add xxx</pre>将私钥添加进去，再-l的时候就会显示了，这个问题在你调整公钥私钥文件位置的时候也会出现，所以出现Permission denied (publickey).尝试上述。\n这样，在提示登录成功的时候就可以准备同步你和github仓库了！\n\nps：貌似git还得设置下用户信息，官方步骤有，那就设置下吧<pre lang="shell" colla="+">$ git config --global user.name "defnngj"//给自己起个用户名\n$ git config --global user.email  "defnngj@gmail.com"//填写自己的邮箱</pre>由于我找不到所谓的api token所以就设置了这两句，够用了。\n\nThen,let''s play with it now:\nif you create a new project , how can you post it to github?\n<pre lang="shell" colla=“+”>\n假设你创建好了一个项目，并切换到项目的根目录下面：\n$ git status   //查看当前项目下所有文的状态，如果第一次，你会发现都红颜色的，因为它还没有交给git/github管理。\n$ git add .   //（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。\nPs:git的强大之处就是有一个本地仓库的概念，在没有网络的情况下可以先将更新的内容提交到本地仓库。\n$ git commit –m”new natter ”  //对你更新或修改了哪些内容做一个描述。\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\n//如果你是第一次提交项目，这一句非常重要，这是你本地的当前的项目与远程的哪个仓库建立连接。\nPs: origin可以改为别人的名字，但是在你下一次push（提交）时，也要用你修改之后的名字。\n$ git remote -v  //查看你当前项目远程连接的是哪个仓库地址。\n$ git push -u origin master  //将本地的项目提交到远程仓库中。\n</pre>\nif you get home,don''t you want to get the project from the github?\n<pre lang="shell" colla="+">\n如果你是第一次想把github上面的项目克隆到本地或者要克隆别人的项目到地。\n$ git clone git@github.com:defnngj/hibernate-demo.git  //在git下面切换到想存放此项目的文件目录下，运行这条命令就可以将项目克隆下来。\n\n假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？\n$ git fetch origin    //取得远程更新，这里可以看做是准备要取了\n$ git merge origin/master  //把更新的内容合并到本地分支/master\n</pre>\nif you delete some files,how can you update to github?\n<pre lang="shell" colla="+">\n假如远程仓库中已经存了aaa这个文件，我fetch了下来，并删除了aaa这个文件，想再push上到远程仓库中，并使远程仓库中的项目被新的修改覆盖（也是是远程仓库中的aaa也被删除）\n$ git status   //可以看到我们删除的哪些文件\n$ git add .   //删除之后的文件提交git管理。\n$ git rm   src/com/hzh/hibernate/dao/aaa.java    //移除我们删除的那个文件，不然git不允许我们往远程仓库提交。\nPs: 如果你想删除的是某个目录（java包），这里想移除整个目录的内容。\n$ git rm  src/com/hzh/hibernate/bbb/ -r   // -r 会把bbb/目录下的所有内容一次性移动。\n</pre>\nif 远程创建了一个新仓库，本地创建了一个新项目，如何使新的项目与仓库对应起来？\n<pre lang="shell" colla="+">\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\n\n//还是这个命令，在你push项目之前加上这一句就OK了。\n\ngit@github.com:defnngj/hibernate-demo.git 就是你常见的新仓库的地址啊。git切换到新项目下，在push之前，加上这一句，我们创建的新仓库就与新项目建立了连接。', 'linux github 设置', '', 'inherit', 'open', 'open', '', '110-autosave', '', '', '2013-05-07 01:39:07', '2013-05-07 01:39:07', '', 110, '', 0, 'revision', '', 0),
(114, 1, '2013-05-07 01:25:04', '2013-05-07 01:25:04', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\r\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\r\n\r\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\r\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\r\n\r\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\r\n $ cp id_rsa* key_backup\r\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"</pre>这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\r\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>然后，在登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。\r\n5.test,输入<pre lang="shell" colla="+">ssh git@github.com</pre>，如果提示hi，what what what 就说明设置成功了。如果是Permission denied (publickey). 那就是密钥对的事，根据github官网上的Q&A，首先检查下是否存在～/.ssh 然后考虑是不是复制时出的问题，vim的设置会导致从vim中复制出来的含有换行符等，最后，也是我的问题所在是公钥正确的设置了，但是自己机器的私钥没有设置，<pre lang="shell" colla="+">$ ssh-add -l</pre>如果显示The agent has no identities.则说明没有私钥，你说官网也是，光说去看看，也没说没有怎么办，不过稍微想想，之前的xxx & xxx.pub就不难知道，<pre lang="shell" colla="+">$ ssh-add xxx</pre>将私钥添加进去，再-l的时候就会显示了，这个问题在你调整公钥私钥文件位置的时候也会出现，所以出现Permission denied (publickey).尝试上述。\r\n这样，在提示登录成功的时候就可以准备同步你和github仓库了！', 'linux github 设置', '', 'inherit', 'open', 'open', '', '110-revision-3', '', '', '2013-05-07 01:25:04', '2013-05-07 01:25:04', '', 110, 'http://codeseeking.sinaapp.com/?p=114', 0, 'revision', '', 0),
(115, 1, '2013-05-07 01:39:27', '2013-05-07 01:39:27', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\r\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\r\n\r\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\r\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\r\n\r\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\r\n $ cp id_rsa* key_backup\r\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"</pre>这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\r\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>然后，在登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。\r\n5.test,输入<pre lang="shell" colla="+">ssh git@github.com</pre>，如果提示hi，what what what 就说明设置成功了。如果是Permission denied (publickey). 那就是密钥对的事，根据github官网上的Q&A，首先检查下是否存在～/.ssh 然后考虑是不是复制时出的问题，vim的设置会导致从vim中复制出来的含有换行符等，最后，也是我的问题所在是公钥正确的设置了，但是自己机器的私钥没有设置，<pre lang="shell" colla="+">$ ssh-add -l</pre>如果显示The agent has no identities.则说明没有私钥，你说官网也是，光说去看看，也没说没有怎么办，不过稍微想想，之前的xxx & xxx.pub就不难知道，<pre lang="shell" colla="+">$ ssh-add xxx</pre>将私钥添加进去，再-l的时候就会显示了，这个问题在你调整公钥私钥文件位置的时候也会出现，所以出现Permission denied (publickey).尝试上述。\r\n这样，在提示登录成功的时候就可以准备同步你和github仓库了！\r\n\r\nps：貌似git还得设置下用户信息，官方步骤有，那就设置下吧<pre lang="shell" colla="+">$ git config --global user.name "defnngj"//给自己起个用户名\r\n$ git config --global user.email  "defnngj@gmail.com"//填写自己的邮箱</pre>由于我找不到所谓的api token所以就设置了这两句，够用了。\r\n\r\nThen,let''s play with it now:\r\nif you create a new project , how can you post it to github?\r\n<pre lang="shell" colla=“+”>\r\n假设你创建好了一个项目，并切换到项目的根目录下面：\r\n$ git status   //查看当前项目下所有文的状态，如果第一次，你会发现都红颜色的，因为它还没有交给git/github管理。\r\n$ git add .   //（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。\r\nPs:git的强大之处就是有一个本地仓库的概念，在没有网络的情况下可以先将更新的内容提交到本地仓库。\r\n$ git commit –m”new natter ”  //对你更新或修改了哪些内容做一个描述。\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//如果你是第一次提交项目，这一句非常重要，这是你本地的当前的项目与远程的哪个仓库建立连接。\r\nPs: origin可以改为别人的名字，但是在你下一次push（提交）时，也要用你修改之后的名字。\r\n$ git remote -v  //查看你当前项目远程连接的是哪个仓库地址。\r\n$ git push -u origin master  //将本地的项目提交到远程仓库中。\r\n</pre>\r\nif you get home,don''t you want to get the project from the github?\r\n<pre lang="shell" colla="+">\r\n如果你是第一次想把github上面的项目克隆到本地或者要克隆别人的项目到地。\r\n$ git clone git@github.com:defnngj/hibernate-demo.git  //在git下面切换到想存放此项目的文件目录下，运行这条命令就可以将项目克隆下来。\r\n\r\n假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？\r\n$ git fetch origin    //取得远程更新，这里可以看做是准备要取了\r\n$ git merge origin/master  //把更新的内容合并到本地分支/master\r\n</pre>\r\nif you delete some files,how can you update to github?\r\n<pre lang="shell" colla="+">\r\n假如远程仓库中已经存了aaa这个文件，我fetch了下来，并删除了aaa这个文件，想再push上到远程仓库中，并使远程仓库中的项目被新的修改覆盖（也是是远程仓库中的aaa也被删除）\r\n$ git status   //可以看到我们删除的哪些文件\r\n$ git add .   //删除之后的文件提交git管理。\r\n$ git rm   src/com/hzh/hibernate/dao/aaa.java    //移除我们删除的那个文件，不然git不允许我们往远程仓库提交。\r\nPs: 如果你想删除的是某个目录（java包），这里想移除整个目录的内容。\r\n$ git rm  src/com/hzh/hibernate/bbb/ -r   // -r 会把bbb/目录下的所有内容一次性移动。\r\n</pre>\r\nif 远程创建了一个新仓库，本地创建了一个新项目，如何使新的项目与仓库对应起来？\r\n<pre lang="shell" colla="+">\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//还是这个命令，在你push项目之前加上这一句就OK了。\r\ngit@github.com:defnngj/hibernate-demo.git 就是你常见的新仓库的地址啊。git切换到新项目下，在push之前，加上这一句，我们创建的新仓库就与新项目建立了连接。\r\n</pre>', 'linux github 设置', '', 'inherit', 'open', 'open', '', '110-revision-4', '', '', '2013-05-07 01:39:27', '2013-05-07 01:39:27', '', 110, 'http://codeseeking.sinaapp.com/?p=115', 0, 'revision', '', 0),
(117, 1, '2013-05-09 16:05:04', '2013-05-09 16:05:04', 'http://eigen.tuxfamily.org/', 'matrices, vectors, numerical solvers, and related algorithms', '', 'inherit', 'open', 'open', '', '116-revision', '', '', '2013-05-09 16:05:04', '2013-05-09 16:05:04', '', 116, 'http://codeseeking.sinaapp.com/?p=117', 0, 'revision', '', 0),
(118, 1, '2013-05-10 19:16:35', '2013-05-10 19:16:35', '<pre lang="c" colla="-">\r\n#include "picread.h"\r\n\r\nvoid Xprod(BYTE k[16],double pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\ndouble f(double x){\r\n	double y;\r\n	//y = 8*x*x*x*x-8*x*x+1;\r\n	y = 8*pow(x,4)-8*pow(x,2)+1;\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(double pk[16],double nk[16],int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RtoY(BYTE *BK,double *YUV,int eachtime){\r\n    	int i = 0;\r\n	while(i<eachtime){\r\n		BYTE r,g,b;\r\n		r = BK[i+0];\r\n		g = BK[i+1];\r\n		b = BK[i+2];\r\n		YUV[i+0] = (double)((r*0.256789 + g*0.504129 + b*0.097906) + 16);\r\n		YUV[i+1] = (double)((r*(-0.148223) + g*(-0.290992) + b*0.439215) + 128);\r\n		YUV[i+2] = (double)((r*0.439215 + g*(-0.367789) + b*(-0.071426)) + 128);\r\n		i = i+3;	\r\n	}\r\n}\r\n\r\nvoid rlProd(double pk[16],double nk[16],double *LR,int eachtime){\r\n	for(int i=0;i<eachtime/16;i++){\r\n		for(int j=0;j<16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]); \r\n		}\r\n		for(int k=0;k<16;k++){\r\n			LR[16*i+k] = nk[k]/2;\r\n			if((nk[k]/2 <-0.5)|(nk[k]/2)>0.5)\r\n			    cout<<"有超范围的映射"<<endl;\r\n			pk[k] = nk[k];\r\n		}\r\n	}\r\n}\r\n\r\nvoid LProd(double *rla,double *L){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(i==0){//这里老是为0\r\n					L[64*k+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rla[64*k+j])/16);\r\n				}else{\r\n					L[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rla[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\nvoid RProd(double *rlb,double *R){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(j==0){\r\n					R[64*k+8*i+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rlb[64*k+j])/16);\r\n				}else{\r\n					R[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rlb[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	double pk[16];//迭代前的各个盒子值\r\n	double nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d Num = %d\\n",eachtime,bnum);\r\n	//BYTE RL[eachtime];//每次的随机序列\r\n	//RL 得变成double的了。。方便运算么\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,500);\r\n	//然后产生随机序列并映射到（-0.5，0.5）直接利用混沌盒子的值！？yes!!(8x4-8x2+1)~(-1,1)的，直接处理出来就好了\r\n	BYTE BK[eachtime];\r\n	double YUV[eachtime];\r\n	double rla[eachtime];\r\n	double rlb[eachtime];\r\n	double L[eachtime];\r\n	double R[eachtime];\r\n	MatrixXd Lym(8,8);\r\n	MatrixXd Rym(8,8);\r\n	MatrixXd Lum(8,8);\r\n	MatrixXd Rum(8,8);\r\n	MatrixXd Lvm(8,8);\r\n	MatrixXd Rvm(8,8);\r\n	MatrixXd Xym(8,8);\r\n	MatrixXd Xum(8,8);\r\n	MatrixXd Xvm(8,8);\r\n	MatrixXd Yym(8,8);\r\n	MatrixXd Yum(8,8);\r\n	MatrixXd Yvm(8,8);\r\n	\r\n	for(int k = 0 ; k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		//RGB to YUV\r\n		RtoY(BK,YUV,eachtime);\r\n		//一次产生a b 以计算出L & R\r\n		rlProd(pk,nk,rla,eachtime);\r\n		rlProd(pk,nk,rlb,eachtime);\r\n		//L&R \r\n		LProd(rla,L);\r\n		RProd(rlb,R);\r\n		for(int i=0;i<8;i++){\r\n		    for(int j=0;j<8;j++){\r\n		    	Xym(i,j) = YUV[3*(8*i+j)+0];\r\n			Xum(i,j) = YUV[3*(8*i+j)+1];\r\n			Xvm(i,j) = YUV[3*(8*i+j)+2];\r\n			Lym(i,j) = L[3*(8*i+j)+0];\r\n			Lum(i,j) = L[3*(8*i+j)+1];\r\n			Lvm(i,j) = L[3*(8*i+j)+2];\r\n			Rym(i,j) = R[3*(8*i+j)+0];\r\n			Rum(i,j) = R[3*(8*i+j)+1];\r\n			Rvm(i,j) = R[3*(8*i+j)+2];\r\n\r\n		    }\r\n		}//得到YUV三个分量的X矩阵,3个L&R\r\n		Yym = Lym*Xym*Rym;\r\n		Yum = Lum*Xum*Rum;\r\n		Yvm = Lvm*Xvm*Rvm;\r\n		/*if(k%100 == 0){\r\n		    	cout<<Lym<<endl<<Lum<<endl<<Lvm<<endl<<Rym<<endl<<Rum<<endl<<Rvm<<endl;\r\n			cout<<k<<"::"<<endl<<"yym:"<<endl<<Yym<<endl<<"yum:"<<endl<<Yum<<endl<<"yvm:"<<endl<<Yvm<<endl;\r\n		}*/\r\n\r\n	}\r\n	\r\n	return 0;  \r\n}\r\n</pre>', '非均匀dct尝试', '', 'publish', 'open', 'open', '', '%e9%9d%9e%e5%9d%87%e5%8c%80dct%e5%b0%9d%e8%af%95', '', '', '2014-05-21 08:22:28', '2014-05-21 08:22:28', '', 0, 'http://codeseeking.sinaapp.com/?p=118', 0, 'post', '', 0),
(119, 1, '2013-05-10 19:15:26', '2013-05-10 19:15:26', '', '非均匀dct尝试', '', 'inherit', 'open', 'open', '', '118-revision', '', '', '2013-05-10 19:15:26', '2013-05-10 19:15:26', '', 118, 'http://codeseeking.sinaapp.com/?p=119', 0, 'revision', '', 0),
(120, 1, '2013-05-10 19:16:35', '2013-05-10 19:16:35', '<pre lang="c++" colla=“-”>\r\n#include "picread.h"\r\n\r\nvoid Xprod(BYTE k[16],double pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\ndouble f(double x){\r\n	double y;\r\n	//y = 8*x*x*x*x-8*x*x+1;\r\n	y = 8*pow(x,4)-8*pow(x,2)+1;\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(double pk[16],double nk[16],int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RtoY(BYTE *BK,double *YUV,int eachtime){\r\n    	int i = 0;\r\n	while(i<eachtime){\r\n		BYTE r,g,b;\r\n		r = BK[i+0];\r\n		g = BK[i+1];\r\n		b = BK[i+2];\r\n		YUV[i+0] = (double)((r*0.256789 + g*0.504129 + b*0.097906) + 16);\r\n		YUV[i+1] = (double)((r*(-0.148223) + g*(-0.290992) + b*0.439215) + 128);\r\n		YUV[i+2] = (double)((r*0.439215 + g*(-0.367789) + b*(-0.071426)) + 128);\r\n		i = i+3;	\r\n	}\r\n}\r\n\r\nvoid rlProd(double pk[16],double nk[16],double *LR,int eachtime){\r\n	for(int i=0;i<eachtime/16;i++){\r\n		for(int j=0;j<16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]); \r\n		}\r\n		for(int k=0;k<16;k++){\r\n			LR[16*i+k] = nk[k]/2;\r\n			if((nk[k]/2 <-0.5)|(nk[k]/2)>0.5)\r\n			    cout<<"有超范围的映射"<<endl;\r\n			pk[k] = nk[k];\r\n		}\r\n	}\r\n}\r\n\r\nvoid LProd(double *rla,double *L){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(i==0){//这里老是为0\r\n					L[64*k+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rla[64*k+j])/16);\r\n				}else{\r\n					L[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rla[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\nvoid RProd(double *rlb,double *R){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(j==0){\r\n					R[64*k+8*i+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rlb[64*k+j])/16);\r\n				}else{\r\n					R[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rlb[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	double pk[16];//迭代前的各个盒子值\r\n	double nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d Num = %d\\n",eachtime,bnum);\r\n	//BYTE RL[eachtime];//每次的随机序列\r\n	//RL 得变成double的了。。方便运算么\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,500);\r\n	//然后产生随机序列并映射到（-0.5，0.5）直接利用混沌盒子的值！？yes!!(8x4-8x2+1)~(-1,1)的，直接处理出来就好了\r\n	BYTE BK[eachtime];\r\n	double YUV[eachtime];\r\n	double rla[eachtime];\r\n	double rlb[eachtime];\r\n	double L[eachtime];\r\n	double R[eachtime];\r\n	MatrixXd Lym(8,8);\r\n	MatrixXd Rym(8,8);\r\n	MatrixXd Lum(8,8);\r\n	MatrixXd Rum(8,8);\r\n	MatrixXd Lvm(8,8);\r\n	MatrixXd Rvm(8,8);\r\n	MatrixXd Xym(8,8);\r\n	MatrixXd Xum(8,8);\r\n	MatrixXd Xvm(8,8);\r\n	MatrixXd Yym(8,8);\r\n	MatrixXd Yum(8,8);\r\n	MatrixXd Yvm(8,8);\r\n	\r\n	for(int k = 0 ; k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		//RGB to YUV\r\n		RtoY(BK,YUV,eachtime);\r\n		//一次产生a b 以计算出L & R\r\n		rlProd(pk,nk,rla,eachtime);\r\n		rlProd(pk,nk,rlb,eachtime);\r\n		//L&R \r\n		LProd(rla,L);\r\n		RProd(rlb,R);\r\n		for(int i=0;i<8;i++){\r\n		    for(int j=0;j<8;j++){\r\n		    	Xym(i,j) = YUV[3*(8*i+j)+0];\r\n			Xum(i,j) = YUV[3*(8*i+j)+1];\r\n			Xvm(i,j) = YUV[3*(8*i+j)+2];\r\n			Lym(i,j) = L[3*(8*i+j)+0];\r\n			Lum(i,j) = L[3*(8*i+j)+1];\r\n			Lvm(i,j) = L[3*(8*i+j)+2];\r\n			Rym(i,j) = R[3*(8*i+j)+0];\r\n			Rum(i,j) = R[3*(8*i+j)+1];\r\n			Rvm(i,j) = R[3*(8*i+j)+2];\r\n\r\n		    }\r\n		}//得到YUV三个分量的X矩阵,3个L&R\r\n		Yym = Lym*Xym*Rym;\r\n		Yum = Lum*Xum*Rum;\r\n		Yvm = Lvm*Xvm*Rvm;\r\n		/*if(k%100 == 0){\r\n		    	cout<<Lym<<endl<<Lum<<endl<<Lvm<<endl<<Rym<<endl<<Rum<<endl<<Rvm<<endl;\r\n			cout<<k<<"::"<<endl<<"yym:"<<endl<<Yym<<endl<<"yum:"<<endl<<Yum<<endl<<"yvm:"<<endl<<Yvm<<endl;\r\n		}*/\r\n\r\n	}\r\n	\r\n	return 0;  \r\n}\r\n</pre>', '非均匀dct尝试', '', 'inherit', 'open', 'open', '', '118-revision-2', '', '', '2013-05-10 19:16:35', '2013-05-10 19:16:35', '', 118, 'http://codeseeking.sinaapp.com/?p=120', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(121, 1, '2013-05-10 19:17:04', '2013-05-10 19:17:04', '<pre lang="c++" colla="-">\r\n#include "picread.h"\r\n\r\nvoid Xprod(BYTE k[16],double pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\ndouble f(double x){\r\n	double y;\r\n	//y = 8*x*x*x*x-8*x*x+1;\r\n	y = 8*pow(x,4)-8*pow(x,2)+1;\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(double pk[16],double nk[16],int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RtoY(BYTE *BK,double *YUV,int eachtime){\r\n    	int i = 0;\r\n	while(i<eachtime){\r\n		BYTE r,g,b;\r\n		r = BK[i+0];\r\n		g = BK[i+1];\r\n		b = BK[i+2];\r\n		YUV[i+0] = (double)((r*0.256789 + g*0.504129 + b*0.097906) + 16);\r\n		YUV[i+1] = (double)((r*(-0.148223) + g*(-0.290992) + b*0.439215) + 128);\r\n		YUV[i+2] = (double)((r*0.439215 + g*(-0.367789) + b*(-0.071426)) + 128);\r\n		i = i+3;	\r\n	}\r\n}\r\n\r\nvoid rlProd(double pk[16],double nk[16],double *LR,int eachtime){\r\n	for(int i=0;i<eachtime/16;i++){\r\n		for(int j=0;j<16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]); \r\n		}\r\n		for(int k=0;k<16;k++){\r\n			LR[16*i+k] = nk[k]/2;\r\n			if((nk[k]/2 <-0.5)|(nk[k]/2)>0.5)\r\n			    cout<<"有超范围的映射"<<endl;\r\n			pk[k] = nk[k];\r\n		}\r\n	}\r\n}\r\n\r\nvoid LProd(double *rla,double *L){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(i==0){//这里老是为0\r\n					L[64*k+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rla[64*k+j])/16);\r\n				}else{\r\n					L[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rla[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\nvoid RProd(double *rlb,double *R){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(j==0){\r\n					R[64*k+8*i+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rlb[64*k+j])/16);\r\n				}else{\r\n					R[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rlb[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	double pk[16];//迭代前的各个盒子值\r\n	double nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d Num = %d\\n",eachtime,bnum);\r\n	//BYTE RL[eachtime];//每次的随机序列\r\n	//RL 得变成double的了。。方便运算么\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,500);\r\n	//然后产生随机序列并映射到（-0.5，0.5）直接利用混沌盒子的值！？yes!!(8x4-8x2+1)~(-1,1)的，直接处理出来就好了\r\n	BYTE BK[eachtime];\r\n	double YUV[eachtime];\r\n	double rla[eachtime];\r\n	double rlb[eachtime];\r\n	double L[eachtime];\r\n	double R[eachtime];\r\n	MatrixXd Lym(8,8);\r\n	MatrixXd Rym(8,8);\r\n	MatrixXd Lum(8,8);\r\n	MatrixXd Rum(8,8);\r\n	MatrixXd Lvm(8,8);\r\n	MatrixXd Rvm(8,8);\r\n	MatrixXd Xym(8,8);\r\n	MatrixXd Xum(8,8);\r\n	MatrixXd Xvm(8,8);\r\n	MatrixXd Yym(8,8);\r\n	MatrixXd Yum(8,8);\r\n	MatrixXd Yvm(8,8);\r\n	\r\n	for(int k = 0 ; k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		//RGB to YUV\r\n		RtoY(BK,YUV,eachtime);\r\n		//一次产生a b 以计算出L & R\r\n		rlProd(pk,nk,rla,eachtime);\r\n		rlProd(pk,nk,rlb,eachtime);\r\n		//L&R \r\n		LProd(rla,L);\r\n		RProd(rlb,R);\r\n		for(int i=0;i<8;i++){\r\n		    for(int j=0;j<8;j++){\r\n		    	Xym(i,j) = YUV[3*(8*i+j)+0];\r\n			Xum(i,j) = YUV[3*(8*i+j)+1];\r\n			Xvm(i,j) = YUV[3*(8*i+j)+2];\r\n			Lym(i,j) = L[3*(8*i+j)+0];\r\n			Lum(i,j) = L[3*(8*i+j)+1];\r\n			Lvm(i,j) = L[3*(8*i+j)+2];\r\n			Rym(i,j) = R[3*(8*i+j)+0];\r\n			Rum(i,j) = R[3*(8*i+j)+1];\r\n			Rvm(i,j) = R[3*(8*i+j)+2];\r\n\r\n		    }\r\n		}//得到YUV三个分量的X矩阵,3个L&R\r\n		Yym = Lym*Xym*Rym;\r\n		Yum = Lum*Xum*Rum;\r\n		Yvm = Lvm*Xvm*Rvm;\r\n		/*if(k%100 == 0){\r\n		    	cout<<Lym<<endl<<Lum<<endl<<Lvm<<endl<<Rym<<endl<<Rum<<endl<<Rvm<<endl;\r\n			cout<<k<<"::"<<endl<<"yym:"<<endl<<Yym<<endl<<"yum:"<<endl<<Yum<<endl<<"yvm:"<<endl<<Yvm<<endl;\r\n		}*/\r\n\r\n	}\r\n	\r\n	return 0;  \r\n}\r\n</pre>', '非均匀dct尝试', '', 'inherit', 'open', 'open', '', '118-revision-3', '', '', '2013-05-10 19:17:04', '2013-05-10 19:17:04', '', 118, 'http://codeseeking.sinaapp.com/?p=121', 0, 'revision', '', 0),
(123, 1, '2013-05-23 01:06:18', '2013-05-23 01:06:18', 'Encryption code:\r\n<pre lang="c" colla="-">\r\n       for(int k = 0 ; k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		//RGB to YUV\r\n		RtoY(BK,YUV,eachtime);\r\n		//一次产生a b 以计算出L & R\r\n		rlProd(pk,nk,rla,eachtime);\r\n		rlProd(pk,nk,rlb,eachtime);\r\n		//L&R \r\n		LProd(rla,L);\r\n		RProd(rlb,R);\r\n		for(int i=0;i<8;i++){\r\n		    for(int j=0;j<8;j++){\r\n			//DCT接受的数值是-128-127，所以要-128！？\r\n		    	Xym(i,j) = YUV[3*(8*i+j)+0]-128;\r\n			Xum(i,j) = YUV[3*(8*i+j)+1]-128;\r\n			Xvm(i,j) = YUV[3*(8*i+j)+2]-128;\r\n			Lym(i,j) = L[3*(8*i+j)+0];\r\n			Lum(i,j) = L[3*(8*i+j)+1];\r\n			Lvm(i,j) = L[3*(8*i+j)+2];\r\n			Rym(i,j) = R[3*(8*i+j)+0];\r\n			Rum(i,j) = R[3*(8*i+j)+1];\r\n			Rvm(i,j) = R[3*(8*i+j)+2];\r\n		    }\r\n		}//得到YUV三个分量的X矩阵,3个L&R\r\n		Yym = Lym*Xym*Rym;\r\n		Yum = Lum*Xum*Rum;\r\n		Yvm = Lvm*Xvm*Rvm;\r\n		if(k%500==0)\r\n		    cout<<Xym<<endl<<"============"<<endl;\r\n		//量化\r\n		for(int c=0;c<8;c++){\r\n			for(int d=0;d<8;d++){\r\n				Yyi(c,d) = (int)(Yym(c,d)/Lfm(c,d));\r\n				Yui(c,d) = (int)(Yum(c,d)/Cfm(c,d));\r\n				Yvi(c,d) = (int)(Yvm(c,d)/Cfm(c,d));\r\n			}\r\n		}\r\n		zsearch(Yyi,cky);\r\n		zsearch(Yui,cku);\r\n		zsearch(Yvi,ckv);\r\n		for(int i=0;i<eachtime/3;i++){\r\n			CK[i] = cky[i];\r\n			CK[64+i] = cku[i];\r\n			CK[128+i] = ckv[i];\r\n		}\r\n		for(int i=0;i<eachtime;i++){\r\n			if(CK[i]!=0){\r\n				ckb[ckn++] = CK[i];\r\n			}else{\r\n				if((i==eachtime-1)|(CK[i+1]!=0)){\r\n					if(zma==0){\r\n						ckb[ckn++] = CK[i];\r\n					}else{\r\n						ckb[ckn++] = 0x88;\r\n						ckb[ckn++] = zma+1;\r\n						zma = 0;\r\n					}\r\n				}else{\r\n					zma++;\r\n				}\r\n			}\r\n		}\r\n		\r\n	}\r\n</pre>\r\n\r\nDencryption Reader:\r\n<pre lang="c" colla="-">\r\n        int ckn=0;\r\n	BYTE zn=0;	\r\n	PicD[ckn++] = PicS[0];\r\n	for(int i=1;i<PicData;){\r\n		if(PicS[i] != 0x88){\r\n		    	PicD[ckn++] = PicS[i];\r\n			i++;\r\n		}else{\r\n			zn = PicS[i+1];\r\n			for(int j=0;j<zn;j++){\r\n				PicD[ckn+j] = 0;\r\n			}\r\n			ckn = ckn + zn;\r\n			zn = 0;\r\n			i = i + 2;\r\n		}\r\n	}\r\n</pre>\r\nDencryption :\r\n<pre lang="c" colla="-">\r\n        for(int k=0;k<bnum;k++){\r\n		memcpy(CK,pict.PicD+k*eachtime,eachtime);\r\n		for(int i=0;i<eachtime/3;i++){\r\n			cky[i] = CK[i];\r\n			cku[i] = CK[64+i];\r\n			ckv[i] = CK[128+i];\r\n		}\r\n		Yyi = rzsearch(cky);\r\n		Yui = rzsearch(cku);\r\n		Yvi = rzsearch(ckv);\r\n		for(int c=0;c<8;c++){\r\n			for(int d=0;d<8;d++){\r\n				Yym(c,d) = Yyi(c,d)*Lfm(c,d);\r\n				Yum(c,d) = Yui(c,d)*Cfm(c,d);\r\n				Yvm(c,d) = Yvi(c,d)*Cfm(c,d);\r\n			}\r\n		}\r\n		//一次产生a b 以计算出L & R\r\n		rlProd(pk,nk,rla,eachtime);\r\n		rlProd(pk,nk,rlb,eachtime);\r\n		//L&R \r\n		LProd(rla,L);\r\n		RProd(rlb,R);\r\n		for(int i=0;i<8;i++){\r\n		    for(int j=0;j<8;j++){\r\n			Lym(i,j) = L[3*(8*i+j)+0];\r\n			Lum(i,j) = L[3*(8*i+j)+1];\r\n			Lvm(i,j) = L[3*(8*i+j)+2];\r\n			Rym(i,j) = R[3*(8*i+j)+0];\r\n			Rum(i,j) = R[3*(8*i+j)+1];\r\n			Rvm(i,j) = R[3*(8*i+j)+2];\r\n		    }\r\n		}//得到3个L&R\r\n		Lyinver = Lym.transpose();\r\n		Luinver = Lum.transpose();\r\n		Lvinver = Lvm.transpose();\r\n		Ryinver = Rym.transpose();\r\n		Ruinver = Rum.transpose();\r\n		Rvinver = Rvm.transpose();\r\n		Xym = Lyinver*Yym*Ryinver;\r\n		Xum = Luinver*Yum*Ruinver;\r\n		Xvm = Lvinver*Yvm*Rvinver;\r\n		if(k%500==0)\r\n		    cout<<Xym<<endl<<"-----------"<<endl;\r\n		int td=0;	\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				td = Xym(i,j);\r\n				YUV[3*(8*i+j)+0] = td+128;\r\n				td = Xum(i,j);\r\n				YUV[3*(8*i+j)+1] = td+128;\r\n				td = Xvm(i,j);\r\n				YUV[3*(8*i+j)+2] = td+128;\r\n			}\r\n		}\r\n		YtoR(YUV,BK,eachtime);\r\n		fwrite(BK,1,eachtime,finalfp);\r\n	}\r\n</pre>', 'Ndct encryption&&Dencryption', '', 'publish', 'open', 'open', 'char7722731', 'ndct-encryptiondencryption', '', '', '2013-05-23 01:06:18', '2013-05-23 01:06:18', '', 0, 'http://codeseeking.sinaapp.com/?p=123', 0, 'post', '', 0),
(124, 1, '2013-05-23 01:05:35', '2013-05-23 01:05:35', 'Encryption code:\n<pre lang="c" colla="-">\n       for(int k = 0 ; k < bnum ; k++){\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\n		//RGB to YUV\n		RtoY(BK,YUV,eachtime);\n		//一次产生a b 以计算出L & R\n		rlProd(pk,nk,rla,eachtime);\n		rlProd(pk,nk,rlb,eachtime);\n		//L&R \n		LProd(rla,L);\n		RProd(rlb,R);\n		for(int i=0;i<8;i++){\n		    for(int j=0;j<8;j++){\n			//DCT接受的数值是-128-127，所以要-128！？\n		    	Xym(i,j) = YUV[3*(8*i+j)+0]-128;\n			Xum(i,j) = YUV[3*(8*i+j)+1]-128;\n			Xvm(i,j) = YUV[3*(8*i+j)+2]-128;\n			Lym(i,j) = L[3*(8*i+j)+0];\n			Lum(i,j) = L[3*(8*i+j)+1];\n			Lvm(i,j) = L[3*(8*i+j)+2];\n			Rym(i,j) = R[3*(8*i+j)+0];\n			Rum(i,j) = R[3*(8*i+j)+1];\n			Rvm(i,j) = R[3*(8*i+j)+2];\n		    }\n		}//得到YUV三个分量的X矩阵,3个L&R\n		Yym = Lym*Xym*Rym;\n		Yum = Lum*Xum*Rum;\n		Yvm = Lvm*Xvm*Rvm;\n		if(k%500==0)\n		    cout<<Xym<<endl<<"============"<<endl;\n		//量化\n		for(int c=0;c<8;c++){\n			for(int d=0;d<8;d++){\n				Yyi(c,d) = (int)(Yym(c,d)/Lfm(c,d));\n				Yui(c,d) = (int)(Yum(c,d)/Cfm(c,d));\n				Yvi(c,d) = (int)(Yvm(c,d)/Cfm(c,d));\n			}\n		}\n		zsearch(Yyi,cky);\n		zsearch(Yui,cku);\n		zsearch(Yvi,ckv);\n		for(int i=0;i<eachtime/3;i++){\n			CK[i] = cky[i];\n			CK[64+i] = cku[i];\n			CK[128+i] = ckv[i];\n		}\n		for(int i=0;i<eachtime;i++){\n			if(CK[i]!=0){\n				ckb[ckn++] = CK[i];\n			}else{\n				if((i==eachtime-1)|(CK[i+1]!=0)){\n					if(zma==0){\n						ckb[ckn++] = CK[i];\n					}else{\n						ckb[ckn++] = 0x88;\n						ckb[ckn++] = zma+1;\n						zma = 0;\n					}\n				}else{\n					zma++;\n				}\n			}\n		}\n		\n	}\n</pre>\n\nDencryption Reader:\n<pre lang="c" colla="-">\n        int ckn=0;\n	BYTE zn=0;	\n	PicD[ckn++] = PicS[0];\n	for(int i=1;i<PicData;){\n		if(PicS[i] != 0x88){\n		    	PicD[ckn++] = PicS[i];\n			i++;\n		}else{\n			zn = PicS[i+1];\n			for(int j=0;j<zn;j++){\n				PicD[ckn+j] = 0;\n			}\n			ckn = ckn + zn;\n			zn = 0;\n			i = i + 2;\n		}\n	}\n</pre>\nDencryption :\n<pre lang="c" colla="-">\n\n</pre>', 'Ndct encryption&&Dencryption', '', 'inherit', 'open', 'open', '', '123-revision', '', '', '2013-05-23 01:05:35', '2013-05-23 01:05:35', '', 123, '', 0, 'revision', '', 0),
(128, 1, '2013-08-18 12:01:18', '2013-08-18 12:01:18', '面对现在不用coding的阶段，自己还算是手痒痒了吧。虽然在小打小闹点Java什么的，但是难以成器。所以各种不爽吧。\r\n\r\n突然很想很想拼命地敲打键盘，貌似也成了一纸奢求。\r\n\r\n现在看着日益冷清的微博，看着或忙碌或悠闲的他们。\r\n\r\n自己也不知道现在什么什么状态了。\r\n\r\n今天一点点小插曲，让自己觉得。\r\n\r\n我那微乎其微的存在感啊。\r\n\r\n从小只拿成绩说话的自己现在连成绩的没了。\r\n\r\n呵呵。\r\n\r\n虽然我觉得之前的决定是正确的。\r\n\r\n虽然我觉得这次会准备好。\r\n\r\n但是，这个过程完全是两样的啊。\r\n\r\n论坛都说什么二战心态怎么怎么样。\r\n\r\n可是我在家的状态和学习无关。\r\n\r\n默默的活着。\r\n\r\n静静的活着。\r\n\r\n在经历失败与“傻”后，我其实从来不知道他们是怎么看待的。\r\n\r\n只有沉默。\r\n\r\n也只有沉默。\r\n\r\n对我最有杀伤力。\r\n\r\n注定继续做个好孩子吧。\r\n\r\n呵呵。\r\n\r\n生活还在继续，痛苦逃不掉，甩不开。\r\n\r\n认了。\r\n\r\n我还在挣扎。\r\n\r\n至少我挣扎了。\r\n\r\n嗯。\r\n\r\n20:00 2013/8/18\r\n\r\nchar成。', '就想 找个 地方 打会字', '', 'publish', 'open', 'open', '', '%e5%b0%b1%e6%83%b3-%e6%89%be%e4%b8%aa-%e5%9c%b0%e6%96%b9-%e6%89%93%e4%bc%9a%e5%ad%97', '', '', '2013-08-18 12:01:18', '2013-08-18 12:01:18', '', 0, 'http://codeseeking.sinaapp.com/?p=128', 0, 'post', '', 0),
(126, 1, '2013-05-25 16:55:48', '2013-05-25 16:55:48', '其实，不知道从何时开始，我动摇了。\r\n\r\n其实，不知道从何时开始，我怯弱了。\r\n\r\n&nbsp;\r\n\r\n但是，貌似这一切不能因为我的动摇怯弱而结束。\r\n\r\n曾经的话我还记得，曾经的痕迹我还留着，曾经的感觉，或许你能在别人那里得到。\r\n\r\n我没有资格再去说，回来吧，我们还能怎么怎么样。\r\n\r\n我其实挺确信你做这一切只是为了自己不后悔。\r\n\r\n直到。看了你写的东西，虐心么。是啊，可是我又能说些什么呢。\r\n\r\n&nbsp;\r\n\r\n或许一切真的是我命中注定，2012-2013，我永远都不能忘记的日子。\r\n\r\n不管是妈妈的车祸。老爹的伤病。老太太的病情。\r\n\r\n这一切我只能一直压着，压着。\r\n\r\n我怕，我的悲桑会传染给你，因为你总是那么在意我。\r\n\r\n我怕，我的无力也会让你无力。\r\n\r\n我怕，怕你因为这些而再次面对高考失利的那种绝望。\r\n\r\n&nbsp;\r\n\r\n我走，是因为我选择变了。\r\n\r\n我走，是因为我在崩溃的边缘了。\r\n\r\n我走，是因为放心你应经踏入成功了。\r\n\r\n我走，是因为那些客观的主观的原因。\r\n\r\n我走，是因为我自卑了、觉得自己不再值得了。\r\n\r\n&nbsp;\r\n\r\n或许，这才是伤害的开始吧。\r\n\r\n我不嫌你矮，但是我担心。\r\n\r\n我不是受不了你，只是受不了我妈。\r\n\r\n是我赶走了你，说着人话，干着不是人的事。\r\n\r\n&nbsp;\r\n\r\n当我知道你留下的答案。\r\n\r\n我不知道该说什么。\r\n\r\n或许我一直走下来的这条路才是让你找到幸福的路吧。\r\n\r\n或许我一直强忍着不妥协才是正确的吧。\r\n\r\n但当我看到你写的中间的那些话。\r\n\r\n我想。\r\n\r\n我想给你你本该有的一切。\r\n\r\n我想给你不一样的答案。\r\n\r\n我想。\r\n\r\n&nbsp;\r\n\r\n其实我不知道我再去做这个决定会有什么用。\r\n\r\n我不觉得我还有什么值得你去坚持。\r\n\r\n&nbsp;\r\n\r\n看天意了吧。\r\n\r\n如果我放弃放弃了。\r\n\r\n便是你做到了。\r\n\r\n如果你放弃不放弃了。\r\n\r\n便是我做到了。\r\n\r\n&nbsp;', '其实。', '', 'publish', 'open', 'open', 'woaini3344', '%e5%85%b6%e5%ae%9e%e3%80%82', '', '', '2014-05-21 08:23:22', '2014-05-21 08:23:22', '', 0, 'http://codeseeking.sinaapp.com/?p=126', 0, 'post', '', 0),
(127, 1, '2013-05-25 16:55:26', '2013-05-25 16:55:26', '其实，不知道从何时开始，我动摇了。\n\n其实，不知道从何时开始，我怯弱了。\n\n&nbsp;\n\n但是，貌似这一切不能因为我的动摇怯弱而结束。\n\n曾经的话我还记得，曾经的痕迹我还留着，曾经的感觉，或许你能在别人那里得到。\n\n我没有资格再去说，回来吧，我们还能怎么怎么样。\n\n我其实挺确信你做这一切只是为了自己不后悔。\n\n直到。看了你写的东西，虐心么。是啊，可是我又能说些什么呢。\n\n&nbsp;\n\n或许一切真的是我命中注定，2012-2013，我永远都不能忘记的日子。\n\n不管是妈妈的车祸。老爹的伤病。老太太的病情。\n\n这一切我只能一直压着，压着。\n\n我怕，我的悲桑会传染给你，因为你总是那么在意我。\n\n我怕，我的无力也会让你无力。\n\n我怕，怕你因为这些而再次面对高考失利的那种绝望。\n\n&nbsp;\n\n我走，是因为我选择变了。\n\n我走，是因为我在崩溃的边缘了。\n\n我走，是因为放心你应经踏入成功了。\n\n我走，是因为那些客观的主观的原因。\n\n我走，是因为我自卑了、觉得自己不再值得了。\n\n&nbsp;\n\n或许，这才是伤害的开始吧。\n\n我不嫌你矮，但是我担心。\n\n我不是受不了你，只是受不了我妈。\n\n是我赶走了你，说着人话，干着不是人的事。\n\n&nbsp;\n\n当我知道你留下的答案。\n\n我不知道该说什么。\n\n或许我一直走下来的这条路才是让你找到幸福的路吧。\n\n或许我一直强忍着不妥协才是正确的吧。\n\n但当我看到你写的中间的那些话。\n\n我想。\n\n我想给你你本该有的一切。\n\n我想给你不一样的答案。\n\n我想。\n\n&nbsp;\n\n其实我不知道我再去做这个决定会有什么用。\n\n我不觉得我还有什么值得你去坚持。\n\n&nbsp;\n\n看天意了吧。\n\n如果我放弃放弃了。\n\n便是你做到了。\n\n如果你放弃不放弃了。\n\n便是我做到了。\n\n&nbsp;\n\n如果你能', '其实。', '', 'inherit', 'open', 'open', '', '126-revision', '', '', '2013-05-25 16:55:26', '2013-05-25 16:55:26', '', 126, 'http://codeseeking.sinaapp.com/?p=127', 0, 'revision', '', 0),
(129, 1, '2013-08-18 12:01:06', '2013-08-18 12:01:06', '面对现在不用coding的阶段，自己还算是手痒痒了吧。虽然在小打小闹点Java什么的，但是难以成器。所以各种不爽吧。\n\n突然很想很想拼命地敲打键盘，貌似也成了一纸奢求。\n\n现在看着日益冷清的微博，看着或忙碌或悠闲的他们。\n\n自己也不知道现在什么什么状态了。\n\n今天一点点小插曲，让自己觉得。\n\n我那微乎其微的存在感啊。\n\n从小只拿成绩说话的自己现在连成绩的没了。\n\n呵呵。\n\n虽然我觉得之前的决定是正确的。\n\n虽然我觉得这次会准备好。\n\n但是，这个过程完全是两样的啊。\n\n论坛都说什么二战心态怎么怎么样。\n\n可是我在家的状态和学习无关。\n\n默默的活着。\n\n静静的活着。\n\n在经历失败与“傻”后，我其实从来不知道他们是怎么看待的。\n\n只有沉默。\n\n也只有沉默。\n\n对我最有杀伤力。\n\n注定继续做个好孩子吧。\n\n呵呵。\n\n生活还在继续，痛苦逃不掉，甩不开。\n\n认了。\n\n我还在挣扎。\n\n至少我挣扎了。\n\n嗯。\n\n20:00 2013/8/18\n\ncharc', '就想 找个 地方 打会字', '', 'inherit', 'open', 'open', '', '128-revision', '', '', '2013-08-18 12:01:06', '2013-08-18 12:01:06', '', 128, 'http://codeseeking.sinaapp.com/?p=129', 0, 'revision', '', 0),
(131, 1, '2014-01-21 03:36:21', '2014-01-21 03:36:21', '记录于研究者july github https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/01.0.md\r\n左旋转字符串，将字符串左边几位移至右边\r\n可以表示成\r\nXY - X要移动的数位，Y不移动的位\r\nX^T - X的转置\r\n所以 ((X^T)(Y^T))^T  = YX即实现转置\r\n\r\n<pre lang="c"  colla="+">\r\n\r\nvoid reverse(char *t , int from , int to){\r\n\r\n    while(from<to){\r\n\r\n         char tmp = t[from];\r\n\r\n         t[from++] = t[to];\r\n\r\n         t[to--] = tmp;\r\n\r\n   }\r\n\r\n}\r\n\r\nvoid leftshift(char *t , int n , int m ){\r\n\r\n    m %= n;\r\n\r\n   reverse(t , 0 , m-1);\r\n\r\n   reverse(t, m , n-1);\r\n\r\n   reverse(t, 0 , n-1);\r\n\r\n}\r\n\r\n</pre>', '三步反转（转置）', '', 'publish', 'open', 'open', '', '%e4%b8%89%e6%ad%a5%e5%8f%8d%e8%bd%ac%ef%bc%88%e8%bd%ac%e7%bd%ae%ef%bc%89', '', '', '2014-01-21 03:36:21', '2014-01-21 03:36:21', '', 0, 'http://codeseeking.sinaapp.com/?p=131', 0, 'post', '', 0),
(132, 1, '2014-01-21 03:32:20', '2014-01-21 03:32:20', '\n<pre lang="c"  colla="+">\n\nvoid reverse(char *t , int from , int to){\n\n    while(from<to){\n\n         char tmp = t[from];\n\n         t[from++] = t[to];\n\n         t[to--] = tmp;\n\n   }\n\n}\n\nvoid leftshift(char *t , int n , int m ){\n\n    m %= n;\n\n   reverse(t , 0 , m-1);\n\n   reverse(t, m , n-1);\n\n   reverse(t, 0 , n-1);\n\n}\n\n</pre>', '三步反转（转置）', '', 'inherit', 'open', 'open', '', '131-revision', '', '', '2014-01-21 03:32:20', '2014-01-21 03:32:20', '', 131, 'http://codeseeking.sinaapp.com/?p=132', 0, 'revision', '', 0),
(133, 1, '2014-01-21 03:33:19', '2014-01-21 03:33:19', '\n\n<pre lang="c"  colla="+">\n\nvoid reverse(char *t , int from , int to){\n\n    while(from<to){\n\n         char tmp = t[from];\n\n         t[from++] = t[to];\n\n         t[to--] = tmp;\n\n   }\n\n}\n\nvoid leftshift(char *t , int n , int m ){\n\n    m %= n;\n\n   reverse(t , 0 , m-1);\n\n   reverse(t, m , n-1);\n\n   reverse(t, 0 , n-1);\n\n}\n\n</pre>', '三步反转（转置）', '', 'inherit', 'open', 'open', '', '131-revision-2', '', '', '2014-01-21 03:33:19', '2014-01-21 03:33:19', '', 131, '', 0, 'revision', '', 0),
(143, 1, '2014-05-20 12:28:18', '2014-05-20 12:28:18', '向上补全  C-P\r\n向下补全  C-N\r\n补全文件名  C-X  C-F\r\n补全宏定义  C-X  C-D\r\n补全vim命令  C-X  C-V\r\n用户自定义补全方式  C-X  C-U\r\n拼写建议  C-X  C-S\r\n整行补全  C-X  C-L\r\n根据当前文件关键字补全  C-X  C-N\r\n根据字典补全  C-X  C-K\r\n根据头文件关键词补全  C-X  C-I\r\n根据标签补全  C-X  C-]\r\n补全还是可以的\r\n为了加上tab补全可以下载supertab，安装后tab会记录你上一次的补全。\r\nwww.vim.org/scripts/script.php?script_id=1643', 'vim 补全', '', 'publish', 'open', 'open', '', 'vim-%e8%a1%a5%e5%85%a8', '', '', '2014-05-20 12:38:50', '2014-05-20 12:38:50', '', 0, 'http://codeseeking.sinaapp.com/?p=143', 0, 'post', '', 0),
(137, 1, '2013-05-07 01:41:59', '2013-05-07 01:41:59', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\r\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\r\n\r\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\r\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\r\n\r\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\r\n $ cp id_rsa* key_backup\r\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"</pre>这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\r\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>然后，在登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。\r\n5.test,输入<pre lang="shell" colla="+">ssh git@github.com</pre>，如果提示hi，what what what 就说明设置成功了。如果是Permission denied (publickey). 那就是密钥对的事，根据github官网上的Q&A，首先检查下是否存在～/.ssh 然后考虑是不是复制时出的问题，vim的设置会导致从vim中复制出来的含有换行符等，最后，也是我的问题所在是公钥正确的设置了，但是自己机器的私钥没有设置，<pre lang="shell" colla="+">$ ssh-add -l</pre>如果显示The agent has no identities.则说明没有私钥，你说官网也是，光说去看看，也没说没有怎么办，不过稍微想想，之前的xxx & xxx.pub就不难知道，<pre lang="shell" colla="+">$ ssh-add xxx</pre>将私钥添加进去，再-l的时候就会显示了，这个问题在你调整公钥私钥文件位置的时候也会出现，所以出现Permission denied (publickey).尝试上述。\r\n这样，在提示登录成功的时候就可以准备同步你和github仓库了！\r\n\r\nps：貌似git还得设置下用户信息，官方步骤有，那就设置下吧<pre lang="shell" colla="+">$ git config --global user.name "defnngj"//给自己起个用户名\r\n$ git config --global user.email  "defnngj@gmail.com"//填写自己的邮箱</pre>由于我找不到所谓的api token所以就设置了这两句，够用了。\r\n\r\nThen,let''s play with it now:\r\nif you create a new project , how can you post it to github?\r\n<pre lang="shell" colla="+">\r\n假设你创建好了一个项目，并切换到项目的根目录下面：\r\n$ git status   //查看当前项目下所有文的状态，如果第一次，你会发现都红颜色的，因为它还没有交给git/github管理。\r\n$ git add .   //（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。\r\nPs:git的强大之处就是有一个本地仓库的概念，在没有网络的情况下可以先将更新的内容提交到本地仓库。\r\n$ git commit –m”new natter ”  //对你更新或修改了哪些内容做一个描述。\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//如果你是第一次提交项目，这一句非常重要，这是你本地的当前的项目与远程的哪个仓库建立连接。\r\nPs: origin可以改为别人的名字，但是在你下一次push（提交）时，也要用你修改之后的名字。\r\n$ git remote -v  //查看你当前项目远程连接的是哪个仓库地址。\r\n$ git push -u origin master  //将本地的项目提交到远程仓库中。\r\n</pre>\r\nif you get home,don''t you want to get the project from the github?\r\n<pre lang="shell" colla="+">\r\n如果你是第一次想把github上面的项目克隆到本地或者要克隆别人的项目到地。\r\n$ git clone git@github.com:defnngj/hibernate-demo.git  //在git下面切换到想存放此项目的文件目录下，运行这条命令就可以将项目克隆下来。\r\n\r\n假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？\r\n$ git fetch origin    //取得远程更新，这里可以看做是准备要取了\r\n$ git merge origin/master  //把更新的内容合并到本地分支/master\r\n</pre>\r\nif you delete some files,how can you update to github?\r\n<pre lang="shell" colla="+">\r\n假如远程仓库中已经存了aaa这个文件，我fetch了下来，并删除了aaa这个文件，想再push上到远程仓库中，并使远程仓库中的项目被新的修改覆盖（也是是远程仓库中的aaa也被删除）\r\n$ git status   //可以看到我们删除的哪些文件\r\n$ git add .   //删除之后的文件提交git管理。\r\n$ git rm   src/com/hzh/hibernate/dao/aaa.java    //移除我们删除的那个文件，不然git不允许我们往远程仓库提交。\r\nPs: 如果你想删除的是某个目录（java包），这里想移除整个目录的内容。\r\n$ git rm  src/com/hzh/hibernate/bbb/ -r   // -r 会把bbb/目录下的所有内容一次性移动。\r\n</pre>\r\nif 远程创建了一个新仓库，本地创建了一个新项目，如何使新的项目与仓库对应起来？\r\n<pre lang="shell" colla="+">\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//还是这个命令，在你push项目之前加上这一句就OK了。\r\ngit@github.com:defnngj/hibernate-demo.git 就是你常见的新仓库的地址啊。git切换到新项目下，在push之前，加上这一句，我们创建的新仓库就与新项目建立了连接。\r\n</pre>', 'linux github 设置', '', 'inherit', 'open', 'open', '', '110-revision-5', '', '', '2013-05-07 01:41:59', '2013-05-07 01:41:59', '', 110, 'http://codeseeking.sinaapp.com/?p=137', 0, 'revision', '', 0),
(138, 1, '2014-05-20 01:50:55', '2014-05-20 01:50:55', '挺好的文档类学习，比python基础教程来的直接简洁。\r\n\r\nurl： woodpecker.org.cn/diveintopython3/table-of-contents.html', '深入python3[啄木鸟社区]', '', 'publish', 'open', 'open', '', '%e6%b7%b1%e5%85%a5python3%e5%95%84%e6%9c%a8%e9%b8%9f%e7%a4%be%e5%8c%ba', '', '', '2014-05-20 01:50:55', '2014-05-20 01:50:55', '', 0, 'http://codeseeking.sinaapp.com/?p=138', 0, 'post', '', 0),
(139, 1, '2014-05-20 01:49:59', '2014-05-20 01:49:59', '挺好的文档\nwoodpecker.org.cn/diveintopython3/table-of-contents.html', '深入python3[啄木鸟社区]', '', 'inherit', 'open', 'open', '', '138-revision', '', '', '2014-05-20 01:49:59', '2014-05-20 01:49:59', '', 138, 'http://codeseeking.sinaapp.com/?p=139', 0, 'revision', '', 0),
(140, 1, '2014-05-15 06:18:20', '2014-05-15 06:18:20', '昨天小设置了下linux下的github，总的来说还是遇到和解决不少问题的。\r\n1.安装git<pre lang="c" colla="+">sudo apt-get install git</pre>\r\n\r\n2.在github.com中申请一个github的帐号，用户名/帐号/密码etc\r\n3.在github上创建一个新的“New Repository”，并且填写项目信息最后“Create Repository”便创建了一个github仓库，一个仓库只能存放一个项目。\r\n\r\n4.创建密钥（ssh），<pre lang="shell" colla="+">$cd ~/.ssh  //check the key</pre> 如果提示No such directory 则表示是第一次使用git，如果不是第一次使用，使用<pre lang="shell" colla="+"> $ mkdir key_backup\r\n $ cp id_rsa* key_backup\r\n $ rm id_rsa*</pre>来清理之前的密钥。然后生成新的密钥<pre lang="shell" colla="+">$ssh -keygen -t rsa -C "xxx@xx.com"</pre>这里会提示输入存放密钥的文件名，并且要求输入一个密码，为了在以后提交项目的时候使用，如果不想设置就为空，但是这样可能方便别人给你的项目“润色”了。\r\n这样，找到你存放key的文件，一共又xx & xx.pub 一个是私钥，一个是公钥，利用 <pre lang="shell" colla="+">cat xx.pub|xclip 或者 cat xx.pub|xsel</pre>然后，在登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。\r\n5.test,输入<pre lang="shell" colla="+">ssh -T git@github.com</pre>，如果提示hi，what what what 就说明设置成功了。如果是Permission denied (publickey). 那就是密钥对的事，根据github官网上的Q&A，首先检查下是否存在～/.ssh 然后考虑是不是复制时出的问题，vim的设置会导致从vim中复制出来的含有换行符等，最后，也是我的问题所在是公钥正确的设置了，但是自己机器的私钥没有设置，<pre lang="shell" colla="+">$ ssh-add -l</pre>如果显示The agent has no identities.则说明没有私钥，你说官网也是，光说去看看，也没说没有怎么办，不过稍微想想，之前的xxx & xxx.pub就不难知道，<pre lang="shell" colla="+">$ ssh-add xxx</pre>将私钥添加进去，再-l的时候就会显示了，这个问题在你调整公钥私钥文件位置的时候也会出现，所以出现Permission denied (publickey).尝试上述。\r\n这样，在提示登录成功的时候就可以准备同步你和github仓库了！\r\n\r\nps：貌似git还得设置下用户信息，官方步骤有，那就设置下吧<pre lang="shell" colla="+">$ git config --global user.name "defnngj"//给自己起个用户名\r\n$ git config --global user.email  "defnngj@gmail.com"//填写自己的邮箱</pre>由于我找不到所谓的api token所以就设置了这两句，够用了。\r\n\r\nThen,let''s play with it now:\r\nif you create a new project , how can you post it to github?\r\n<pre lang="shell" colla="+">\r\n假设你创建好了一个项目，并切换到项目的根目录下面：\r\n$ git status   //查看当前项目下所有文的状态，如果第一次，你会发现都红颜色的，因为它还没有交给git/github管理。\r\n$ git add .   //（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。\r\nPs:git的强大之处就是有一个本地仓库的概念，在没有网络的情况下可以先将更新的内容提交到本地仓库。\r\n$ git commit –m”new natter ”  //对你更新或修改了哪些内容做一个描述。\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//如果你是第一次提交项目，这一句非常重要，这是你本地的当前的项目与远程的哪个仓库建立连接。\r\nPs: origin可以改为别人的名字，但是在你下一次push（提交）时，也要用你修改之后的名字。\r\n$ git remote -v  //查看你当前项目远程连接的是哪个仓库地址。\r\n$ git push -u origin master  //将本地的项目提交到远程仓库中。\r\n</pre>\r\nif you get home,don''t you want to get the project from the github?\r\n<pre lang="shell" colla="+">\r\n如果你是第一次想把github上面的项目克隆到本地或者要克隆别人的项目到地。\r\n$ git clone git@github.com:defnngj/hibernate-demo.git  //在git下面切换到想存放此项目的文件目录下，运行这条命令就可以将项目克隆下来。\r\n\r\n假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？\r\n$ git fetch origin    //取得远程更新，这里可以看做是准备要取了\r\n$ git merge origin/master  //把更新的内容合并到本地分支/master\r\n</pre>\r\nif you delete some files,how can you update to github?\r\n<pre lang="shell" colla="+">\r\n假如远程仓库中已经存了aaa这个文件，我fetch了下来，并删除了aaa这个文件，想再push上到远程仓库中，并使远程仓库中的项目被新的修改覆盖（也是是远程仓库中的aaa也被删除）\r\n$ git status   //可以看到我们删除的哪些文件\r\n$ git add .   //删除之后的文件提交git管理。\r\n$ git rm   src/com/hzh/hibernate/dao/aaa.java    //移除我们删除的那个文件，不然git不允许我们往远程仓库提交。\r\nPs: 如果你想删除的是某个目录（java包），这里想移除整个目录的内容。\r\n$ git rm  src/com/hzh/hibernate/bbb/ -r   // -r 会把bbb/目录下的所有内容一次性移动。\r\n</pre>\r\nif 远程创建了一个新仓库，本地创建了一个新项目，如何使新的项目与仓库对应起来？\r\n<pre lang="shell" colla="+">\r\n$ git remote add origin git@github.com:defnngj/hibernate-demo.git\r\n//还是这个命令，在你push项目之前加上这一句就OK了。\r\ngit@github.com:defnngj/hibernate-demo.git 就是你常见的新仓库的地址啊。git切换到新项目下，在push之前，加上这一句，我们创建的新仓库就与新项目建立了连接。\r\n</pre>', 'linux github 设置', '', 'inherit', 'open', 'open', '', '110-revision-6', '', '', '2014-05-15 06:18:20', '2014-05-15 06:18:20', '', 110, 'http://codeseeking.sinaapp.com/?p=140', 0, 'revision', '', 0),
(141, 1, '2014-05-20 02:57:47', '2014-05-20 02:57:47', '\r\n    ^ 匹配字符串开始位置。\r\n    $ 匹配字符串结束位置。\r\n    \\b 匹配一个单词边界。\r\n    \\d 匹配一个数字。\r\n    \\D 匹配一个任意的非数字字符。\r\n    x? 匹配可选的x字符。换句话说，就是0个或者1个x字符。\r\n    x* 匹配0个或更多的x。\r\n    x+ 匹配1个或者更多x。\r\n    x{n,m} 匹配n到m个x，至少n个，不能超过m个。\r\n    (a|b|c) 匹配单独的任意一个a或者b或者c。\r\n    (x) 这是一个组，它会记忆它匹配到的字符串。你可以用re.search返回的匹配对象的groups()函数来获取到匹配的值。 ', '正则（持续更新）', '', 'publish', 'open', 'open', '', '%e6%ad%a3%e5%88%99%ef%bc%88%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0%ef%bc%89', '', '', '2014-05-20 02:57:47', '2014-05-20 02:57:47', '', 0, 'http://codeseeking.sinaapp.com/?p=141', 0, 'post', '', 0),
(142, 1, '2014-05-20 02:57:11', '2014-05-20 02:57:11', '\n    ^ 匹配字符串开始位置。\n    $ 匹配字符串结束位置。\n    \\b 匹配一个单词边界。\n    \\d 匹配一个数字。\n    \\D 匹配一个任意的非数字字符。\n    x? 匹配可选的x字符。换句话说，就是0个或者1个x字符。\n    x* 匹配0个或更多的x。\n    x+ 匹配1个或者更多x。\n    x{n,m} 匹配n到m个x，至少n个，不能超过m个。\n    (a|b|c) 匹配单独的任意一个a或者b或者c。\n    (x) 这是一个组，它会记忆它匹配到的字符串。你可以用re.search返回的匹配对象的groups()函数来获取到匹配的值。 ', '正则（持续更新）', '', 'inherit', 'open', 'open', '', '141-revision', '', '', '2014-05-20 02:57:11', '2014-05-20 02:57:11', '', 141, 'http://codeseeking.sinaapp.com/?p=142', 0, 'revision', '', 0),
(144, 1, '2014-05-20 12:28:05', '2014-05-20 12:28:05', '向上补全  C-P\n向下补全  C-N\n补全文件名  C-X  C-F\n补全宏定义  C-X  C-D\n补全vim命令  C-X  C-V\n用户自定义补全方式  C-X  C-U\n拼写建议  C-X  C-S\n整行补全  C-X  C-L\n根据当前文件关键字补全  C-X  C-N\n根据字典补全  C-X  C-K\n根据头文件关键词补全  C-X  C-I\n根据标签补全  C-X  C-]\n补全还是可以的\n', 'vim 补全', '', 'inherit', 'open', 'open', '', '143-revision', '', '', '2014-05-20 12:28:05', '2014-05-20 12:28:05', '', 143, 'http://codeseeking.sinaapp.com/?p=144', 0, 'revision', '', 0),
(145, 1, '2014-05-20 12:38:46', '2014-05-20 12:38:46', '向上补全  C-P\n向下补全  C-N\n补全文件名  C-X  C-F\n补全宏定义  C-X  C-D\n补全vim命令  C-X  C-V\n用户自定义补全方式  C-X  C-U\n拼写建议  C-X  C-S\n整行补全  C-X  C-L\n根据当前文件关键字补全  C-X  C-N\n根据字典补全  C-X  C-K\n根据头文件关键词补全  C-X  C-I\n根据标签补全  C-X  C-]\n补全还是可以的\n为了加上tab补全可以下载supertab，安装后tab会记录你上一次的补全。\nwww.vim.org/scripts/script.php?script_id=1643', 'vim 补全', '', 'inherit', 'open', 'open', '', '143-autosave', '', '', '2014-05-20 12:38:46', '2014-05-20 12:38:46', '', 143, 'http://codeseeking.sinaapp.com/?p=145', 0, 'revision', '', 0),
(146, 1, '2014-05-20 12:28:18', '2014-05-20 12:28:18', '向上补全  C-P\r\n向下补全  C-N\r\n补全文件名  C-X  C-F\r\n补全宏定义  C-X  C-D\r\n补全vim命令  C-X  C-V\r\n用户自定义补全方式  C-X  C-U\r\n拼写建议  C-X  C-S\r\n整行补全  C-X  C-L\r\n根据当前文件关键字补全  C-X  C-N\r\n根据字典补全  C-X  C-K\r\n根据头文件关键词补全  C-X  C-I\r\n根据标签补全  C-X  C-]\r\n补全还是可以的\r\n', 'vim 补全', '', 'inherit', 'open', 'open', '', '143-revision-2', '', '', '2014-05-20 12:28:18', '2014-05-20 12:28:18', '', 143, 'http://codeseeking.sinaapp.com/?p=146', 0, 'revision', '', 0),
(147, 1, '2014-05-21 08:15:38', '2014-05-21 08:15:38', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\n<ul>\r\n	<li><strong>first of all THE LIST：</strong></li>\r\n</ul>\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python">a_list = [1,2,3,4]\r\na_list[0]  1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\nname = list(''perl'')\r\nname\r\n[''p'',''e'',''r'',''l'']\r\nname[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\nname\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist  [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去</pre>\r\nlist方法：append() index() extend() count() insert() pop() reverse() remove() sort()\r\n<pre lang="python">a_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦</pre>\r\n<ul>\r\n	<li><strong>second,TUPLE 元组</strong></li>\r\n</ul>\r\n元组是不可变的列表。\r\n元组的创建：\r\n<pre lang="python">a_tuple = (1,2,3,4)  #用一对小括号创建元组 \r\n#元组和列表可以互相转化，可以想成list()融化元组，tuple()冻结列表\r\na_list = list(a_tuple)\r\na_tuple = tuple(a_list)\r\n#同时赋多个值\r\n(mon,tues,wed,thurs,fri,sat,sun) = range(7)</pre>\r\n对于元祖，其分片，索引等都和列表相同，但是对于append等一系列的操作则不能，当然除了index() 和 in 判断元组中是否存在该元素以外\r\n相对于列表，元组的好处还是有的：\r\n1.元祖的速度比列表快，如果只是需要进行遍历，创建成元组更合适\r\n2.写保护，代码更加安全\r\n3.一些元组可用作字典键，而列表永远不能做字典键，因为列表不是不可变的的\r\n<ul>\r\n	<li><strong>third,The SET 集合</strong></li>\r\n</ul>\r\n集合则是装有独特值的无序袋子，既然是独特值，那么其中的元素就是去重的，同时一个集合中可以包含任何类型的数据，同时两个集合可以执行交/并/差/对称差等操作\r\n集合的创建是用一对大括号 {}来初始化的\r\n<pre lang="python">a_set = {1,2,3,4}\r\na_set = set(a_list) #set()函数可以将列表变成集合当然会去重，\r\n#同时，因为set集合是无序的，可能同样顺序产生出来的set顺序不同，\r\n#但是他俩还是同一个集合的，ps：实际上集合是以类的形式出现的。</pre>\r\n修改集合值的方法，add() 和 update() 两种添加方法，remove() 和discard() 两种删除方法\r\n<pre lang="python">a_set.add(x) #将x 加入到集合中\r\na_set.update({x1,x2,x3},{y1,y2,y3}) #update仅接受一个集合作为参数，将所有元素去重形成新的集合\r\na_set.discard(x) #将x从集合中去除\r\na_set.remove(x) #同将x从集合中去除\r\n#两者的微妙差异在于，如果x不在集合中，那么discard不会报错而remove则会报错</pre>\r\nps：集合总也有个pop()但是因为集合中元素是无序的，导致pop()每次出来的值也是随机的\r\n常见额的集合操作，in / union / intersection / difference / symmetic_difference\r\n<pre lang="python" colla="-">&gt;&gt;&gt;x in a_set\r\nTrue/False\r\na_set = {...}   b_set = {...}\r\na_set.union(b_set)  #并 |\r\na_set.intersection(b_set)  #交 &amp;\r\na_set.difference(b_set)  #a-b 差\r\na_set.symmetric_difference(b_set) #对称差，a|b -(a&amp;b)\r\nps:\r\na_set.issubset(b_set)\r\nTrue/False\r\nb_set.issuperset(a_set)\r\nTrue/False\r\n</pre>\r\n<ul>\r\n	<li><strong>final，DICT 字典</strong></li>\r\n</ul>\r\n字典是键值对的无序集合。向字典添加一个键的同时必须向字典添加一个值。\r\n字典的创建仍然靠一对大括号 {} 但是其中的结构有所要求，必须是{x:y , n:m ...}\r\n<pre lang="python" colla="-">\r\na_dict = {''user'':''char'',''pwd'':''123'', ... }\r\n>>>a_dict[''user'']\r\n''char''\r\n#修改字典\r\na_dict[''user''] = ''new item'' #即修改了user对应的值\r\n#字典中不允许存在重复的键，所以对某键值的修改会覆盖\r\n</pre>\r\n混合值字典，字典并非只能用于字符串，字典的值可以是任何的数据类型，即便在同一字典中，值的类型也不必相同，同时也可混合使用不同类型的键。\r\n\r\n以上便是python中的四种比较重要的数据‘容器’在此小作总结。', 'list/tuple/dict/set of python', '', 'publish', 'open', 'open', '', 'listtupledictset-of-python', '', '', '2014-06-06 08:40:51', '2014-06-06 08:40:51', '', 0, 'http://codeseeking.sinaapp.com/?p=147', 0, 'post', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(193, 1, '2014-06-06 08:37:35', '2014-06-06 08:37:35', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\n<ul>\r\n	<li><strong>first of all THE LIST：</strong></li>\r\n</ul>\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python">a_list = [1,2,3,4]\r\na_list[0]  1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\nname = list(''perl'')\r\nname\r\n[''p'',''e'',''r'',''l'']\r\nname[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\nname\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist  [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去</pre>\r\nlist方法：append() index() extend() count() insert() pop() reverse() remove() sort()\r\n<pre lang="python">a_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦</pre>\r\n<ul>\r\n	<li><strong>second,TUPLE 元组</strong></li>\r\n</ul>\r\n元组是不可变的列表。\r\n元组的创建：\r\n<pre lang="python">a_tuple = (1,2,3,4)  #用一对小括号创建元组 \r\n#元组和列表可以互相转化，可以想成list()融化元组，tuple()冻结列表\r\na_list = list(a_tuple)\r\na_tuple = tuple(a_list)\r\n#同时赋多个值\r\n(mon,tues,wed,thurs,fri,sat,sun) = range(7)</pre>\r\n对于元祖，其分片，索引等都和列表相同，但是对于append等一系列的操作则不能，当然除了index() 和 in 判断元组中是否存在该元素以外\r\n相对于列表，元组的好处还是有的：\r\n1.元祖的速度比列表快，如果只是需要进行遍历，创建成元组更合适\r\n2.写保护，代码更加安全\r\n3.一些元组可用作字典键，而列表永远不能做字典键，因为列表不是不可变的的\r\n<ul>\r\n	<li><strong>third,The SET 集合</strong></li>\r\n</ul>\r\n集合则是装有独特值的无序袋子，既然是独特值，那么其中的元素就是去重的，同时一个集合中可以包含任何类型的数据，同时两个集合可以执行交/并/差/对称差等操作\r\n集合的创建是用一对大括号 {}来初始化的\r\n<pre lang="python">a_set = {1,2,3,4}\r\na_set = set(a_list) #set()函数可以将列表变成集合当然会去重，\r\n#同时，因为set集合是无序的，可能同样顺序产生出来的set顺序不同，\r\n#但是他俩还是同一个集合的，ps：实际上集合是以类的形式出现的。</pre>\r\n修改集合值的方法，add() 和 update() 两种添加方法，remove() 和discard() 两种删除方法\r\n<pre lang="python">a_set.add(x) #将x 加入到集合中\r\na_set.update({x1,x2,x3},{y1,y2,y3}) #update仅接受一个集合作为参数，将所有元素去重形成新的集合\r\na_set.discard(x) #将x从集合中去除\r\na_set.remove(x) #同将x从集合中去除\r\n#两者的微妙差异在于，如果x不在集合中，那么discard不会报错而remove则会报错</pre>\r\nps：集合总也有个pop()但是因为集合中元素是无序的，导致pop()每次出来的值也是随机的\r\n常见额的集合操作，in / union / intersection / difference / symmetic_difference\r\n<pre lang="python" colla="-">&gt;&gt;&gt;x in a_set\r\nTrue/False\r\na_set = {...}   b_set = {...}\r\na_set.union(b_set)  #并 |\r\na_set.intersection(b_set)  #交 &amp;\r\na_set.difference(b_set)  #a-b 差\r\na_set.symmetric_difference(b_set) #对称差，a|b -(a&amp;b)\r\nps:\r\na_set.issubset(b_set)\r\n&gt;&gt;True/False\r\nb_set.issuperset(a_set)\r\n&gt;&gt;True/False\r\n</pre>\r\n<ul>\r\n	<li><strong>final，DICT 字典</strong></li>\r\n</ul>\r\n字典是键值对的无序集合。向字典添加一个键的同时必须向字典添加一个值。\r\n字典的创建仍然靠一对大括号 {} 但是其中的结构有所要求，必须是{x:y , n:m ...}\r\n<pre lang="python" colla="-">\r\na_dict = {''user'':''char'',''pwd'':''123'', ... }\r\n>>>a_dict[''user'']\r\n''char''\r\n#修改字典\r\na_dict[''user''] = ''new item'' #即修改了user对应的值\r\n#字典中不允许存在重复的键，所以对某键值的修改会覆盖\r\n</pre>\r\n混合值字典，字典并非只能用于字符串，字典的值可以是任何的数据类型，即便在同一字典中，值的类型也不必相同，同时也可混合使用不同类型的键。\r\n\r\n以上便是python中的四种比较重要的数据‘容器’在此小作总结。', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-9', '', '', '2014-06-06 08:37:35', '2014-06-06 08:37:35', '', 147, 'http://codeseeking.sinaapp.com/?p=193', 0, 'revision', '', 0),
(148, 1, '2014-05-21 07:15:07', '2014-05-21 07:15:07', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\nfirst of all THE LIST：\n<pre lang="python" colla="+">\n初始化\nl\n</pre>', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision', '', '', '2014-05-21 07:15:07', '2014-05-21 07:15:07', '', 147, 'http://codeseeking.sinaapp.com/?p=148', 0, 'revision', '', 0),
(149, 1, '2014-05-21 07:16:07', '2014-05-21 07:16:07', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\nfirst of all THE LIST：\n<pre lang="python" colla="+">\n初始化\na_list = [1,2,3,4]\na_list = list(''hello'')\n</pre>', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-2', '', '', '2014-05-21 07:16:07', '2014-05-21 07:16:07', '', 147, 'http://codeseeking.sinaapp.com/?p=149', 0, 'revision', '', 0),
(150, 1, '2014-05-21 07:35:55', '2014-05-21 07:35:55', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\nfirst of all THE LIST：\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python" colla="-">\r\na_list = [1,2,3,4]\r\na_list[0] <==> 1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\n>>>name = list(''perl'')\r\n>>>name\r\n[''p'',''e'',''r'',''l'']\r\n>>>name[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\n>>>name\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist <==> [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去\r\n</pre>\r\nlist方法：append() index()  extend()  count() insert() pop() reverse() remove()  sort()\r\n<pre lang="python" colla="-">\r\na_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦\r\n</pre>', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-3', '', '', '2014-05-21 07:35:55', '2014-05-21 07:35:55', '', 147, 'http://codeseeking.sinaapp.com/?p=150', 0, 'revision', '', 0),
(151, 1, '2014-05-21 07:45:37', '2014-05-21 07:45:37', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\n<ul>\r\n	<li><strong>first of all THE LIST：</strong></li>\r\n</ul>\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python">a_list = [1,2,3,4]\r\na_list[0]  1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\n&gt;&gt;&gt;name = list(''perl'')\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''r'',''l'']\r\n&gt;&gt;&gt;name[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist  [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去</pre>\r\nlist方法：append() index() extend() count() insert() pop() reverse() remove() sort()\r\n<pre lang="python">a_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦</pre>\r\n<ul>\r\n	<li><strong>second,TUPLE 元组</strong></li>\r\n</ul>\r\n元组是不可变的列表。\r\n元组的创建：\r\n<pre lang="python" colla="-">\r\na_tuple = (1,2,3,4)  #用一对小括号创建元组 \r\n</pre>\r\n对于元祖，其分片，索引等都和列表相同，但是对于append等一系列的操作则不能，当然除了index() 和 in 判断元组中是否存在该元素以外\r\n相对于列表，元组的好处还是有的：\r\n1.元祖的速度比列表快，如果只是需要进行遍历，创建成元组更合适\r\n2.写保护，代码更加安全\r\n3.一些元组可用作字典键，而列表永远不能做字典键，因为列表不是不可变的的\r\n', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-4', '', '', '2014-05-21 07:45:37', '2014-05-21 07:45:37', '', 147, 'http://codeseeking.sinaapp.com/?p=151', 0, 'revision', '', 0),
(152, 1, '2014-05-21 07:49:52', '2014-05-21 07:49:52', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\n<ul>\r\n	<li><strong>first of all THE LIST：</strong></li>\r\n</ul>\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python">a_list = [1,2,3,4]\r\na_list[0]  1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\n&gt;&gt;&gt;name = list(''perl'')\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''r'',''l'']\r\n&gt;&gt;&gt;name[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist  [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去</pre>\r\nlist方法：append() index() extend() count() insert() pop() reverse() remove() sort()\r\n<pre lang="python">a_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦</pre>\r\n<ul>\r\n	<li><strong>second,TUPLE 元组</strong></li>\r\n</ul>\r\n元组是不可变的列表。\r\n元组的创建：\r\n<pre lang="python" colla="-">\r\na_tuple = (1,2,3,4)  #用一对小括号创建元组 \r\n#元组和列表可以互相转化，可以想成list()融化元组，tuple()冻结列表\r\na_list = list(a_tuple)\r\na_tuple = tuple(a_list)\r\n#同时赋多个值\r\n(mon,tues,wed,thurs,fri,sat,sun) = range(7)\r\n</pre>\r\n对于元祖，其分片，索引等都和列表相同，但是对于append等一系列的操作则不能，当然除了index() 和 in 判断元组中是否存在该元素以外\r\n相对于列表，元组的好处还是有的：\r\n1.元祖的速度比列表快，如果只是需要进行遍历，创建成元组更合适\r\n2.写保护，代码更加安全\r\n3.一些元组可用作字典键，而列表永远不能做字典键，因为列表不是不可变的的\r\n\r\n\r\n<blockquote><strong>third,The SET 集合</strong></blockquote>\r\n\r\n', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-5', '', '', '2014-05-21 07:49:52', '2014-05-21 07:49:52', '', 147, 'http://codeseeking.sinaapp.com/?p=152', 0, 'revision', '', 0),
(153, 1, '2014-05-21 08:15:38', '2014-05-21 08:15:38', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\n<ul>\r\n	<li><strong>first of all THE LIST：</strong></li>\r\n</ul>\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python">a_list = [1,2,3,4]\r\na_list[0]  1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\n&gt;&gt;&gt;name = list(''perl'')\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''r'',''l'']\r\n&gt;&gt;&gt;name[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist  [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去</pre>\r\nlist方法：append() index() extend() count() insert() pop() reverse() remove() sort()\r\n<pre lang="python">a_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦</pre>\r\n<ul>\r\n	<li><strong>second,TUPLE 元组</strong></li>\r\n</ul>\r\n元组是不可变的列表。\r\n元组的创建：\r\n<pre lang="python">a_tuple = (1,2,3,4)  #用一对小括号创建元组 \r\n#元组和列表可以互相转化，可以想成list()融化元组，tuple()冻结列表\r\na_list = list(a_tuple)\r\na_tuple = tuple(a_list)\r\n#同时赋多个值\r\n(mon,tues,wed,thurs,fri,sat,sun) = range(7)</pre>\r\n对于元祖，其分片，索引等都和列表相同，但是对于append等一系列的操作则不能，当然除了index() 和 in 判断元组中是否存在该元素以外\r\n相对于列表，元组的好处还是有的：\r\n1.元祖的速度比列表快，如果只是需要进行遍历，创建成元组更合适\r\n2.写保护，代码更加安全\r\n3.一些元组可用作字典键，而列表永远不能做字典键，因为列表不是不可变的的\r\n<ul>\r\n	<li><strong>third,The SET 集合</strong></li>\r\n</ul>\r\n集合则是装有独特值的无序袋子，既然是独特值，那么其中的元素就是去重的，同时一个集合中可以包含任何类型的数据，同时两个集合可以执行交/并/差/对称差等操作\r\n集合的创建是用一对大括号 {}来初始化的\r\n<pre lang="python">a_set = {1,2,3,4}\r\na_set = set(a_list) #set()函数可以将列表变成集合当然会去重，\r\n#同时，因为set集合是无序的，可能同样顺序产生出来的set顺序不同，\r\n#但是他俩还是同一个集合的，ps：实际上集合是以类的形式出现的。</pre>\r\n修改集合值的方法，add() 和 update() 两种添加方法，remove() 和discard() 两种删除方法\r\n<pre lang="python">a_set.add(x) #将x 加入到集合中\r\na_set.update({x1,x2,x3},{y1,y2,y3}) #update仅接受一个集合作为参数，将所有元素去重形成新的集合\r\na_set.discard(x) #将x从集合中去除\r\na_set.remove(x) #同将x从集合中去除\r\n#两者的微妙差异在于，如果x不在集合中，那么discard不会报错而remove则会报错</pre>\r\nps：集合总也有个pop()但是因为集合中元素是无序的，导致pop()每次出来的值也是随机的\r\n常见额的集合操作，in / union / intersection / difference / symmetic_difference\r\n<pre lang="python colla=">&gt;&gt;&gt;x in a_set\r\nTrue/False\r\na_set = {...}   b_set = {...}\r\na_set.union(b_set)  #并 |\r\na_set.intersection(b_set)  #交 &amp;\r\na_set.difference(b_set)  #a-b 差\r\na_set.symmetric_difference(b_set) #对称差，a|b -(a&amp;b)\r\nps:\r\na_set.issubset(b_set)\r\n&gt;&gt;True/False\r\nb_set.issuperset(a_set)\r\n&gt;&gt;True/False</pre>\r\n<ul>\r\n	<li><strong>final，DICT 字典</strong></li>\r\n</ul>\r\n字典是键值对的无序集合。向字典添加一个键的同时必须向字典添加一个值。\r\n字典的创建仍然靠一对大括号 {} 但是其中的结构有所要求，必须是{x:y , n:m ...}\r\n<pre lang="python" colla="-">\r\na_dict = {''user'':''char'',''pwd'':''123'', ... }\r\n>>>a_dict[''user'']\r\n''char''\r\n#修改字典\r\na_dict[''user''] = ''new item'' #即修改了user对应的值\r\n#字典中不允许存在重复的键，所以对某键值的修改会覆盖\r\n</pre>\r\n混合值字典，字典并非只能用于字符串，字典的值可以是任何的数据类型，即便在同一字典中，值的类型也不必相同，同时也可混合使用不同类型的键。\r\n\r\n以上便是python中的四种比较重要的数据‘容器’在此小作总结。', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-6', '', '', '2014-05-21 08:15:38', '2014-05-21 08:15:38', '', 147, 'http://codeseeking.sinaapp.com/?p=153', 0, 'revision', '', 0),
(154, 1, '2014-05-21 08:16:10', '2014-05-21 08:16:10', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\n<ul>\r\n	<li><strong>first of all THE LIST：</strong></li>\r\n</ul>\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python">a_list = [1,2,3,4]\r\na_list[0]  1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\n&gt;&gt;&gt;name = list(''perl'')\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''r'',''l'']\r\n&gt;&gt;&gt;name[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist  [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去</pre>\r\nlist方法：append() index() extend() count() insert() pop() reverse() remove() sort()\r\n<pre lang="python">a_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦</pre>\r\n<ul>\r\n	<li><strong>second,TUPLE 元组</strong></li>\r\n</ul>\r\n元组是不可变的列表。\r\n元组的创建：\r\n<pre lang="python">a_tuple = (1,2,3,4)  #用一对小括号创建元组 \r\n#元组和列表可以互相转化，可以想成list()融化元组，tuple()冻结列表\r\na_list = list(a_tuple)\r\na_tuple = tuple(a_list)\r\n#同时赋多个值\r\n(mon,tues,wed,thurs,fri,sat,sun) = range(7)</pre>\r\n对于元祖，其分片，索引等都和列表相同，但是对于append等一系列的操作则不能，当然除了index() 和 in 判断元组中是否存在该元素以外\r\n相对于列表，元组的好处还是有的：\r\n1.元祖的速度比列表快，如果只是需要进行遍历，创建成元组更合适\r\n2.写保护，代码更加安全\r\n3.一些元组可用作字典键，而列表永远不能做字典键，因为列表不是不可变的的\r\n<ul>\r\n	<li><strong>third,The SET 集合</strong></li>\r\n</ul>\r\n集合则是装有独特值的无序袋子，既然是独特值，那么其中的元素就是去重的，同时一个集合中可以包含任何类型的数据，同时两个集合可以执行交/并/差/对称差等操作\r\n集合的创建是用一对大括号 {}来初始化的\r\n<pre lang="python">a_set = {1,2,3,4}\r\na_set = set(a_list) #set()函数可以将列表变成集合当然会去重，\r\n#同时，因为set集合是无序的，可能同样顺序产生出来的set顺序不同，\r\n#但是他俩还是同一个集合的，ps：实际上集合是以类的形式出现的。</pre>\r\n修改集合值的方法，add() 和 update() 两种添加方法，remove() 和discard() 两种删除方法\r\n<pre lang="python">a_set.add(x) #将x 加入到集合中\r\na_set.update({x1,x2,x3},{y1,y2,y3}) #update仅接受一个集合作为参数，将所有元素去重形成新的集合\r\na_set.discard(x) #将x从集合中去除\r\na_set.remove(x) #同将x从集合中去除\r\n#两者的微妙差异在于，如果x不在集合中，那么discard不会报错而remove则会报错</pre>\r\nps：集合总也有个pop()但是因为集合中元素是无序的，导致pop()每次出来的值也是随机的\r\n常见额的集合操作，in / union / intersection / difference / symmetic_difference\r\n<pre lang="python colla="-">&gt;&gt;&gt;x in a_set\r\nTrue/False\r\na_set = {...}   b_set = {...}\r\na_set.union(b_set)  #并 |\r\na_set.intersection(b_set)  #交 &amp;\r\na_set.difference(b_set)  #a-b 差\r\na_set.symmetric_difference(b_set) #对称差，a|b -(a&amp;b)\r\nps:\r\na_set.issubset(b_set)\r\n&gt;&gt;True/False\r\nb_set.issuperset(a_set)\r\n&gt;&gt;True/False</pre>\r\n<ul>\r\n	<li><strong>final，DICT 字典</strong></li>\r\n</ul>\r\n字典是键值对的无序集合。向字典添加一个键的同时必须向字典添加一个值。\r\n字典的创建仍然靠一对大括号 {} 但是其中的结构有所要求，必须是{x:y , n:m ...}\r\n<pre lang="python" colla="-">\r\na_dict = {''user'':''char'',''pwd'':''123'', ... }\r\n>>>a_dict[''user'']\r\n''char''\r\n#修改字典\r\na_dict[''user''] = ''new item'' #即修改了user对应的值\r\n#字典中不允许存在重复的键，所以对某键值的修改会覆盖\r\n</pre>\r\n混合值字典，字典并非只能用于字符串，字典的值可以是任何的数据类型，即便在同一字典中，值的类型也不必相同，同时也可混合使用不同类型的键。\r\n\r\n以上便是python中的四种比较重要的数据‘容器’在此小作总结。', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-7', '', '', '2014-05-21 08:16:10', '2014-05-21 08:16:10', '', 147, 'http://codeseeking.sinaapp.com/?p=154', 0, 'revision', '', 0),
(155, 1, '2013-02-08 12:22:44', '2013-02-08 12:22:44', '我爱的人-陈小春', '音乐-更新', '', 'inherit', 'open', 'open', '', '48-revision-2', '', '', '2013-02-08 12:22:44', '2013-02-08 12:22:44', '', 48, 'http://codeseeking.sinaapp.com/?p=155', 0, 'revision', '', 0),
(156, 1, '2013-04-30 21:41:21', '2013-04-30 21:41:21', '加密：\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	\r\n	//获得灰度值\r\n	/*picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++){\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	}\r\n	printf("PicGrayValue is %d \\n",picG);*/\r\n	picG = 0xff;\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\r\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);*/\r\n				    	CK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^BK[3*(8*i+j)+n];\r\n		\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum - 1){\r\n			while((Knew == KL)|(picheck[Knew]!=0))\r\n				Knew = (Knew + 1)%bnum;\r\n			//cout<<Knew<<"  ";\r\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\r\n			picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\r\n			picheck[KL] = 1;\r\n		}\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(3*(y+d))%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		//memcpy(cpics+eachtime*k,CK,eachtime);\r\n		for(int m=0 ; m<16 ; m++)\r\n			pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("cpicC.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>\r\n解密：\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	picG = 0xff;\r\n	//cout<<"Please input the PicGreyvalue"<<endl;\r\n	//cin>>picG;\r\n	//printf("PicGrayValue is %d \\n",picG);\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n	    	Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum-1){\r\n		while((Knew == KL)|(picheck[Knew]!=0))\r\n			Knew = (Knew + 1)%bnum;\r\n		//cout<<Knew<<"  ";\r\n		memcpy(CK,pict.PicS+eachtime*Knew,eachtime);\r\n		picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(CK,pict.PicS+eachtime*KL,eachtime);\r\n			picheck[KL] = 1;\r\n		}\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					RSL = cycR(CK[3*(8*i+j)+n],RSR);\r\n					BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^(RSL-LCL[3*j+n]+picG)%picG;*/\r\n				    	BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^CK[3*(8*i+j)+n];\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		memcpy(cpics+eachtime*k,BK,eachtime);\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(y+d)%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		for(int m=0 ; m<16 ; m++)\r\n		    pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n\r\n	picS = picH*picW*3;\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("repic.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>', 'Double main()', '', 'inherit', 'open', 'open', '', '105-revision-2', '', '', '2013-04-30 21:41:21', '2013-04-30 21:41:21', '', 105, 'http://codeseeking.sinaapp.com/?p=156', 0, 'revision', '', 0),
(157, 1, '2014-05-21 08:19:39', '2014-05-21 08:19:39', '加密：\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	\r\n	//获得灰度值\r\n	/*picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++){\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	}\r\n	printf("PicGrayValue is %d \\n",picG);*/\r\n	picG = 0xff;\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\r\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);*/\r\n				    	CK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^BK[3*(8*i+j)+n];\r\n		\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum - 1){\r\n			while((Knew == KL)|(picheck[Knew]!=0))\r\n				Knew = (Knew + 1)%bnum;\r\n			//cout<<Knew<<"  ";\r\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\r\n			picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\r\n			picheck[KL] = 1;\r\n		}\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(3*(y+d))%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		//memcpy(cpics+eachtime*k,CK,eachtime);\r\n		for(int m=0 ; m<16 ; m++)\r\n			pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("cpicC.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>\r\n解密：\r\n<pre lang="c" colla="-">\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	picG = 0xff;\r\n	//cout<<"Please input the PicGreyvalue"<<endl;\r\n	//cin>>picG;\r\n	//printf("PicGrayValue is %d \\n",picG);\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n	    	Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum-1){\r\n		while((Knew == KL)|(picheck[Knew]!=0))\r\n			Knew = (Knew + 1)%bnum;\r\n		//cout<<Knew<<"  ";\r\n		memcpy(CK,pict.PicS+eachtime*Knew,eachtime);\r\n		picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(CK,pict.PicS+eachtime*KL,eachtime);\r\n			picheck[KL] = 1;\r\n		}\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					RSL = cycR(CK[3*(8*i+j)+n],RSR);\r\n					BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^(RSL-LCL[3*j+n]+picG)%picG;*/\r\n				    	BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^CK[3*(8*i+j)+n];\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		memcpy(cpics+eachtime*k,BK,eachtime);\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(y+d)%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		for(int m=0 ; m<16 ; m++)\r\n		    pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n\r\n	picS = picH*picW*3;\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("repic.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>', 'Double main()', '', 'inherit', 'open', 'open', '', '105-revision-3', '', '', '2014-05-21 08:19:39', '2014-05-21 08:19:39', '', 105, 'http://codeseeking.sinaapp.com/?p=157', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(158, 1, '2013-05-06 06:32:30', '2013-05-06 06:32:30', 'pichandle.c\r\n<pre lang="c" colla="-">\r\n#include "pichandle.h"\r\n/*void Xprod(char k[16],float pk[16]);//根据输入的序列产生最早的x0\r\nvoid NKProd(float pk[16],float nk[16],float xinput,float e,int times);//初始迭代times次，消除初始影响\r\nfloat f(float xi,float x);//局部混沌函数\r\nvoid RLProd(float *pk,float *nk,char *RL);//正常迭代，每次产生64字节随机序列\r\nvoid RLSplit(float nk,char *RL,int i,int j);//取位函数*/\r\n\r\nvoid Xprod(BYTE k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	y = 8*xi*xi*xi*xi-8*xi*xi+1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	if(y < 0)\r\n	    y = -y;\r\n	//y = 3.9999 * xi * ( 1 - xi);\r\n	//y = 4 * xi * xi * xi - 3 * xi;\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nBYTE cycL(BYTE a,BYTE b){\r\n    a = (a>>(8 - b))|(a<<b);\r\n    return a;\r\n}\r\n\r\nBYTE LSB(BYTE c){\r\n	BYTE tc = c & 0x07;\r\n	return tc;\r\n}\r\n\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d Num = %d\\n",eachtime,bnum);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n	//获得灰度值\r\n	/*picG = pict.PicS[0]*0.3 + pict.PicS[1]*0.59 + pict.PicS[2]*0.11;\r\n	for(int i = 1;i < picW * picH;i++){\r\n	    picG = (i * picG + pict.PicS[3*i]*0.3 + pict.PicS[3*i+1]*0.59 + pict.PicS[3*i+2]*0.11)/(i+1);\r\n	}\r\n	printf("PicGrayValue is %d \\n",picG);*/\r\n	picG = 0xff;\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSL = (BK[3*(8*i+j)+n]^RL[3*(8*i+j)+n]+LCL[3*j+n])%picG;\r\n					RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					CK[3*(8*i+j)+n] = cycL(RSL,RSR);*/\r\n				    	//CK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^BK[3*(8*i+j)+n];\r\n					RSR = LSB(LCL[3*j+n]);\r\n					RSL = cycL(BK[3*(8*i+j)+n],RSR);\r\n					CK[3*(8*i+j)+n] = RSL^RL[3*(8*i+j)+n];\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum - 1){\r\n			while((Knew == KL)|(picheck[Knew]!=0))\r\n				Knew = (Knew + 1)%bnum;\r\n			//cout<<Knew<<"  ";\r\n			memcpy(cpics+eachtime*Knew,CK,eachtime);\r\n			picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(cpics+eachtime*KL,CK,eachtime);	\r\n			picheck[KL] = 1;\r\n		}\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(3*(y+d))%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		//memcpy(cpics+eachtime*k,CK,eachtime);\r\n		for(int m=0 ; m<16 ; m++)\r\n			pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("cpic.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>\r\npichandle.h\r\n<pre lang="c" colla="-">\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <sys/types.h>\r\n#include<iostream>\r\n#pragma pack(2)\r\n\r\nusing namespace std;\r\n\r\n#define N 16\r\n#define e 0.05\r\n#define BYTE unsigned char\r\n#define WORD u_int16_t\r\n#define DWORD u_int32_t\r\n//typedef unsigned char BYTE;\r\n//typedef u_int16_t WORD;\r\n//typedef u_int32_t DWORD;\r\n\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n	WORD bfType; //数据地址为 0 - "BM"  \r\n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n	WORD bfReserved1;   //DA 6 - 文件保留字 0\r\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\r\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;\r\n\r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n	DWORD biWidth;   //DA 18\r\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n	DWORD biXPelsPerMeter;   //DA 38\r\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\r\n	DWORD biClrUsed;   //DA 46 颜色变址数\r\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER; \r\n\r\ntypedef struct tagRGBQUAD{\r\n	BYTE rgbBlue;\r\n	BYTE rgbGreen;\r\n	BYTE rgbRed;\r\n	BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nclass bmpreader{\r\npublic:\r\n	BITMAPFILEHEADER head;\r\n	BITMAPINFODEADER info;\r\n	RGBQUAD colors;\r\n	int picH,picW,csize;\r\n	int Bnum;\r\n	BYTE *PicS;\r\n	bmpreader(char *picaddr);\r\n	void showRgbtag(RGBQUAD &colors);\r\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\r\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\r\n};\r\n\r\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n\r\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    cout<<"位图文件头:"<<endl;    \r\n    cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    cout<<"位图信息头:"<<endl;    \r\n    cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n		cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n		cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n		cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n		cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n		cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n		cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n		cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n		cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n		cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}\r\n\r\nbmpreader::bmpreader(char *picaddr){\r\n	FILE *fp = fopen(picaddr, "rb");  	\r\n	int palesize = 0;\r\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \r\n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \r\n	switch(info.biBitCount){\r\n	    case 1:\r\n		palesize = 2;\r\n		break;\r\n	    case 4:\r\n		palesize = 16;\r\n		break;\r\n	    case 8:\r\n		palesize = 256;\r\n		break;\r\n	}\r\n	if(palesize){\r\n	    	cout<<"存在RGBQUAD.."<<endl;\r\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n	}else{\r\n		cout<<"不存在RGBQUAD.."<<endl;\r\n	}\r\n	showBmpHead(head);  \r\n	showBmpInforHead(info);  \r\n	//showRgbtag(colors);\r\n	int PicData = info.biSizeImage;\r\n	if(!palesize){\r\n		int tempsize = info.biBitCount/8;\r\n		tempsize = tempsize*64;\r\n		if(PicData%tempsize){\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n			PicData = PicData + (tempsize-PicData%tempsize);\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n		}\r\n		Bnum = PicData/tempsize;\r\n	}else{\r\n		if(PicData%64){\r\n			PicData = PicData + PicData%64;\r\n			cout<<PicData<<"---"<<"64"<<endl;\r\n		}	\r\n		Bnum = PicData/64;\r\n	}\r\n        //PicS = (char*)malloc(PicData);\r\n	csize = PicData;\r\n	picH = info.biHeight;\r\n	picW = info.biWidth;\r\n	PicS = (unsigned char*)new unsigned char[PicData];\r\n	memset(PicS,0,PicData);\r\n	fread(PicS,1,info.biSizeImage,fp);\r\n	if(feof(fp) == 0)\r\n	    cout<<"All in.."<<endl;\r\n	fclose(fp);  \r\n}\r\n\r\n\r\n/*void Xprod(char *k,float *pk);//根据输入的序列产生最早的x0\r\nvoid NKProd(float *pk,float *nk,int times);//初始迭代times次，消除初始影响\r\nfloat f(float xi,float x);//局部混沌函数\r\nvoid RLProd(float *pk,float *nk,char *RL);//正常迭代，每次产生64字节随机序列\r\nvoid RLSplit(float *nk,char *RL,int i,int j);//取位函数*/\r\n</pre>\r\nrepic.h\r\n<pre lang="c" colla="-">\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <sys/types.h>\r\n#include<iostream>\r\n#pragma pack(2)\r\n\r\nusing namespace std;\r\n\r\n#define N 16\r\n#define e 0.05\r\n#define BYTE unsigned char\r\n#define WORD u_int16_t\r\n#define DWORD u_int32_t\r\n//typedef unsigned char BYTE;\r\n//typedef u_int16_t WORD;\r\n//typedef u_int32_t DWORD;\r\n\r\ntypedef struct BITMAPFILEHEADER  \r\n{   \r\n	WORD bfType; //数据地址为 0 - "BM"  \r\n	DWORD bfSize; //DA 2 - 定义文件大小，字节为单位  \r\n	WORD bfReserved1;   //DA 6 - 文件保留字 0\r\n	WORD bfReserved2;   //DA 8 - 文件保留字 0\r\n	DWORD bfOffBits;   //DA 10 - 图像数据指针对文件头的偏移量\r\n}BITMAPFILEHEADER;\r\n\r\ntypedef struct BITMAPINFOHEADER  \r\n{   \r\n	DWORD biSize;   //DA14 BITMAPPINFOHEADER存储容量 固定值为40\r\n	DWORD biWidth;   //DA 18\r\n	DWORD biHeight;   //DA 22 像素为单位，文件所描述的位图的高度和宽度\r\n	WORD biPlanes;   //DA 26 目标设备的平面数 必须为1\r\n	WORD biBitCount;   //DA 28 确定每个像素需要的位数 单色-1 16色-14 256-8 真彩-24\r\n	DWORD biCompression;  //DA 30 压缩类型是否与进行了什么压缩 \r\n	DWORD biSizeImage;   //DA 34 图像数据所占用的空间大小，若上面30-BI-RGB 则该字段必须为0\r\n	DWORD biXPelsPerMeter;   //DA 38\r\n	DWORD biYPelsPerMeter;   //DA 42 分辨率\r\n	DWORD biClrUsed;   //DA 46 颜色变址数\r\n	DWORD biClrImportant;  //DA 50 重要颜色变址数 \r\n}BITMAPINFODEADER; \r\n\r\ntypedef struct tagRGBQUAD{\r\n	BYTE rgbBlue;\r\n	BYTE rgbGreen;\r\n	BYTE rgbRed;\r\n	BYTE rgbReserved;\r\n}RGBQUAD;\r\n\r\nclass bmpreader{\r\npublic:\r\n	BITMAPFILEHEADER head;\r\n	BITMAPINFODEADER info;\r\n	RGBQUAD colors;\r\n	int picH,picW,csize;\r\n	int Bnum;\r\n	BYTE *PicS;\r\n	bmpreader(char *picaddr);\r\n	void showRgbtag(RGBQUAD &colors);\r\n	void showBmpHead(BITMAPFILEHEADER &pBmpHead);\r\n	void showBmpInforHead(BITMAPINFODEADER &pBmpInforHead);\r\n};\r\n\r\nvoid bmpreader::showRgbtag(RGBQUAD &colors){\r\n		cout<<"Blue:"<<colors.rgbBlue<<endl;\r\n		cout<<"Green:"<<colors.rgbGreen<<endl;\r\n		cout<<"Red:"<<colors.rgbRed<<endl;\r\n}\r\n\r\nvoid bmpreader::showBmpHead(BITMAPFILEHEADER &pBmpHead){    \r\n    //cout<<"位图文件头:"<<endl;    \r\n    //cout<<"文件头类型:"<<pBmpHead.bfType<<endl;    \r\n    cout<<"文件大小:"<<pBmpHead.bfSize<<endl;    \r\n    //cout<<"保留字_1:"<<pBmpHead.bfReserved1<<endl;    \r\n    //cout<<"保留字_2:"<<pBmpHead.bfReserved2<<endl;    \r\n    cout<<"实际位图数据的偏移字节数:"<<pBmpHead.bfOffBits<<endl<<endl;    \r\n}    \r\n                                                          \r\nvoid bmpreader::showBmpInforHead(BITMAPINFODEADER &pBmpInforHead){    \r\n    //cout<<"位图信息头:"<<endl;    \r\n    //cout<<"结构体的长度:"<<pBmpInforHead.biSize<<endl;    \r\n    //cout<<"位图宽:"<<pBmpInforHead.biWidth<<endl;    \r\n    //cout<<"位图高:"<<pBmpInforHead.biHeight<<endl;    \r\n    //cout<<"biPlanes平面数:"<<pBmpInforHead.biPlanes<<endl;    \r\n    cout<<"biBitCount采用颜色位数:"<<pBmpInforHead.biBitCount<<endl;    \r\n    //cout<<"压缩方式:"<<pBmpInforHead.biCompression<<endl;    \r\n    cout<<"biSizeImage实际位图数据占用的字节数:"<<pBmpInforHead.biSizeImage<<endl;    \r\n    //cout<<"X方向分辨率:"<<pBmpInforHead.biXPelsPerMeter<<endl;    \r\n    //cout<<"Y方向分辨率:"<<pBmpInforHead.biYPelsPerMeter<<endl;    \r\n    //cout<<"使用的颜色数:"<<pBmpInforHead.biClrUsed<<endl;    \r\n    //cout<<"重要颜色数:"<<pBmpInforHead.biClrImportant<<endl;    \r\n}\r\n\r\nbmpreader::bmpreader(char *picaddr){\r\n	FILE *fp = fopen(picaddr, "rb");  	\r\n	int palesize = 0;\r\n	fread(&head,sizeof(BITMAPFILEHEADER),1,fp);  \r\n	fread(&info,sizeof(BITMAPINFODEADER),1,fp);  \r\n	switch(info.biBitCount){\r\n	    case 1:\r\n		palesize = 2;\r\n		break;\r\n	    case 4:\r\n		palesize = 16;\r\n		break;\r\n	    case 8:\r\n		palesize = 256;\r\n		break;\r\n	}\r\n	if(palesize){\r\n	    	cout<<"存在RGBQUAD.."<<endl;\r\n		fread(&colors,1,palesize*sizeof(RGBQUAD),fp);\r\n	}else{\r\n		cout<<"不存在RGBQUAD.."<<endl;\r\n	}\r\n	//showBmpHead(head);  \r\n	//showBmpInforHead(info);  \r\n	//showRgbtag(colors);\r\n	int PicData = info.biSizeImage;\r\n	if(!palesize){\r\n		int tempsize = info.biBitCount/8;\r\n		tempsize = tempsize*64;\r\n		if(PicData%tempsize){\r\n			PicData = PicData + PicData%tempsize;\r\n			cout<<PicData<<"----"<<tempsize<<endl;\r\n		}\r\n		Bnum = PicData/tempsize;\r\n	}else{\r\n		if(PicData%64){\r\n			PicData = PicData + PicData%64;\r\n			cout<<PicData<<"---"<<"64"<<endl;\r\n		}	\r\n		Bnum = PicData/64;\r\n	}\r\n        //PicS = (char*)malloc(PicData);\r\n	csize = PicData;\r\n	picH = info.biHeight;\r\n	picW = info.biWidth;\r\n	PicS = (unsigned char*)new unsigned char[PicData];\r\n	memset(PicS,0,PicData);\r\n	fread(PicS,1,info.biSizeImage,fp);\r\n	if(feof(fp) == 0)\r\n	    cout<<"All in.."<<endl;\r\n	fclose(fp);  \r\n}\r\n</pre>\r\nrepic.c\r\n<pre lang="c" colla="-">\r\n#include "repic.h"\r\n\r\nvoid Xprod(BYTE k[16],float pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\nvoid Arrydisplay(float arr[16]){\r\n	for(int i = 0;i<16;i++){\r\n		cout<<i<<"-:-"<<arr[i]<<"  ";\r\n	}\r\n	cout<<endl;\r\n}\r\nfloat f(float xi,float x){\r\n	float y;\r\n	y = 8*xi*xi*xi*xi - 8*x*x + 1;//大于一定次数后，产生的K值一定。。果然要用俩方程么。。。\r\n	if(y < 0)\r\n	    y =-y;\r\n	//y = 3.9999 * xi * ( 1 - xi);\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(float pk[16],float nk[16],float xinput,int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RLSplit(float nk,WORD tempL[16],int j){\r\n	int y;\r\n	memcpy(&y,&nk,4);\r\n	y = y&0x00ffff00;\r\n	unsigned int tk;\r\n	memcpy(&tk,&y,4);\r\n	tk = tk>>8;\r\n	memcpy(&tempL[j],&tk,2);\r\n}\r\n\r\nWORD F(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&b)|((~a)&c))+d)%256;\r\n	return tempx;\r\n}\r\nWORD G(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = (((a&c)|((~c)&b))+d)%256;\r\n	return tempx;\r\n}\r\nWORD H(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((a^b^c)+d)%256;\r\n	return tempx;\r\n}\r\nWORD I(WORD a,WORD b,WORD c,WORD d){\r\n	WORD tempx;\r\n	tempx = ((b^(a|(~c)))+d)%256;\r\n	return tempx;\r\n}\r\n\r\n\r\nvoid SLProd(WORD tempL[16],WORD tmpL[16]){\r\n	for(int i = 0;i < 4;i++){\r\n		tmpL[(4*i)%16] = F(tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16]);\r\n		tmpL[(4*i+1)%16] = G(tempL[(4*i+1)%16],tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16]);\r\n		tmpL[(4*i+2)%16] = H(tempL[(4*i+2)%16],tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16]);\r\n		tmpL[(4*i+3)%16] = I(tempL[(4*i+3)%16],tempL[(4*i)%16],tempL[(4*i+1)%16],tempL[(4*i+2)%16]);\r\n	}	\r\n}\r\n\r\nvoid RLSave(int i,WORD tempL[16],BYTE *RL/*[192]*/){\r\n    	WORD tpk;\r\n	for(int k = 0;k < 16;k++){\r\n		//RL[16*i+k] = tempL[k]&0x00ff;\r\n		tpk = tempL[k]&0x00ff;\r\n		memcpy(&RL[16*i+k],&tpk,2);\r\n	}	\r\n}\r\n\r\nvoid RLProd(float pk[16],float nk[16],BYTE *RL/*[192]*/,int eachtime,float xinput){\r\n    	WORD tempL[16];\r\n	WORD tmpL[16];\r\n	for(int i = 0;i < eachtime/16 ;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j],xinput) + e * f(pk[(j+1)%16],xinput);\r\n			RLSplit(nk[j],tempL,j);\r\n		}\r\n		SLProd(tempL,tmpL);\r\n		RLSave(i,tmpL,RL);\r\n		memset(tempL,0,16*sizeof(WORD));\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nBYTE cycR(BYTE a,BYTE b){\r\n    a = (a<<(8 - b))|(a>>b);\r\n    return a;\r\n}\r\n\r\nBYTE LSB(BYTE c){\r\n	BYTE tc = c & 0x07;\r\n	return tc;\r\n}\r\n\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	float Xinput = 0.723812;//方程还是先选用Logistic方程，至少还是决定用一个方程的时候,输入K获得x[0](i)即16个盒子的初始值\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	float pk[16];//迭代前的各个盒子值\r\n	float nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	unsigned char picG;//可能的灰度值，整体的\r\n	int KL;//置换中的对比值\r\n	int r;\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d\\n",eachtime);\r\n	BYTE cpics[picS];//加密后\r\n	memset(cpics,0,picS);\r\n	BYTE RL[eachtime];//每次的随机序列\r\n	memset(RL,0,eachtime);\r\n	//cout<<"please input a key float x ..(0.123456 for example.)"<<endl;\r\n	//cin>>Xinput;\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	picG = 0xff;\r\n	//cout<<"Please input the PicGreyvalue"<<endl;\r\n	//cin>>picG;\r\n	//printf("PicGrayValue is %d \\n",picG);\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,Xinput,50);\r\n\r\n	//计算KL等信息\r\n	KL = (KeyInput[0]^KeyInput[1]^KeyInput[2]^KeyInput[3]^KeyInput[4]^KeyInput[5]^KeyInput[6]^KeyInput[7]^KeyInput[8]^KeyInput[9]^KeyInput[10]^KeyInput[11]^KeyInput[12]^KeyInput[13]^KeyInput[14]^KeyInput[15])*pict.Bnum/256;\r\n	printf("PicKL %d \\n",KL);\r\n	r = (KeyInput[8]+KeyInput[9]+KeyInput[10]+KeyInput[11]+KeyInput[12]+KeyInput[13]+KeyInput[14]+KeyInput[15])%pict.csize;\r\n\r\n	//产生一块用的随机序列～\r\n	RLProd(pk,nk,RL,eachtime,Xinput);\r\n	//正常序列产生和循环移位与取位函数测试输出\r\n	/*RLProd(pk,nk,RL,eachtime,Xinput);\r\n	for(int s = 0;s <eachtime;s++){\r\n		printf("%x\\t",RL[s]);\r\n		if((s%10 == 0)&&(s!=0))\r\n		    printf("\\n");\r\n	}\r\n	printf("\\n");*/\r\n	\r\n	BYTE LCL[24];\r\n	BYTE picheck[bnum];\r\n	BYTE BK[eachtime];\r\n	BYTE CK[eachtime];\r\n	BYTE RSL,RSR;\r\n	int Knew;\r\n	int d,tx;\r\n	memset(picheck,0,bnum);\r\n	memcpy(LCL,KeyInput+8,8);\r\n	memcpy(LCL+8,KeyInput+8,8);\r\n	memcpy(LCL+16,KeyInput+8,8);\r\n	for(int k = 0;k < bnum ; k++){\r\n	    	Knew = (int)(nk[0]*bnum);\r\n		if(k != bnum-1){\r\n		while((Knew == KL)|(picheck[Knew]!=0))\r\n			Knew = (Knew + 1)%bnum;\r\n		//cout<<Knew<<"  ";\r\n		memcpy(CK,pict.PicS+eachtime*Knew,eachtime);\r\n		picheck[Knew] = 1;\r\n		}else{\r\n			memcpy(CK,pict.PicS+eachtime*KL,eachtime);\r\n			picheck[KL] = 1;\r\n		}\r\n		for(int i = 0 ; i < 8 ; i ++){\r\n			for(int j = 0 ; j < 8 ; j++){\r\n				for(int n = 0 ; n < 3 ; n++){\r\n					/*RSR = LSB(LCL[3*((j-1)%8)+n]^RL[3*(8*i+j)+n]);\r\n					RSL = cycR(CK[3*(8*i+j)+n],RSR);\r\n					BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^(RSL-LCL[3*j+n]+picG)%picG;*/\r\n				    	//BK[3*(8*i+j)+n] = RL[3*(8*i+j)+n]^CK[3*(8*i+j)+n];\r\n					RSR = LSB(LCL[3*j+n]);\r\n					RSL = CK[3*(8*i+j)+n]^RL[3*(8*i+j)+n];\r\n					BK[3*(8*i+j)+n] = cycR(RSL,RSR);\r\n				}\r\n			}\r\n			memcpy(LCL,CK+8*i,24);\r\n		}\r\n		memcpy(cpics+eachtime*k,BK,eachtime);\r\n		/*d = LSB(LCL[0]);\r\n		//cout<<d<<"  ";\r\n		for(int y = 0 ; y < 4 ; y ++){\r\n			if(LCL[y]>LCL[(y+d)%8]){\r\n				tx = nk[y];\r\n				nk[y] = nk[(y+d)%8];\r\n				nk[(y+d)%8] = tx;	\r\n			}\r\n		}*/\r\n		for(int m=0 ; m<16 ; m++)\r\n		    pk[m] = nk[m];\r\n		RLProd(pk,nk,RL,eachtime,Xinput);\r\n		//Arrydisplay(nk);\r\n	}\r\n\r\n	picS = picH*picW*3;\r\n	pict.info.biSizeImage = picS;\r\n	pict.head.bfSize = picS + 54;\r\n	FILE *rfp = fopen("repic.bmp","wb");\r\n	fwrite(&pict.head,1,14,rfp);\r\n	fwrite(&pict.info,1,40,rfp);\r\n	fwrite(cpics,1,picS,rfp);\r\n	fclose(rfp);\r\n	return 0;  \r\n}\r\n</pre>', 'pichandle&repic for last', '', 'inherit', 'open', 'open', '', '108-revision-2', '', '', '2013-05-06 06:32:30', '2013-05-06 06:32:30', '', 108, 'http://codeseeking.sinaapp.com/?p=158', 0, 'revision', '', 0),
(159, 1, '2013-05-10 19:17:14', '2013-05-10 19:17:14', '<pre lang="c" colla="-">\r\n#include "picread.h"\r\n\r\nvoid Xprod(BYTE k[16],double pk[16]){\r\n	for(int i = 0;i < 16;i++){\r\n	    pk[i] = ((int)k[i]+0.1)/256;\r\n	}\r\n}\r\n\r\ndouble f(double x){\r\n	double y;\r\n	//y = 8*x*x*x*x-8*x*x+1;\r\n	y = 8*pow(x,4)-8*pow(x,2)+1;\r\n	return y;	\r\n}\r\n\r\nvoid NKProd(double pk[16],double nk[16],int times){\r\n	for(int i = 0;i < times;i++){\r\n		for(int j = 0;j < 16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]);\r\n		}\r\n		for(int k = 0;k<16;k++)\r\n		    pk[k] = nk[k];\r\n	}\r\n}\r\n\r\nvoid RtoY(BYTE *BK,double *YUV,int eachtime){\r\n    	int i = 0;\r\n	while(i<eachtime){\r\n		BYTE r,g,b;\r\n		r = BK[i+0];\r\n		g = BK[i+1];\r\n		b = BK[i+2];\r\n		YUV[i+0] = (double)((r*0.256789 + g*0.504129 + b*0.097906) + 16);\r\n		YUV[i+1] = (double)((r*(-0.148223) + g*(-0.290992) + b*0.439215) + 128);\r\n		YUV[i+2] = (double)((r*0.439215 + g*(-0.367789) + b*(-0.071426)) + 128);\r\n		i = i+3;	\r\n	}\r\n}\r\n\r\nvoid rlProd(double pk[16],double nk[16],double *LR,int eachtime){\r\n	for(int i=0;i<eachtime/16;i++){\r\n		for(int j=0;j<16;j++){\r\n			nk[j] = (1 - e) * f(pk[j]) + e * f(pk[(j+1)%16]); \r\n		}\r\n		for(int k=0;k<16;k++){\r\n			LR[16*i+k] = nk[k]/2;\r\n			if((nk[k]/2 <-0.5)|(nk[k]/2)>0.5)\r\n			    cout<<"有超范围的映射"<<endl;\r\n			pk[k] = nk[k];\r\n		}\r\n	}\r\n}\r\n\r\nvoid LProd(double *rla,double *L){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(i==0){//这里老是为0\r\n					L[64*k+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rla[64*k+j])/16);\r\n				}else{\r\n					L[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rla[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\nvoid RProd(double *rlb,double *R){\r\n    	for(int k=0;k<3;k++){\r\n		for(int i=0;i<8;i++){\r\n			for(int j=0;j<8;j++){\r\n				if(j==0){\r\n					R[64*k+8*i+j] = (1/(2*sqrt(2)))*cos(pi*((2*j+1)*rlb[64*k+j])/16);\r\n				}else{\r\n					R[64*k+8*i+j] = 0.5*cos(pi*((2*j+1)*(i+rlb[64*k+8*i+j]))/16);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nint main( int argc, char **argv )  \r\n{  \r\n	bmpreader pict(argv[1]);//实例一个bmp读取类，获得相应的信息头和像素数据，并根据不同大小的像素位进行填充图像\r\n	BYTE KeyInput[16];//输入的密钥，传送走的密钥\r\n	double pk[16];//迭代前的各个盒子值\r\n	double nk[16];//迭代后的各个盒子值\r\n	int picH = pict.picH;\r\n	int picW = pict.picW;//原始图的高宽\r\n	int picS = pict.csize;//填充后的整体大小\r\n	int bnum = pict.Bnum;//分块数\r\n	int eachtime = picS/bnum;\r\n	printf("each time = %d Num = %d\\n",eachtime,bnum);\r\n	//BYTE RL[eachtime];//每次的随机序列\r\n	//RL 得变成double的了。。方便运算么\r\n	cout<<"Please input a Keyline...(16byte-128bit)"<<endl;\r\n	cout<<"1234567890123456<-Here the ending is.."<<endl;\r\n	cin>>KeyInput;\r\n	//获得x初始盒子，迭代times次，消除。。\r\n	Xprod(KeyInput,pk);\r\n	NKProd(pk,nk,500);\r\n	//然后产生随机序列并映射到（-0.5，0.5）直接利用混沌盒子的值！？yes!!(8x4-8x2+1)~(-1,1)的，直接处理出来就好了\r\n	BYTE BK[eachtime];\r\n	double YUV[eachtime];\r\n	double rla[eachtime];\r\n	double rlb[eachtime];\r\n	double L[eachtime];\r\n	double R[eachtime];\r\n	MatrixXd Lym(8,8);\r\n	MatrixXd Rym(8,8);\r\n	MatrixXd Lum(8,8);\r\n	MatrixXd Rum(8,8);\r\n	MatrixXd Lvm(8,8);\r\n	MatrixXd Rvm(8,8);\r\n	MatrixXd Xym(8,8);\r\n	MatrixXd Xum(8,8);\r\n	MatrixXd Xvm(8,8);\r\n	MatrixXd Yym(8,8);\r\n	MatrixXd Yum(8,8);\r\n	MatrixXd Yvm(8,8);\r\n	\r\n	for(int k = 0 ; k < bnum ; k++){\r\n		memcpy(BK,pict.PicS+k*eachtime,eachtime);\r\n		//RGB to YUV\r\n		RtoY(BK,YUV,eachtime);\r\n		//一次产生a b 以计算出L & R\r\n		rlProd(pk,nk,rla,eachtime);\r\n		rlProd(pk,nk,rlb,eachtime);\r\n		//L&R \r\n		LProd(rla,L);\r\n		RProd(rlb,R);\r\n		for(int i=0;i<8;i++){\r\n		    for(int j=0;j<8;j++){\r\n		    	Xym(i,j) = YUV[3*(8*i+j)+0];\r\n			Xum(i,j) = YUV[3*(8*i+j)+1];\r\n			Xvm(i,j) = YUV[3*(8*i+j)+2];\r\n			Lym(i,j) = L[3*(8*i+j)+0];\r\n			Lum(i,j) = L[3*(8*i+j)+1];\r\n			Lvm(i,j) = L[3*(8*i+j)+2];\r\n			Rym(i,j) = R[3*(8*i+j)+0];\r\n			Rum(i,j) = R[3*(8*i+j)+1];\r\n			Rvm(i,j) = R[3*(8*i+j)+2];\r\n\r\n		    }\r\n		}//得到YUV三个分量的X矩阵,3个L&R\r\n		Yym = Lym*Xym*Rym;\r\n		Yum = Lum*Xum*Rum;\r\n		Yvm = Lvm*Xvm*Rvm;\r\n		/*if(k%100 == 0){\r\n		    	cout<<Lym<<endl<<Lum<<endl<<Lvm<<endl<<Rym<<endl<<Rum<<endl<<Rvm<<endl;\r\n			cout<<k<<"::"<<endl<<"yym:"<<endl<<Yym<<endl<<"yum:"<<endl<<Yum<<endl<<"yvm:"<<endl<<Yvm<<endl;\r\n		}*/\r\n\r\n	}\r\n	\r\n	return 0;  \r\n}\r\n</pre>', '非均匀dct尝试', '', 'inherit', 'open', 'open', '', '118-revision-4', '', '', '2013-05-10 19:17:14', '2013-05-10 19:17:14', '', 118, 'http://codeseeking.sinaapp.com/?p=159', 0, 'revision', '', 0),
(160, 1, '2013-05-25 16:55:48', '2013-05-25 16:55:48', '其实，不知道从何时开始，我动摇了。\r\n\r\n其实，不知道从何时开始，我怯弱了。\r\n\r\n&nbsp;\r\n\r\n但是，貌似这一切不能因为我的动摇怯弱而结束。\r\n\r\n曾经的话我还记得，曾经的痕迹我还留着，曾经的感觉，或许你能在别人那里得到。\r\n\r\n我没有资格再去说，回来吧，我们还能怎么怎么样。\r\n\r\n我其实挺确信你做这一切只是为了自己不后悔。\r\n\r\n直到。看了你写的东西，虐心么。是啊，可是我又能说些什么呢。\r\n\r\n&nbsp;\r\n\r\n或许一切真的是我命中注定，2012-2013，我永远都不能忘记的日子。\r\n\r\n不管是妈妈的车祸。老爹的伤病。老太太的病情。\r\n\r\n这一切我只能一直压着，压着。\r\n\r\n我怕，我的悲桑会传染给你，因为你总是那么在意我。\r\n\r\n我怕，我的无力也会让你无力。\r\n\r\n我怕，怕你因为这些而再次面对高考失利的那种绝望。\r\n\r\n&nbsp;\r\n\r\n我走，是因为我选择变了。\r\n\r\n我走，是因为我在崩溃的边缘了。\r\n\r\n我走，是因为放心你应经踏入成功了。\r\n\r\n我走，是因为那些客观的主观的原因。\r\n\r\n我走，是因为我自卑了、觉得自己不再值得了。\r\n\r\n&nbsp;\r\n\r\n或许，这才是伤害的开始吧。\r\n\r\n我不嫌你矮，但是我担心。\r\n\r\n我不是受不了你，只是受不了我妈。\r\n\r\n是我赶走了你，说着人话，干着不是人的事。\r\n\r\n&nbsp;\r\n\r\n当我知道你留下的答案。\r\n\r\n我不知道该说什么。\r\n\r\n或许我一直走下来的这条路才是让你找到幸福的路吧。\r\n\r\n或许我一直强忍着不妥协才是正确的吧。\r\n\r\n但当我看到你写的中间的那些话。\r\n\r\n我想。\r\n\r\n我想给你你本该有的一切。\r\n\r\n我想给你不一样的答案。\r\n\r\n我想。\r\n\r\n&nbsp;\r\n\r\n其实我不知道我再去做这个决定会有什么用。\r\n\r\n我不觉得我还有什么值得你去坚持。\r\n\r\n&nbsp;\r\n\r\n看天意了吧。\r\n\r\n如果我放弃放弃了。\r\n\r\n便是你做到了。\r\n\r\n如果你放弃不放弃了。\r\n\r\n便是我做到了。\r\n\r\n&nbsp;', '其实。', '', 'inherit', 'open', 'open', '', '126-revision-2', '', '', '2013-05-25 16:55:48', '2013-05-25 16:55:48', '', 126, 'http://codeseeking.sinaapp.com/?p=160', 0, 'revision', '', 0),
(163, 1, '2014-05-21 08:35:11', '2014-05-21 08:35:11', '斯坦福Ng ML 简单总结 待更新', 'MLearning summary', '', 'publish', 'open', 'open', '', 'mlearning-summary', '', '', '2014-06-06 03:12:13', '2014-06-06 03:12:13', '', 0, 'http://codeseeking.sinaapp.com/?p=163', 0, 'post', '', 0),
(164, 1, '2014-05-21 08:34:39', '2014-05-21 08:34:39', '', 'MLearning summarization', '', 'inherit', 'open', 'open', '', '163-revision', '', '', '2014-05-21 08:34:39', '2014-05-21 08:34:39', '', 163, 'http://codeseeking.sinaapp.com/?p=164', 0, 'revision', '', 0),
(165, 1, '2014-05-27 07:30:44', '2014-05-27 07:30:44', 'first of all , 关于import module && from module import * 的区别，前者在使用module中导入的东西的时候需要加上模块名的限定，而后者则不需要，如果使用前者导入而用了后者的使用，则会返回 ''module'' object is not callable 的错误。\r\n再者，python中的for循环是for xx in xx 这种，而没有那种指定数字的循环，所以可以利用某个1ton 的数组来in以下！？有点贱..我用的是in+list.pop最后看大小来发现到哪里了，但是这样可能会产生从空list中pop的问题', 'python 初coding', '', 'publish', 'open', 'open', '', 'python-%e5%88%9dcoding', '', '', '2014-06-06 08:58:13', '2014-06-06 08:58:13', '', 0, 'http://codeseeking.sinaapp.com/?p=165', 0, 'post', '', 0),
(166, 1, '2014-05-27 07:30:20', '2014-05-27 07:30:20', 'first of all , 关于import module && from module import * 的区别，前者在使用module中导入的东西的时候需要加上模块名的限定，而后者则不需要，如果使用前者导入而用了后者的使用，则会返回 ''module'' object is not callable 的错误。\n再者，python中的for循环是for xx in xx 这种，而没有那种指定数字的循环，所以可以利用某个1ton 的数组来in以下！？有点贱..我用的是in+list.pop最后看大小来发现到哪里了，但是这样可能会产生从看哦', 'python 初coding', '', 'inherit', 'open', 'open', '', '165-revision', '', '', '2014-05-27 07:30:20', '2014-05-27 07:30:20', '', 165, 'http://codeseeking.sinaapp.com/?p=166', 0, 'revision', '', 0),
(179, 1, '2014-06-06 02:22:13', '2014-06-06 02:22:13', '再次遇到yield，三个函数嵌套，一个yield一个，当时纠结在是一个进去还是。？后来发现是自己多想了，如果另外一个没有for in的话，那么yield也不能自动调用yield.next了，所以，在整体看的时候还是将它看成是list比较好理解，具体的用，对于里层函数的yield肯定还是每次返回一个然后暂停在那，但是对于外层的for in 可以看成接受到整个，但是每次其实也只有一个进来，next 是自动调用的。所以每次不要去纠到底进来多少个数据了。\r\n至于到底好用不好用，我也说不清楚，至少我觉得如果直接list全整出来也是一样，而且重点在于对于一个已知list去寻找那些count等的操作真的就是index+...？还是要亲自去试下阿。', 'yield 再遇到', '', 'publish', 'open', 'open', '', 'yield-%e5%86%8d%e9%81%87%e5%88%b0', '', '', '2014-06-06 02:22:13', '2014-06-06 02:22:13', '', 0, 'http://codeseeking.sinaapp.com/?p=179', 0, 'post', '', 0),
(168, 1, '2014-05-28 02:03:07', '2014-05-28 02:03:07', '一般使用的命令，一点点增加吧\r\n<pre lang="shell" colla="+">\r\nunzip xx.zip #解压至当前文件夹内\r\ntar -zxvf xxx.tar.gz #解压至当前文件夹内\r\nunzip/tar ..  xxx....  /dir #解压到dir内\r\n\r\ncd .. 进入 ~/ #当前用户home  .. 上层  \r\nmkdir #create a new dir\r\nrm -rf ... # -r 向下递归，自文件什么的都删除 -f 直接强行删除\r\nrm -rf dir/* #删除文件夹内所有文件 然后\r\nrm -rf dir #删除文件夹\r\n\r\ncp dir1/.../file1 dir2/.../ #复制\r\nmv dir1/.../file1 dir2/.../ #剪切   *表示将dir下所有复制或者剪切\r\n\r\n重命名这点其实就是剪切 \r\nmv dir/../file dir/.../file'' #dir是一样的，将file换成file‘\r\n</pre>', 'ubuntu 命令（持续增加）', '', 'publish', 'open', 'open', '', 'ubuntu-%e5%91%bd%e4%bb%a4%ef%bc%88%e6%8c%81%e7%bb%ad%e5%a2%9e%e5%8a%a0%ef%bc%89', '', '', '2014-05-28 02:03:18', '2014-05-28 02:03:18', '', 0, 'http://codeseeking.sinaapp.com/?p=168', 0, 'post', '', 0),
(169, 1, '2014-05-28 02:02:13', '2014-05-28 02:02:13', '一般使用的命令，一点点增加吧\n<pre lang="shell" colla="+">\nunzip xx.zip #解压至当前文件夹内\ntar -zxvf xxx.tar.gz #解压至当前文件夹内\nunzip/tar ..  xxx....  /dir #解压到dir内\n\ncd .. 进入 ~/ #当前用户home  .. 上层  \nmkdir #create a new dir\nrm -rf ... # -r 向下递归，自文件什么的都删除 -f 直接强行删除\nrm -rf dir/* #删除文件夹内所有文件 然后\nrm -rf dir #删除文件夹\n\ncp dir1/.../file1 dir2/.../ #复制\nmv dir1/.../file1 dir2/.../ #剪切   *表示将dir下所有复制或者剪切\n\n重命名这点其实就是剪切 \nmv dir/../file dir/.../file'' #将f', 'ubuntu 命令（持续增加）', '', 'inherit', 'open', 'open', '', '168-revision', '', '', '2014-05-28 02:02:13', '2014-05-28 02:02:13', '', 168, 'http://codeseeking.sinaapp.com/?p=169', 0, 'revision', '', 0),
(170, 1, '2014-05-28 02:03:07', '2014-05-28 02:03:07', '一般使用的命令，一点点增加吧\r\n<pre lang="shell" colla="+">\r\nunzip xx.zip #解压至当前文件夹内\r\ntar -zxvf xxx.tar.gz #解压至当前文件夹内\r\nunzip/tar ..  xxx....  /dir #解压到dir内\r\n\r\ncd .. 进入 ~/ #当前用户home  .. 上层  \r\nmkdir #create a new dir\r\nrm -rf ... # -r 向下递归，自文件什么的都删除 -f 直接强行删除\r\nrm -rf dir/* #删除文件夹内所有文件 然后\r\nrm -rf dir #删除文件夹\r\n\r\ncp dir1/.../file1 dir2/.../ #复制\r\nmv dir1/.../file1 dir2/.../ #剪切   *表示将dir下所有复制或者剪切\r\n\r\n重命名这点其实就是剪切 \r\nmv dir/../file dir/.../file'' #dir是一样的，将file换成file‘', 'ubuntu 命令（持续增加）', '', 'inherit', 'open', 'open', '', '168-revision-2', '', '', '2014-05-28 02:03:07', '2014-05-28 02:03:07', '', 168, 'http://codeseeking.sinaapp.com/?p=170', 0, 'revision', '', 0),
(171, 1, '2014-05-29 00:06:25', '2014-05-29 00:06:25', 'I 对于知识图谱的初步认识总结\r\nII 对于知识图谱的研究方向的认识\r\n\r\nI：\r\n	知识图谱旨在描述真实世界中存在的各种实体或概念。其中每个实体或概念用一个全局唯一确定的标示ID（identifier）。\r\n	每个属性-值对（attribute-value pair AVP）用来刻画实体的内在特性，而关系用来联系两个实体。\r\n	知识卡片（knowledge card），旨在为用户提供更多与搜索内容相关的信息，具体便是为用户查询中所包含的实体或返回的答案提供详细的结构化摘要。\r\nII:\r\n	知识图谱的构建\r\n	1 规模\r\n		实体和事实（形如实体-属性-值，实体-关系-实体）\r\n	2 数据来源\r\n		高质量的常识性知识(百科类站点和各种垂直站点的结构化数据）（质量高，更新慢）\r\n		半结构化数据中进行数据挖掘，发现新的实体或事实（数据更大，更能反映当前用户需求但质量相对较差且存在一定的错误）（评估，审核）\r\n		a. 百科类（维基百科/freebase）\r\n		b. 结构化数据（新旧的实体对齐/Deep web ..）\r\n		c. 半结构化数据挖掘AVP（长尾化/主动学习）\r\n		d. 搜索日志等挖掘（实时性/Bootstrapping多类别协同模式学习）\r\n	3 抽取图谱（extraction graphs）到知识图谱\r\n		a. 实体对齐（object alignment）\r\n			发现具有不同id却代表同一对象的实体，并将这些实体归并为一个具有全局唯一标识的实体对象加入到知识图谱中。（聚类）（定义合适的相似度度量）\r\n		b. 知识图谱schema构建\r\n			以上多是数据层（data level），而模式是对知识的提炼，模式层（schema level），遵循预先给定的schema有助于知识的标准化，有利于查询后续处理。构建schema相当于为其建立本体（ontology），最基本的本体包括概念/概念层次/属性/属性值类型/关系/关系定义域（domain）概念集以及关系值域（range）概念集。在此基础上可以添加规则（rules）或者公理（axioms）表示模式层更复杂的约束关系。\r\n		ps:freebase的模式定义了domain（领域），type（类别）和topic（主题即实体）。每个domain有若干types，每个type包含多个topics且和多个properties关联，这些properties规定了当前type的那些topics需要包含的属性和关系。\r\n		c. 不一致性（充分考虑数据源的可靠性以及不同信息在各个数据源中出现的频度因素）\r\n		d. 知识图谱上的挖掘\r\n			推理（reasoning or inference）\r\n			实体重要性排序\r\n			相关实体挖掘\r\nIII：\r\n	应用\r\n	查询理解（查询涉及的实体（概念）及其属性等根据实体重要性展现相应的知识卡片）\r\n	问题回答（直接返回答案）\r\n\r\nimportance:\r\n	结构化数据/更复杂的自然语言查询', '知识图谱（笔记）', '', 'publish', 'open', 'open', '', '%e7%9f%a5%e8%af%86%e5%9b%be%e8%b0%b1%ef%bc%88%e7%ac%94%e8%ae%b0%ef%bc%89', '', '', '2014-05-29 00:06:25', '2014-05-29 00:06:25', '', 0, 'http://codeseeking.sinaapp.com/?p=171', 0, 'post', '', 0),
(172, 1, '2014-05-29 00:06:00', '2014-05-29 00:06:00', 'I 对于知识图谱的初步认识总结\nII 对于知识图谱的研究方向的认识\n\nI：\n	知识图谱旨在描述真实世界中存在的各种实体或概念。其中每个实体或概念用一个全局唯一确定的标示ID（identifier）。\n	每个属性-值对（attribute-value pair AVP）用来刻画实体的内在特性，而关系用来联系两个实体。\n	知识卡片（knowledge card），旨在为用户提供更多与搜索内容相关的信息，具体便是为用户查询中所包含的实体或返回的答案提供详细的结构化摘要。\nII:\n	知识图谱的构建\n	1 规模\n		实体和事实（形如实体-属性-值，实体-关系-实体）\n	2 数据来源\n		高质量的常识性知识(百科类站点和各种垂直站点的结构化数据）（质量高，更新慢）\n		半结构化数据中进行数据挖掘，发现新的实体或事实（数据更大，更能反映当前用户需求但质量相对较差且存在一定的错误）（评估，审核）\n		a. 百科类（维基百科/freebase）\n		b. 结构化数据（新旧的实体对齐/Deep web ..）\n		c. 半结构化数据挖掘AVP（长尾化/主动学习）\n		d. 搜索日志等挖掘（实时性/Bootstrapping多类别协同模式学习）\n	3 抽取图谱（extraction graphs）到知识图谱\n		a. 实体对齐（object alignment）\n			发现具有不同id却代表同一对象的实体，并将这些实体归并为一个具有全局唯一标识的实体对象加入到知识图谱中。（聚类）（定义合适的相似度度量）\n		b. 知识图谱schema构建\n			以上多是数据层（data level），而模式是对知识的提炼，模式层（schema level），遵循预先给定的schema有助于知识的标准化，有利于查询后续处理。构建schema相当于为其建立本体（ontology），最基本的本体包括概念/概念层次/属性/属性值类型/关系/关系定义域（domain）概念集以及关系值域（range）概念集。在此基础上可以添加规则（rules）或者公理（axioms）表示模式层更复杂的约束关系。\n		ps:freebase的模式定义了domain（领域），type（类别）和topic（主题即实体）。每个domain有若干types，每个type包含多个topics且和多个properties关联，这些properties规定了当前type的那些topics需要包含的属性和关系。\n		c. 不一致性（充分考虑数据源的可靠性以及不同信息在各个数据源中出现的频度因素）\n		d. 知识图谱上的挖掘\n			推理（reasoning or inference）\n			实体重要性排序\n			相关实体挖掘\nIII：\n	应用\n	查询理解（查询涉及的实体（概念）及其属性等根据实体重要性展现相应的知识卡片）\n	问题回答（直接返回答案）\n\nimportance:\n	结构化数据/更复杂的自然语言查询', '知识图谱（笔记）', '', 'inherit', 'open', 'open', '', '171-revision', '', '', '2014-05-29 00:06:00', '2014-05-29 00:06:00', '', 171, 'http://codeseeking.sinaapp.com/?p=172', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(173, 1, '2014-06-03 02:51:36', '2014-06-03 02:51:36', '问题出现，在读取统计一个training set中Count(y->x) 和 Count(y) Count(y1,y2)等的时候首先就遇到了yeild函数\r\n<pre lang="python" colla="-">\r\ndef simple_conll_corpus_iterator(corpus_file):\r\n    l = corpus_file.readline()\r\n    while l:\r\n        line = l.strip()\r\n        if line: \r\n            fields = line.split(" ")\r\n            ne_tag = fields[-1]\r\n            word = " ".join(fields[:-1])\r\n            yield word, ne_tag\r\n        else: \r\n            yield (None, None)                        \r\n        l = corpus_file.readline()\r\n</pre>\r\n要介绍yeild，首先需要了解iterator迭代器和constructor生成器：\r\n迭代器iterator\r\n在Python中，for循环可以用于Python中的任何类型，包括列表、元祖等等，实际上，for循环可用于任何“可迭代对象”，这其实就是迭代器迭代器是一个实现了迭代器协议的对象，Python中的迭代器协议就是有next方法的对象会前进到下一结果，而在一系列结果的末尾是，则会引发StopIteration。任何这类的对象在Python中都可以用for循环或其他遍历工具迭代，迭代工具内部会在每次迭代时调用next方法，并且捕捉StopIteration异常来确定何时离开。\r\n使用迭代器一个显而易见的好处就是：每次只从对象中读取一条数据，不会造成内存的过大开销。\r\n<pre lang="python" colla="+">\r\nfor line in open("test.txt").readlines():\r\n      print line\r\n</pre>\r\n<pre lang="python" colla="+">\r\nfor line in open("test.txt"):\r\n      print line\r\n</pre>\r\n第一种当然可以读取每行，但是它是将所有文件一次性读取至内存然后再逐行打印，这样占用内存过大，而第二种没有显示读取文件，而是利用迭代器每次读取一行。\r\n生成器constructor\r\n生成器函数在Python中与迭代器协议的概念联系在一起。简而言之，包含yield语句的函数会被特地编译成生成器。当函数被调用时，他们返回一个生成器对象，这个对象支持迭代器接口。函数也许会有个return语句，但它的作用是用来yield产生值的。不像一般的函数会生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行和状态，他的本地变量将保存状态信息，这些信息在函数恢复时将再度有效。\r\n<pre lang="python" colla="+">\r\ndef g(n):\r\n    for i in range(n):\r\n        yeild i**2\r\nfor i in g(5):\r\n    print i,":",\r\n0:1:4:9:16:\r\nps:t = g(5)\r\nt.next()    :0\r\nt.next()    :1 ...\r\n</pre>\r\n总结：yeild最好的好处就是节省内存！？\r\n\r\n从常用的fab(max)（斐波那契函数）说起，最简单的就是直接在函数中将b输出，但是这样函数的复用性较差，如果返回none其他函数不能获得该函数生成的数列，所以可以不直接打印而是返回一个数列，但是这样函数在运行的时候占用的内存会随着参数max的大小的增大而增大。所以要控制内存占用大小的时候，不能用list来存放中间结果，而应该使用iterator对象来迭代。\r\n<pre lang="python" colla="+">\r\nfor i in range(1000):pass\r\n#生成1000个数的list代码\r\nfor i in xrange(1000):pass\r\n#不会生成list，而是在每次迭代中返回下一个数值\r\n</pre>\r\nso:yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。当函数执行结束时，generator 自动抛出 StopIteration 异常，表示迭代完成。在 for 循环里，无需处理 StopIteration 异常，循环会正常结束。\r\n一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。\r\n在一个 generator function 中，如果没有 return，则默认执行至函数完毕，如果在执行过程中 return，则直接抛出 StopIteration 终止迭代。\r\n\r\nreference link: www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/', 'yield - python', '', 'publish', 'open', 'open', '', 'yield-python', '', '', '2014-06-03 02:52:06', '2014-06-03 02:52:06', '', 0, 'http://codeseeking.sinaapp.com/?p=173', 0, 'post', '', 0),
(174, 1, '2014-06-03 02:26:42', '2014-06-03 02:26:42', '<pre lang="python" colla="+">\n', 'yield - python', '', 'inherit', 'open', 'open', '', '173-revision', '', '', '2014-06-03 02:26:42', '2014-06-03 02:26:42', '', 173, 'http://codeseeking.sinaapp.com/?p=174', 0, 'revision', '', 0),
(175, 1, '2014-06-03 02:27:42', '2014-06-03 02:27:42', '<pre lang="python" colla="+">\ndef simple_conll_corpus_iterator(corpus_file):\n    l = corpus_file.readline()\n    while l:\n        line = l.strip()\n        if line: \n            fields = line.split(" ")\n            ne_tag = fields[-1]\n            word = " ".join(fields[:-1])\n            yield word, ne_tag\n        else: \n            yield (None, None)                        \n        l = corpus_file.readline()\n</pre>', 'yield - python', '', 'inherit', 'open', 'open', '', '173-revision-2', '', '', '2014-06-03 02:27:42', '2014-06-03 02:27:42', '', 173, 'http://codeseeking.sinaapp.com/?p=175', 0, 'revision', '', 0),
(176, 1, '2014-06-03 02:31:10', '2014-06-03 02:31:10', '问题出现，在读取统计一个training set中Count(y->x) 和 Count(y) Count(y1,y2)等的时候首先就遇到了yeild函数\r\n<pre lang="python" colla="-">\r\ndef simple_conll_corpus_iterator(corpus_file):\r\n    l = corpus_file.readline()\r\n    while l:\r\n        line = l.strip()\r\n        if line: \r\n            fields = line.split(" ")\r\n            ne_tag = fields[-1]\r\n            word = " ".join(fields[:-1])\r\n            yield word, ne_tag\r\n        else: \r\n            yield (None, None)                        \r\n        l = corpus_file.readline()\r\n</pre>\r\n要介绍yeild，首先需要了解iterator迭代器和constructor生成器：\r\n迭代器iterator\r\n在Python中，for循环可以用于Python中的任何类型，包括列表、元祖等等，实际上，for循环可用于任何“可迭代对象”，这其实就是迭代器迭代器是一个实现了迭代器协议的对象，Python中的迭代器协议就是有next方法的对象会前进到下一结果，而在一系列结果的末尾是，则会引发StopIteration。任何这类的对象在Python中都可以用for循环或其他遍历工具迭代，迭代工具内部会在每次迭代时调用next方法，并且捕捉StopIteration异常来确定何时离开。\r\n\r\n使用迭代器一个显而易见的好处就是：每次只从对象中读取一条数据，不会造成内存的过大开销。', 'yield - python', '', 'inherit', 'open', 'open', '', '173-revision-3', '', '', '2014-06-03 02:31:10', '2014-06-03 02:31:10', '', 173, 'http://codeseeking.sinaapp.com/?p=176', 0, 'revision', '', 0),
(177, 1, '2014-06-03 02:41:32', '2014-06-03 02:41:32', '问题出现，在读取统计一个training set中Count(y->x) 和 Count(y) Count(y1,y2)等的时候首先就遇到了yeild函数\r\n<pre lang="python" colla="-">\r\ndef simple_conll_corpus_iterator(corpus_file):\r\n    l = corpus_file.readline()\r\n    while l:\r\n        line = l.strip()\r\n        if line: \r\n            fields = line.split(" ")\r\n            ne_tag = fields[-1]\r\n            word = " ".join(fields[:-1])\r\n            yield word, ne_tag\r\n        else: \r\n            yield (None, None)                        \r\n        l = corpus_file.readline()\r\n</pre>\r\n要介绍yeild，首先需要了解iterator迭代器和constructor生成器：\r\n迭代器iterator\r\n在Python中，for循环可以用于Python中的任何类型，包括列表、元祖等等，实际上，for循环可用于任何“可迭代对象”，这其实就是迭代器迭代器是一个实现了迭代器协议的对象，Python中的迭代器协议就是有next方法的对象会前进到下一结果，而在一系列结果的末尾是，则会引发StopIteration。任何这类的对象在Python中都可以用for循环或其他遍历工具迭代，迭代工具内部会在每次迭代时调用next方法，并且捕捉StopIteration异常来确定何时离开。\r\n使用迭代器一个显而易见的好处就是：每次只从对象中读取一条数据，不会造成内存的过大开销。\r\n<pre lang="python" colla="+">\r\nfor line in open("test.txt").readlines():\r\n      print line\r\n</pre>\r\n<pre lang="python" colla="+">\r\nfor line in open("test.txt"):\r\n      print line\r\n</pre>\r\n第一种当然可以读取每行，但是它是将所有文件一次性读取至内存然后再逐行打印，这样占用内存过大，而第二种没有显示读取文件，而是利用迭代器每次读取一行。\r\n生成器constructor\r\n生成器函数在Python中与迭代器协议的概念联系在一起。简而言之，包含yield语句的函数会被特地编译成生成器。当函数被调用时，他们返回一个生成器对象，这个对象支持迭代器接口。函数也许会有个return语句，但它的作用是用来yield产生值的。不像一般的函数会生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行和状态，他的本地变量将保存状态信息，这些信息在函数恢复时将再度有效。\r\n<pre lang="python" colla="+">\r\ndef g(n):\r\n    for i in range(n):\r\n        yeild i**2\r\nfor i in g(5):\r\n    print i,":",\r\n0:1:4:9:16:\r\nps:t = g(5)\r\nt.next()    :0\r\nt.next()    :1 ...\r\n</pre>\r\n总结：yeild最好的好处就是节省内存！？\r\n', 'yield - python', '', 'inherit', 'open', 'open', '', '173-revision-4', '', '', '2014-06-03 02:41:32', '2014-06-03 02:41:32', '', 173, 'http://codeseeking.sinaapp.com/?p=177', 0, 'revision', '', 0),
(178, 1, '2014-06-03 02:51:36', '2014-06-03 02:51:36', '问题出现，在读取统计一个training set中Count(y->x) 和 Count(y) Count(y1,y2)等的时候首先就遇到了yeild函数\r\n<pre lang="python" colla="-">\r\ndef simple_conll_corpus_iterator(corpus_file):\r\n    l = corpus_file.readline()\r\n    while l:\r\n        line = l.strip()\r\n        if line: \r\n            fields = line.split(" ")\r\n            ne_tag = fields[-1]\r\n            word = " ".join(fields[:-1])\r\n            yield word, ne_tag\r\n        else: \r\n            yield (None, None)                        \r\n        l = corpus_file.readline()\r\n</pre>\r\n要介绍yeild，首先需要了解iterator迭代器和constructor生成器：\r\n迭代器iterator\r\n在Python中，for循环可以用于Python中的任何类型，包括列表、元祖等等，实际上，for循环可用于任何“可迭代对象”，这其实就是迭代器迭代器是一个实现了迭代器协议的对象，Python中的迭代器协议就是有next方法的对象会前进到下一结果，而在一系列结果的末尾是，则会引发StopIteration。任何这类的对象在Python中都可以用for循环或其他遍历工具迭代，迭代工具内部会在每次迭代时调用next方法，并且捕捉StopIteration异常来确定何时离开。\r\n使用迭代器一个显而易见的好处就是：每次只从对象中读取一条数据，不会造成内存的过大开销。\r\n<pre lang="python" colla="+">\r\nfor line in open("test.txt").readlines():\r\n      print line\r\n</pre>\r\n<pre lang="python" colla="+">\r\nfor line in open("test.txt"):\r\n      print line\r\n</pre>\r\n第一种当然可以读取每行，但是它是将所有文件一次性读取至内存然后再逐行打印，这样占用内存过大，而第二种没有显示读取文件，而是利用迭代器每次读取一行。\r\n生成器constructor\r\n生成器函数在Python中与迭代器协议的概念联系在一起。简而言之，包含yield语句的函数会被特地编译成生成器。当函数被调用时，他们返回一个生成器对象，这个对象支持迭代器接口。函数也许会有个return语句，但它的作用是用来yield产生值的。不像一般的函数会生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行和状态，他的本地变量将保存状态信息，这些信息在函数恢复时将再度有效。\r\n<pre lang="python" colla="+">\r\ndef g(n):\r\n    for i in range(n):\r\n        yeild i**2\r\nfor i in g(5):\r\n    print i,":",\r\n0:1:4:9:16:\r\nps:t = g(5)\r\nt.next()    :0\r\nt.next()    :1 ...\r\n</pre>\r\n总结：yeild最好的好处就是节省内存！？\r\n\r\n从常用的fab(max)（斐波那契函数）说起，最简单的就是直接在函数中将b输出，但是这样函数的复用性较差，如果返回none其他函数不能获得该函数生成的数列，所以可以不直接打印而是返回一个数列，但是这样函数在运行的时候占用的内存会随着参数max的大小的增大而增大。所以要控制内存占用大小的时候，不能用list来存放中间结果，而应该使用iterator对象来迭代。\r\n<pre lang="python" colla="+">\r\nfor i in range(1000):pass\r\n#生成1000个数的list代码\r\nfor i in xrange(1000):pass\r\n#不会生成list，而是在每次迭代中返回下一个数值\r\n</pre>\r\nso:yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。当函数执行结束时，generator 自动抛出 StopIteration 异常，表示迭代完成。在 for 循环里，无需处理 StopIteration 异常，循环会正常结束。\r\n一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。\r\n\r\nreference link: www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/\r\n在一个 generator function 中，如果没有 return，则默认执行至函数完毕，如果在执行过程中 return，则直接抛出 StopIteration 终止迭代。', 'yield - python', '', 'inherit', 'open', 'open', '', '173-revision-5', '', '', '2014-06-03 02:51:36', '2014-06-03 02:51:36', '', 173, 'http://codeseeking.sinaapp.com/?p=178', 0, 'revision', '', 0),
(180, 1, '2014-06-06 02:22:02', '2014-06-06 02:22:02', '再次遇到yield，三个函数嵌套，一个yield一个，当时纠结在是一个进去还是。？后来发现是自己多想了，如果另外一个没有for in的话，那么yield也不能自动调用yield.next了，所以，在整体看的时候还是将它看成是list比较好理解，具体的用，对于里层函数的yield肯定还是每次返回一个然后暂停在那，但是对于外层的for in 可以看成接受到整个，但是每次其实也只有一个进来，next 是自动调用的。所以每次不要去纠到底进来多少个数据了。\n至于到底好用不好用，我也说不清楚，至少我觉得如果直接list全整出来也是一样，而且重点在于对于一个已知list去寻找那些count等的操作真的就是index+...？还是要亲自去试下阿。', 'yield 再遇到', '', 'inherit', 'open', 'open', '', '179-revision', '', '', '2014-06-06 02:22:02', '2014-06-06 02:22:02', '', 179, 'http://codeseeking.sinaapp.com/?p=180', 0, 'revision', '', 0),
(181, 1, '2014-06-06 03:08:55', '2014-06-06 03:08:55', '正常下的n-yy n-dd yy dd + p是在vim中进行复制粘贴，需要从vim打开的文件中复制才可以\r\n但是有时候我们从外面复制的东西想要粘贴进去，只能用右键，粘贴，但是有时候格式缩进什么的都变了，这是因为设置的自动缩进等问题所以我们可以在粘贴外面文件的时候先， :set paste 进入粘贴模式，粘贴完 可以 :set nopaste 绑定快捷键也可以阿\r\n然而，还可以利用\r\n“+p\r\n来快速粘贴，它不考虑是否粘贴模式，是否自动缩进，直接原文粘贴。\r\nvim寄存器，就要从vim文件间的复制粘贴说起。\r\nVim中，若要复制当前行，普通模式下按 yy 即可，在要粘贴的地方按 p 。这是vim将复制内容保存到了自己的寄存器中的缘故。如果在其他地方执行yy，新的内容将覆盖掉原寄存器中内容。如果想保存原寄存器中内容而同时增加新的内容呢？这时就要在yy前增加标签了。标签以双引号开始，跟着的是标签名称，可以是数字0-9，也可以是26个字母，然后就是复制操作，这样就把复制内容保存到该标签寄存器里。通过下面命令显示所有寄存器内容：:\r\n:reg\r\n“ + 缓冲区标号 + p 就是粘贴出某个寄存器中间的\r\n其中注意两个特殊的寄存器：”* 和 “+。这两个寄存器是和系统相通的，前者关联系统选择缓冲区，后者关联系统剪切板。通过它们可以和其他程序进行数据交换。\r\n不同于Windows，<span style="color: #ff0000;">Linux系统里存在两个剪切板：一个叫做选择缓冲区(X11 selection buffer)，另一个才是剪切板(clipboard)。选择缓冲区是实时的，当使用鼠标或键盘选择内容时，内容已经存在于选择缓冲区了，这或许就是选择缓冲区的由来吧。可以使用<em><strong>鼠标中键</strong></em>或键入<em><strong>Shift+Insert</strong></em>来粘贴选择缓冲区的内容。但对于有些GUI程序，比如gedit，只能通过鼠标中键调用选择缓冲区的内容，使用Shift+Insert的话，调用的是剪切板的内容。</span>\r\n\r\n<span style="color: #0000ff;">相当有用阿！！！！！！</span>\r\n\r\n剪切板和Windows的剪切板类似，gnome-terminal，不能直接使用Ctrl+c，Ctrl+v，这时就要用Shift+Ctrl+c，Shift+Ctrl+v代替\r\n<ul class="simple">\r\n	<li>方案一：</li>\r\n</ul>\r\n<ol class="arabic simple">\r\n	<li>选择文本内容</li>\r\n	<li>vim普通模式下按 “*p 将选择缓冲区中内容粘贴进来</li>\r\n</ol>\r\n<ul class="simple">\r\n	<li>方案二：</li>\r\n</ul>\r\n<ol class="arabic simple">\r\n	<li>复制文件内容</li>\r\n	<li>vim普通模式下按 “+ p 将剪切板内容粘贴进来</li>\r\n</ol>\r\n但是，其实发现，在linux下或者vim里，利用选中，鼠标中键，来将缓冲区中的复制粘贴出来就很爽了阿。\r\n\r\nreferent link :www.cnblogs.com/jianyungsun/archive/2011/03/19/1988855.html', 'vim - 复制&粘贴', '', 'publish', 'open', 'open', '', 'vim-%e5%a4%8d%e5%88%b6%e7%b2%98%e8%b4%b4', '', '', '2014-06-06 03:13:39', '2014-06-06 03:13:39', '', 0, 'http://codeseeking.sinaapp.com/?p=181', 0, 'post', '', 0),
(182, 1, '2014-06-06 03:08:14', '2014-06-06 03:08:14', '正常下的n-yy n-dd yy dd + p是在vim中进行复制粘贴，需要从vim打开的文件中复制才可以\n但是有时候我们从外面复制的东西想要粘贴进去，只能用右键，粘贴，但是有时候格式缩进什么的都变了，这是因为设置的自动缩进等问题所以我们可以在粘贴外面文件的时候先， :set paste 进入粘贴模式，粘贴完 可以 :set nopaste 绑定快捷键也可以阿\n然而，还可以利用\n“+p\n来快速粘贴，它不考虑是否粘贴模式，是否自动缩进，直接原文粘贴。\nvim寄存器，就要从vim文件间的复制粘贴说起。\nVim中，若要复制当前行，普通模式下按 yy 即可，在要粘贴的地方按 p 。这是vim将复制内容保存到了自己的寄存器中的缘故。如果在其他地方执行yy，新的内容将覆盖掉原寄存器中内容。如果想保存原寄存器中内容而同时增加新的内容呢？这时就要在yy前增加标签了。标签以双引号开始，跟着的是标签名称，可以是数字0-9，也可以是26个字母，然后就是复制操作，这样就把复制内容保存到该标签寄存器里。通过下面命令显示所有寄存器内容：:\n:reg\n“ + 缓冲区标号 + p 就是粘贴出某个寄存器中间的\n其中注意两个特殊的寄存器：”* 和 “+。这两个寄存器是和系统相通的，前者关联系统选择缓冲区，后者关联系统剪切板。通过它们可以和其他程序进行数据交换。\n不同于Windows，Linux系统里存在两个剪切板：一个叫做选择缓冲区(X11 selection buffer)，另一个才是剪切板(clipboard)。选择缓冲区是实时的，当使用鼠标或键盘选择内容时，内容已经存在于选择缓冲区了，这或许就是选择缓冲区的由来吧。可以使用<span style="color: #00ffff;"><em><strong>鼠标中键</strong></em></span>或键入<span style="color: #00ffff;"><em><strong>Shift+Insert</strong></em></span>来粘贴选择缓冲区的内容。但对于有些GUI程序，比如gedit，只能通过鼠标中键调用选择缓冲区的内容，使用Shift+Insert的话，调用的是剪切板的内容。\n\n剪切板和Windows的剪切板类似，gnome-terminal，不能直接使用Ctrl+c，Ctrl+v，这时就要用Shift+Ctrl+c，Shift+Ctrl+v代替\n<ul class="simple">\n	<li>方案一：</li>\n</ul>\n<ol class="arabic simple">\n	<li>选择文本内容</li>\n	<li>vim普通模式下按 “*p 将选择缓冲区中内容粘贴进来</li>\n</ol>\n<ul class="simple">\n	<li>方案二：</li>\n</ul>\n<ol class="arabic simple">\n	<li>复制文件内容</li>\n	<li>vim普通模式下按 “+ p 将剪切板内容粘贴进来</li>\n</ol>\n\n但是，其实发现，在linux下或者vim里，利用选中，鼠标中键，来将缓冲区中的复制粘贴出来就很爽了阿。\n\nreferent link :www.cnblogs.com/jianyungsun/archive/2011/03/19/1988855.html', 'vim - 复制&粘贴', '', 'inherit', 'open', 'open', '', '181-revision', '', '', '2014-06-06 03:08:14', '2014-06-06 03:08:14', '', 181, 'http://codeseeking.sinaapp.com/?p=182', 0, 'revision', '', 0),
(190, 1, '2014-06-06 03:13:33', '2014-06-06 03:13:33', '正常下的n-yy n-dd yy dd + p是在vim中进行复制粘贴，需要从vim打开的文件中复制才可以\r\n但是有时候我们从外面复制的东西想要粘贴进去，只能用右键，粘贴，但是有时候格式缩进什么的都变了，这是因为设置的自动缩进等问题所以我们可以在粘贴外面文件的时候先， :set paste 进入粘贴模式，粘贴完 可以 :set nopaste 绑定快捷键也可以阿\r\n然而，还可以利用\r\n“+p\r\n来快速粘贴，它不考虑是否粘贴模式，是否自动缩进，直接原文粘贴。\r\nvim寄存器，就要从vim文件间的复制粘贴说起。\r\nVim中，若要复制当前行，普通模式下按 yy 即可，在要粘贴的地方按 p 。这是vim将复制内容保存到了自己的寄存器中的缘故。如果在其他地方执行yy，新的内容将覆盖掉原寄存器中内容。如果想保存原寄存器中内容而同时增加新的内容呢？这时就要在yy前增加标签了。标签以双引号开始，跟着的是标签名称，可以是数字0-9，也可以是26个字母，然后就是复制操作，这样就把复制内容保存到该标签寄存器里。通过下面命令显示所有寄存器内容：:\r\n:reg\r\n“ + 缓冲区标号 + p 就是粘贴出某个寄存器中间的\r\n其中注意两个特殊的寄存器：”* 和 “+。这两个寄存器是和系统相通的，前者关联系统选择缓冲区，后者关联系统剪切板。通过它们可以和其他程序进行数据交换。\r\n不同于Windows，<span style="color: #ff0000;">Linux系统里存在两个剪切板：一个叫做选择缓冲区(X11 selection buffer)，另一个才是剪切板(clipboard)。选择缓冲区是实时的，当使用鼠标或键盘选择内容时，内容已经存在于选择缓冲区了，这或许就是选择缓冲区的由来吧。可以使用<em><strong>鼠标中键</strong></em>或键入<em><strong>Shift+Insert</strong></em>来粘贴选择缓冲区的内容。但对于有些GUI程序，比如gedit，只能通过鼠标中键调用选择缓冲区的内容，使用Shift+Insert的话，调用的是剪切板的内容。</span>\r\n\r\n<span style="color: #0000ff;">相当有用阿！！！！！！</span>\r\n\r\n剪切板和Windows的剪切板类似，gnome-terminal，不能直接使用Ctrl+c，Ctrl+v，这时就要用Shift+Ctrl+c，Shift+Ctrl+v代替\r\n<ul class="simple">\r\n	<li>方案一：</li>\r\n</ul>\r\n<ol class="arabic simple">\r\n	<li>选择文本内容</li>\r\n	<li>vim普通模式下按 “*p 将选择缓冲区中内容粘贴进来</li>\r\n</ol>\r\n<ul class="simple">\r\n	<li>方案二：</li>\r\n</ul>\r\n<ol class="arabic simple">\r\n	<li>复制文件内容</li>\r\n	<li>vim普通模式下按 “+ p 将剪切板内容粘贴进来</li>\r\n</ol>\r\n但是，其实发现，在linux下或者vim里，利用选中，鼠标中键，来将缓冲区中的复制粘贴出来就很爽了阿。\r\n\r\nreferent link :www.cnblogs.com/jianyungsun/archive/2011/03/19/1988855.html', 'vim - 复制&粘贴', '', 'inherit', 'open', 'open', '', '181-autosave', '', '', '2014-06-06 03:13:33', '2014-06-06 03:13:33', '', 181, 'http://codeseeking.sinaapp.com/?p=190', 0, 'revision', '', 0),
(233, 1, '2014-06-13 08:48:00', '0000-00-00 00:00:00', '命令历史\r\n\r\n以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。\r\n启动vim\r\n\r\n在命令行窗口中输入以下命令即可\r\n\r\nvim 直接启动vim\r\n\r\nvim filename 打开vim并创建名为filename的文件\r\n文件命令\r\n\r\n打开单个文件\r\n\r\nvim file\r\n\r\n同时打开多个文件\r\n\r\nvim file1 file2 file3 ...\r\n\r\n在vim窗口中打开一个新文件\r\n\r\n:open file\r\n\r\n在新窗口中打开文件\r\n\r\n:split file\r\n\r\n切换到下一个文件\r\n\r\n:bn\r\n\r\n切换到上一个文件\r\n\r\n:bp\r\n\r\n查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。\r\n\r\n:args\r\n\r\n打开远程文件，比如ftp或者share folder\r\n\r\n:e ftp://192.168.10.76/abc.txt\r\n\r\n:e \\\\qadrive\\test\\1.txt\r\nvim的模式\r\n\r\n正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空\r\n插入模式（按i键进入） 左下角显示--INSERT--\r\n可视模式（不知道如何进入） 左下角显示--VISUAL--\r\n导航命令\r\n\r\n% 括号匹配\r\n插入命令\r\n\r\ni 在当前位置生前插入\r\n\r\nI 在当前行首插入\r\n\r\na 在当前位置后插入\r\n\r\nA 在当前行尾插入\r\n\r\no 在当前行之后插入一行\r\n\r\nO 在当前行之前插入一行\r\n查找命令\r\n\r\n/text　　查找text，按n健查找下一个，按N健查找前一个。\r\n\r\n?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。\r\n\r\nvim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$\r\n\r\n:set ignorecase　　忽略大小写的查找\r\n\r\n:set noignorecase　　不忽略大小写的查找\r\n\r\n查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。\r\n\r\n:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。\r\n\r\n:set nohlsearch　　关闭高亮搜索显示\r\n\r\n:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。\r\n\r\n:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。\r\n\r\n:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。\r\n替换命令\r\n\r\nra 将当前字符替换为a，当期字符即光标所在字符。\r\n\r\ns/old/new/ 用old替换new，替换当前行的第一个匹配\r\n\r\ns/old/new/g 用old替换new，替换当前行的所有匹配\r\n\r\n%s/old/new/ 用old替换new，替换所有行的第一个匹配\r\n\r\n%s/old/new/g 用old替换new，替换整个文件的所有匹配\r\n\r\n:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。\r\n\r\nddp 交换光标所在行和其下紧邻的一行。\r\n移动命令\r\n\r\nh 左移一个字符\r\nl 右移一个字符，这个命令很少用，一般用w代替。\r\nk 上移一个字符\r\nj 下移一个字符\r\n以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。\r\n\r\nw 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。\r\n\r\nb 向后移动一个单词 2b 向后移动2个单词\r\n\r\ne，同w，只不过是光标停在单词尾部\r\n\r\nge，同b，光标停在单词尾部。\r\n\r\n^ 移动到本行第一个非空白字符上。\r\n\r\n0（数字0）移动到本行第一个字符上，\r\n\r\n<HOME> 移动到本行第一个字符。同0健。\r\n\r\n$ 移动到行尾 3$ 移动到下面3行的行尾\r\n\r\ngg 移动到文件头。 = [[\r\n\r\nG（shift + g） 移动到文件尾。 = ]]\r\n\r\nf（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。\r\n\r\nF 同f，反向查找。\r\n\r\n跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。\r\n\r\nCtrl + e 向下滚动一行\r\n\r\nCtrl + y 向上滚动一行\r\n\r\nCtrl + d 向下滚动半屏\r\n\r\nCtrl + u 向上滚动半屏\r\n\r\nCtrl + f 向下滚动一屏\r\n\r\nCtrl + b 向上滚动一屏\r\n撤销和重做\r\n\r\nu 撤销（Undo）\r\nU 撤销对整行的操作\r\nCtrl + r 重做（Redo），即撤销的撤销。\r\n删除命令\r\n\r\nx 删除当前字符\r\n\r\n3x 删除当前光标开始向后三个字符\r\n\r\nX 删除当前字符的前一个字符。X=dh\r\n\r\ndl 删除当前字符， dl=x\r\n\r\ndh 删除前一个字符\r\n\r\ndd 删除当前行\r\n\r\ndj 删除上一行\r\n\r\ndk 删除下一行\r\n\r\n10d 删除当前行开始的10行。\r\n\r\nD 删除当前字符至行尾。D=d$\r\n\r\nd$ 删除当前字符之后的所有字符（本行）\r\n\r\nkdgg 删除当前行之前所有行（不包括当前行）\r\n\r\njdG（jd shift + g）   删除当前行之后所有行（不包括当前行）\r\n\r\n:1,10d 删除1-10行\r\n\r\n:11,$d 删除11行及以后所有的行\r\n\r\n:1,$d 删除所有行\r\n\r\nJ(shift + j)　　删除两行之间的空行，实际上是合并两行。\r\n拷贝和粘贴\r\n\r\nyy 拷贝当前行\r\n\r\nnyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。\r\n\r\np  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。\r\n\r\nshift+p 在当前行前粘贴\r\n\r\n:1,10 co 20 将1-10行插入到第20行之后。\r\n\r\n:1,$ co $ 将整个文件复制一份并添加到文件尾部。\r\n\r\n正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制\r\n\r\nddp交换当前行和其下一行\r\n\r\nxp交换当前字符和其后一个字符\r\n剪切命令\r\n\r\n正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切\r\n\r\nndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴\r\n\r\n:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。\r\n\r\n:1, 10 m 20 将第1-10行移动到第20行之后。\r\n退出命令\r\n\r\n:wq 保存并退出\r\n\r\nZZ 保存并退出\r\n\r\n:q! 强制退出并忽略所有更改\r\n\r\n:e! 放弃所有修改，并打开原来文件。\r\n窗口命令\r\n\r\n:split或new 打开一个新窗口，光标停在顶层的窗口上\r\n\r\n:split file或:new file 用新窗口打开文件\r\n\r\nsplit打开的窗口都是横向的，使用vsplit可以纵向打开窗口。\r\n\r\nCtrl+ww 移动到下一个窗口\r\n\r\nCtrl+wj 移动到下方的窗口\r\n\r\nCtrl+wk 移动到上方的窗口\r\n\r\n关闭窗口\r\n\r\n:close 最后一个窗口不能使用此命令，可以防止意外退出vim。\r\n\r\n:q 如果是最后一个被关闭的窗口，那么将退出vim。\r\n\r\nZZ 保存并退出。\r\n\r\n关闭所有窗口，只保留当前窗口\r\n\r\n:only\r\n\r\n录制宏\r\n\r\n按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。\r\n执行shell命令\r\n\r\n:!command\r\n\r\n:!ls 列出当前目录下文件\r\n\r\n:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。\r\n\r\n:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。\r\n\r\n:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。\r\n注释命令\r\n\r\nperl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#\r\n\r\n3,5 s/^/#/g 注释第3-5行\r\n\r\n3,5 s/^#//g 解除3-5行的注释\r\n\r\n1,$ s/^/#/g 注释整个文档。\r\n\r\n:%s/^/#/g 注释整个文档，此法更快。\r\n帮助命令\r\n\r\n:help or F1 显示整个帮助\r\n:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。\r\n:help ''number'' Vim选项的帮助用单引号括起\r\n:help <Esc> 特殊键的帮助用<>扩起\r\n:help -t Vim启动参数的帮助用-\r\n：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式\r\n帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回\r\n其他非编辑命令\r\n\r\n. 重复前一次命令\r\n\r\n:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看\r\n\r\n:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。\r\n\r\n:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:>-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。\r\n\r\nVim教程\r\n在Unix系统上\r\n$ vimtutor\r\n在Windows系统上\r\n:help tutor\r\n\r\n:syntax 列出已经定义的语法项\r\n:syntax clear 清除已定义的语法规则\r\n:syntax case match 大小写敏感，int和Int将视为不同的语法元素\r\n:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案', '', '', 'draft', 'open', 'open', '', '', '', '', '2014-06-13 08:48:00', '2014-06-13 08:48:00', '', 0, 'http://codeseeking.sinaapp.com/?p=233', 0, 'post', '', 0),
(188, 1, '2014-05-21 08:35:11', '2014-05-21 08:35:11', '斯坦福Ng ML 简单总结 待更新', 'MLearning summary', '', 'inherit', 'open', 'open', '', '163-revision-2', '', '', '2014-05-21 08:35:11', '2014-05-21 08:35:11', '', 163, 'http://codeseeking.sinaapp.com/?p=188', 0, 'revision', '', 0),
(191, 1, '2014-06-06 03:08:55', '2014-06-06 03:08:55', '正常下的n-yy n-dd yy dd + p是在vim中进行复制粘贴，需要从vim打开的文件中复制才可以\r\n但是有时候我们从外面复制的东西想要粘贴进去，只能用右键，粘贴，但是有时候格式缩进什么的都变了，这是因为设置的自动缩进等问题所以我们可以在粘贴外面文件的时候先， :set paste 进入粘贴模式，粘贴完 可以 :set nopaste 绑定快捷键也可以阿\r\n然而，还可以利用\r\n“+p\r\n来快速粘贴，它不考虑是否粘贴模式，是否自动缩进，直接原文粘贴。\r\nvim寄存器，就要从vim文件间的复制粘贴说起。\r\nVim中，若要复制当前行，普通模式下按 yy 即可，在要粘贴的地方按 p 。这是vim将复制内容保存到了自己的寄存器中的缘故。如果在其他地方执行yy，新的内容将覆盖掉原寄存器中内容。如果想保存原寄存器中内容而同时增加新的内容呢？这时就要在yy前增加标签了。标签以双引号开始，跟着的是标签名称，可以是数字0-9，也可以是26个字母，然后就是复制操作，这样就把复制内容保存到该标签寄存器里。通过下面命令显示所有寄存器内容：:\r\n:reg\r\n“ + 缓冲区标号 + p 就是粘贴出某个寄存器中间的\r\n其中注意两个特殊的寄存器：”* 和 “+。这两个寄存器是和系统相通的，前者关联系统选择缓冲区，后者关联系统剪切板。通过它们可以和其他程序进行数据交换。\r\n不同于Windows，Linux系统里存在两个剪切板：一个叫做选择缓冲区(X11 selection buffer)，另一个才是剪切板(clipboard)。选择缓冲区是实时的，当使用鼠标或键盘选择内容时，内容已经存在于选择缓冲区了，这或许就是选择缓冲区的由来吧。可以使用<span style="color: #00ffff;"><em><strong>鼠标中键</strong></em></span>或键入<span style="color: #00ffff;"><em><strong>Shift+Insert</strong></em></span>来粘贴选择缓冲区的内容。但对于有些GUI程序，比如gedit，只能通过鼠标中键调用选择缓冲区的内容，使用Shift+Insert的话，调用的是剪切板的内容。\r\n\r\n剪切板和Windows的剪切板类似，gnome-terminal，不能直接使用Ctrl+c，Ctrl+v，这时就要用Shift+Ctrl+c，Shift+Ctrl+v代替\r\n<ul class="simple">\r\n	<li>方案一：</li>\r\n</ul>\r\n<ol class="arabic simple">\r\n	<li>选择文本内容</li>\r\n	<li>vim普通模式下按 “*p 将选择缓冲区中内容粘贴进来</li>\r\n</ol>\r\n<ul class="simple">\r\n	<li>方案二：</li>\r\n</ul>\r\n<ol class="arabic simple">\r\n	<li>复制文件内容</li>\r\n	<li>vim普通模式下按 “+ p 将剪切板内容粘贴进来</li>\r\n</ol>\r\n\r\n但是，其实发现，在linux下或者vim里，利用选中，鼠标中键，来将缓冲区中的复制粘贴出来就很爽了阿。\r\n\r\nreferent link :www.cnblogs.com/jianyungsun/archive/2011/03/19/1988855.html', 'vim - 复制&粘贴', '', 'inherit', 'open', 'open', '', '181-revision-2', '', '', '2014-06-06 03:08:55', '2014-06-06 03:08:55', '', 181, 'http://codeseeking.sinaapp.com/?p=191', 0, 'revision', '', 0),
(192, 1, '2014-05-21 08:16:46', '2014-05-21 08:16:46', 'python 中的四个比较重要的‘容器’ list列表，tuple元祖，set集合，和dict字典，对于不同的‘容器’有相同的地方又有不同的操作。\r\n<ul>\r\n	<li><strong>first of all THE LIST：</strong></li>\r\n</ul>\r\nlist 的初始化，删除与分片，注意索引是从 0 开始的\r\n<pre lang="python">a_list = [1,2,3,4]\r\na_list[0]  1\r\na_list = list(''hello'')\r\na_list = [1,2,3,4]\r\ndel a_list[2]  #删除某个元素\r\ndel a_list #删除整个列表\r\n&gt;&gt;&gt;name = list(''perl'')\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''r'',''l'']\r\n&gt;&gt;&gt;name[2:] = list(''ar'')  #分片，a_list[m:n] 从m索引开始，到n之前的所有元素被分片出来\r\n&gt;&gt;&gt;name\r\n[''p'',''e'',''a'',''r'']\r\na_list = [1,5]\r\na_list[1:1] = [2,3,4]\r\nalist  [1,2,3,4,5]  #只是替换了一个空位置，将2，3，4加入进去</pre>\r\nlist方法：append() index() extend() count() insert() pop() reverse() remove() sort()\r\n<pre lang="python">a_list += [1,2] #+ 连接两个列表可以创建一个新的列表\r\na_list.append(x) #将一个新的元素 x 加入到列表尾端，只接受一个参数，但可以是各种数据类型\r\na_list.index(''who'') #如果列表中有who 将其索引返回，否则返回异常\r\na_list.extend(x)  #只接受一个列表作为参数，将一个或者多个值加入到列表中，注意extend只作用在原被拓展的列表上而不是新创建一个列表\r\na_list.count()  #统计某个元素在列表中出现的次数\r\na_list.insert(m,x)  #将某元素插入到列表的某个位置当中\r\na_list.pop() / a_list.pop(x)  # 默认是将列表的最后一个参数取出并返回出该值，亦可以指定返回的值的索引，这样配合append等可以用作队列或者栈\r\na_list.reverse()  #将队列反转\r\na_list.remove(x)  #将队列中第一个匹配 x 值的值移除\r\na_list.sort()  #排序啦</pre>\r\n<ul>\r\n	<li><strong>second,TUPLE 元组</strong></li>\r\n</ul>\r\n元组是不可变的列表。\r\n元组的创建：\r\n<pre lang="python">a_tuple = (1,2,3,4)  #用一对小括号创建元组 \r\n#元组和列表可以互相转化，可以想成list()融化元组，tuple()冻结列表\r\na_list = list(a_tuple)\r\na_tuple = tuple(a_list)\r\n#同时赋多个值\r\n(mon,tues,wed,thurs,fri,sat,sun) = range(7)</pre>\r\n对于元祖，其分片，索引等都和列表相同，但是对于append等一系列的操作则不能，当然除了index() 和 in 判断元组中是否存在该元素以外\r\n相对于列表，元组的好处还是有的：\r\n1.元祖的速度比列表快，如果只是需要进行遍历，创建成元组更合适\r\n2.写保护，代码更加安全\r\n3.一些元组可用作字典键，而列表永远不能做字典键，因为列表不是不可变的的\r\n<ul>\r\n	<li><strong>third,The SET 集合</strong></li>\r\n</ul>\r\n集合则是装有独特值的无序袋子，既然是独特值，那么其中的元素就是去重的，同时一个集合中可以包含任何类型的数据，同时两个集合可以执行交/并/差/对称差等操作\r\n集合的创建是用一对大括号 {}来初始化的\r\n<pre lang="python">a_set = {1,2,3,4}\r\na_set = set(a_list) #set()函数可以将列表变成集合当然会去重，\r\n#同时，因为set集合是无序的，可能同样顺序产生出来的set顺序不同，\r\n#但是他俩还是同一个集合的，ps：实际上集合是以类的形式出现的。</pre>\r\n修改集合值的方法，add() 和 update() 两种添加方法，remove() 和discard() 两种删除方法\r\n<pre lang="python">a_set.add(x) #将x 加入到集合中\r\na_set.update({x1,x2,x3},{y1,y2,y3}) #update仅接受一个集合作为参数，将所有元素去重形成新的集合\r\na_set.discard(x) #将x从集合中去除\r\na_set.remove(x) #同将x从集合中去除\r\n#两者的微妙差异在于，如果x不在集合中，那么discard不会报错而remove则会报错</pre>\r\nps：集合总也有个pop()但是因为集合中元素是无序的，导致pop()每次出来的值也是随机的\r\n常见额的集合操作，in / union / intersection / difference / symmetic_difference\r\n<pre lang="python" colla="-">&gt;&gt;&gt;x in a_set\r\nTrue/False\r\na_set = {...}   b_set = {...}\r\na_set.union(b_set)  #并 |\r\na_set.intersection(b_set)  #交 &amp;\r\na_set.difference(b_set)  #a-b 差\r\na_set.symmetric_difference(b_set) #对称差，a|b -(a&amp;b)\r\nps:\r\na_set.issubset(b_set)\r\n&gt;&gt;True/False\r\nb_set.issuperset(a_set)\r\n&gt;&gt;True/False\r\n</pre>\r\n<ul>\r\n	<li><strong>final，DICT 字典</strong></li>\r\n</ul>\r\n字典是键值对的无序集合。向字典添加一个键的同时必须向字典添加一个值。\r\n字典的创建仍然靠一对大括号 {} 但是其中的结构有所要求，必须是{x:y , n:m ...}\r\n<pre lang="python" colla="-">\r\na_dict = {''user'':''char'',''pwd'':''123'', ... }\r\n>>>a_dict[''user'']\r\n''char''\r\n#修改字典\r\na_dict[''user''] = ''new item'' #即修改了user对应的值\r\n#字典中不允许存在重复的键，所以对某键值的修改会覆盖\r\n</pre>\r\n混合值字典，字典并非只能用于字符串，字典的值可以是任何的数据类型，即便在同一字典中，值的类型也不必相同，同时也可混合使用不同类型的键。\r\n\r\n以上便是python中的四种比较重要的数据‘容器’在此小作总结。', 'list/tuple/dict/set of python', '', 'inherit', 'open', 'open', '', '147-revision-8', '', '', '2014-05-21 08:16:46', '2014-05-21 08:16:46', '', 147, 'http://codeseeking.sinaapp.com/?p=192', 0, 'revision', '', 0),
(194, 1, '2014-05-27 07:30:44', '2014-05-27 07:30:44', 'first of all , 关于import module && from module import * 的区别，前者在使用module中导入的东西的时候需要加上模块名的限定，而后者则不需要，如果使用前者导入而用了后者的使用，则会返回 ''module'' object is not callable 的错误。\r\n再者，python中的for循环是for xx in xx 这种，而没有那种指定数字的循环，所以可以利用某个1ton 的数组来in以下！？有点贱..我用的是in+list.pop最后看大小来发现到哪里了，但是这样可能会产生从空list中pop的问题', 'python 初coding', '', 'inherit', 'open', 'open', '', '165-revision-2', '', '', '2014-05-27 07:30:44', '2014-05-27 07:30:44', '', 165, 'http://codeseeking.sinaapp.com/?p=194', 0, 'revision', '', 0),
(195, 1, '2014-06-06 09:04:16', '2014-06-06 09:04:16', '首先，写一个HMM重要的两步，count the e(x|y) & compute the p(v|w,u) 与dp\r\ncount的时候，用到list遍历和字典的使用，集合是[] tuple元祖是() set是{} dictionary是{x:y}，具体操作不写多，但是在用的时候，字典是可以直接按照键来赋值的，如果不存在该键值对则添加进去，但是如果不存在不能用+=来添加，所以便有了判断是否存在某键值对或单一键值是否存在在字典中\r\n<pre lang="python" colla="+">\r\n>>> d\r\n{(1, 2): 8, (3, 4): 5}\r\n>>> x\r\n[(1, 2), (3, 4)]\r\n>>> if (1,3) in d:\r\n...     d[(1,3)] += 1\r\n... else:\r\n...     d[(1,3)] = 1\r\n... \r\n>>> d\r\n{(1, 2): 8, (1, 3): 1, (3, 4): 5}\r\n#字典也是可以删除的，如：\r\n#删除指定键－值对  \r\n>>> dict1  \r\n{''a'': 1, ''b'': 2}  \r\n>>> del dict1[''a''] #也可以用pop方法，dict1.pop(''a'')  \r\n>>> dict1  \r\n{''b'': 2}  \r\n#清空字典  \r\n>>> dict1.clear()  \r\n>>> dict1 #字典变为空了  \r\n{}  \r\n#删除字典对象  \r\n>>> del dict1  \r\n</pre>\r\n\r\n遍历字典的时候，得到的是字典键值的序列！！！！！！！\r\n\r\nps:所有的list tuple set dict，他们的索引都是 [ ] ，只不过里面的东西不一样罢了', 'HMM coding有感', '', 'publish', 'open', 'open', '', 'hmm-coding%e6%9c%89%e6%84%9f', '', '', '2014-06-06 13:35:21', '2014-06-06 13:35:21', '', 0, 'http://codeseeking.sinaapp.com/?p=195', 0, 'post', '', 0),
(196, 1, '2014-06-06 09:03:19', '2014-06-06 09:03:19', '首先，写一个HMM重要的两步，count the e(x|y) & compute the p(v|w,u) 与dp\ncount的时候，用到list遍历和字典的使用，集合是[] tuple元祖是() set是{} dictionary是{x:y}，具体操作不写多，但是在用的时候，字典是可以直接按照键来赋值的，如果不存在该键值对则添加进去，但是如果不存在不能用+=来添加，所以便有了判断是否存在某键值对或单一键值是否存在在字典中\n<pre lang="python" colla="+">\n>>> d\n{(1, 2): 8, (3, 4): 5}\n>>> x\n[(1, 2), (3, 4)]\n>>> if (1,3) in d:\n...     d[(1,3)] += 1\n... else:\n...     d[(1,3)] = 1\n... \n>>> d\n{(1, 2): 8, (1, 3): 1, (3, 4): 5}\n</pre>', 'HMM coding有感', '', 'inherit', 'open', 'open', '', '195-revision', '', '', '2014-06-06 09:03:19', '2014-06-06 09:03:19', '', 195, 'http://codeseeking.sinaapp.com/?p=196', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(197, 1, '2014-06-06 13:34:22', '2014-06-06 13:34:22', '首先，写一个HMM重要的两步，count the e(x|y) &amp; compute the p(v|w,u) 与dp\ncount的时候，用到list遍历和字典的使用，集合是[] tuple元祖是() set是{} dictionary是{x:y}，具体操作不写多，但是在用的时候，字典是可以直接按照键来赋值的，如果不存在该键值对则添加进去，但是如果不存在不能用+=来添加，所以便有了判断是否存在某键值对或单一键值是否存在在字典中\n<pre lang="python">&gt;&gt;&gt; d\n{(1, 2): 8, (3, 4): 5}\n&gt;&gt;&gt; x\n[(1, 2), (3, 4)]\n&gt;&gt;&gt; if (1,3) in d:\n...     d[(1,3)] += 1\n... else:\n...     d[(1,3)] = 1\n... \n&gt;&gt;&gt; d\n{(1, 2): 8, (1, 3): 1, (3, 4): 5}\n#字典也是可以删除的，如：\n#删除指定键－值对  \n&gt;&gt;&gt; dict1  \n{''a'': 1, ''b'': 2}  \n&gt;&gt;&gt; del dict1[''a''] #也可以用pop方法，dict1.pop(''a'')  \n&gt;&gt;&gt; dict1  \n{''b'': 2}  \n#清空字典  \n&gt;&gt;&gt; dict1.clear()  \n&gt;&gt;&gt; dict1 #字典变为空了  \n{}  \n#删除字典对象  \n</pre>\n<span style="color: #ff0000;">#attention:遍历字典的时候，得到的 i 是字典的键值。</span>\nps:所有的list tuple set dict，他们的索引都是 [ ] ，只不过里面的东西不一样罢了', 'HMM coding有感', '', 'inherit', 'open', 'open', '', '195-autosave', '', '', '2014-06-06 13:34:22', '2014-06-06 13:34:22', '', 195, 'http://codeseeking.sinaapp.com/?p=197', 0, 'revision', '', 0),
(198, 1, '2014-06-06 09:04:16', '2014-06-06 09:04:16', '首先，写一个HMM重要的两步，count the e(x|y) & compute the p(v|w,u) 与dp\r\ncount的时候，用到list遍历和字典的使用，集合是[] tuple元祖是() set是{} dictionary是{x:y}，具体操作不写多，但是在用的时候，字典是可以直接按照键来赋值的，如果不存在该键值对则添加进去，但是如果不存在不能用+=来添加，所以便有了判断是否存在某键值对或单一键值是否存在在字典中\r\n<pre lang="python" colla="+">\r\n>>> d\r\n{(1, 2): 8, (3, 4): 5}\r\n>>> x\r\n[(1, 2), (3, 4)]\r\n>>> if (1,3) in d:\r\n...     d[(1,3)] += 1\r\n... else:\r\n...     d[(1,3)] = 1\r\n... \r\n>>> d\r\n{(1, 2): 8, (1, 3): 1, (3, 4): 5}\r\n</pre>\r\nps:所有的list tuple set dict，他们的索引都是 [ ] ，只不过里面的东西不一样罢了', 'HMM coding有感', '', 'inherit', 'open', 'open', '', '195-revision-2', '', '', '2014-06-06 09:04:16', '2014-06-06 09:04:16', '', 195, 'http://codeseeking.sinaapp.com/?p=198', 0, 'revision', '', 0),
(199, 1, '2014-06-06 12:26:21', '2014-06-06 12:26:21', '首先，写一个HMM重要的两步，count the e(x|y) & compute the p(v|w,u) 与dp\r\ncount的时候，用到list遍历和字典的使用，集合是[] tuple元祖是() set是{} dictionary是{x:y}，具体操作不写多，但是在用的时候，字典是可以直接按照键来赋值的，如果不存在该键值对则添加进去，但是如果不存在不能用+=来添加，所以便有了判断是否存在某键值对或单一键值是否存在在字典中\r\n<pre lang="python" colla="+">\r\n>>> d\r\n{(1, 2): 8, (3, 4): 5}\r\n>>> x\r\n[(1, 2), (3, 4)]\r\n>>> if (1,3) in d:\r\n...     d[(1,3)] += 1\r\n... else:\r\n...     d[(1,3)] = 1\r\n... \r\n>>> d\r\n{(1, 2): 8, (1, 3): 1, (3, 4): 5}\r\n#字典也是可以删除的，如：\r\n#删除指定键－值对  \r\n>>> dict1  \r\n{''a'': 1, ''b'': 2}  \r\n>>> del dict1[''a''] #也可以用pop方法，dict1.pop(''a'')  \r\n>>> dict1  \r\n{''b'': 2}  \r\n#清空字典  \r\n>>> dict1.clear()  \r\n>>> dict1 #字典变为空了  \r\n{}  \r\n#删除字典对象  \r\n>>> del dict1  \r\n</pre>\r\nps:所有的list tuple set dict，他们的索引都是 [ ] ，只不过里面的东西不一样罢了', 'HMM coding有感', '', 'inherit', 'open', 'open', '', '195-revision-3', '', '', '2014-06-06 12:26:21', '2014-06-06 12:26:21', '', 195, 'http://codeseeking.sinaapp.com/?p=199', 0, 'revision', '', 0),
(200, 1, '2014-06-06 13:34:41', '2014-06-06 13:34:41', '首先，写一个HMM重要的两步，count the e(x|y) & compute the p(v|w,u) 与dp\r\ncount的时候，用到list遍历和字典的使用，集合是[] tuple元祖是() set是{} dictionary是{x:y}，具体操作不写多，但是在用的时候，字典是可以直接按照键来赋值的，如果不存在该键值对则添加进去，但是如果不存在不能用+=来添加，所以便有了判断是否存在某键值对或单一键值是否存在在字典中\r\n<pre lang="python" colla="+">\r\n>>> d\r\n{(1, 2): 8, (3, 4): 5}\r\n>>> x\r\n[(1, 2), (3, 4)]\r\n>>> if (1,3) in d:\r\n...     d[(1,3)] += 1\r\n... else:\r\n...     d[(1,3)] = 1\r\n... \r\n>>> d\r\n{(1, 2): 8, (1, 3): 1, (3, 4): 5}\r\n#字典也是可以删除的，如：\r\n#删除指定键－值对  \r\n>>> dict1  \r\n{''a'': 1, ''b'': 2}  \r\n>>> del dict1[''a''] #也可以用pop方法，dict1.pop(''a'')  \r\n>>> dict1  \r\n{''b'': 2}  \r\n#清空字典  \r\n>>> dict1.clear()  \r\n>>> dict1 #字典变为空了  \r\n{}  \r\n#删除字典对象  \r\n>>> del dict1  \r\n</pre>\r\nps:所有的list tuple set dict，他们的索引都是 [ ] ，只不过里面的东西不一样罢了', 'HMM coding有感', '', 'inherit', 'open', 'open', '', '195-revision-4', '', '', '2014-06-06 13:34:41', '2014-06-06 13:34:41', '', 195, 'http://codeseeking.sinaapp.com/?p=200', 0, 'revision', '', 0),
(201, 1, '2014-06-09 01:21:04', '2014-06-09 01:21:04', 'Read & handle for something....\r\n<pre lang="python" colla="-">\r\ndef FRline(filetoread,n):\r\n	try:\r\n		infile = file(filetoread,"r")\r\n	except IOError:\r\n		sys.stderr.write("Can not open the file")\r\n		sys.exit(1)\r\n	tlist = (n - 1) * [[None,"*"]]\r\n	fl = infile.readline()\r\n	while fl:\r\n		l = fl.strip()\r\n		ntmp = 1\r\n		if l:\r\n			fline = l.split(" ")\r\n			wtag = fline[-1]\r\n			wd = " ".join(fline[:-1])\r\n			tlist.append([wd,wtag])\r\n		else:\r\n			tlist.append([None,"STOP"])\r\n			for i in xrange(n-1):\r\n				tlist.append([None,"*"])\r\n			ntmp += 1\r\n		fl = infile.readline()\r\n	tlist.append([None,"STOP"])\r\n	return tlist\r\n</pre>\r\nCount & count...\r\n<pre lang="python" colla="-">\r\ndef CountX(wlen):\r\n	wlen = len(wlist)\r\n	xdict = {}\r\n	xlist = []\r\n	for i in xrange(wlen):\r\n		if wlist[i][0] in xdict:\r\n			xdict[wlist[i][0]] +=1\r\n		else:\r\n			xdict[wlist[i][0]] = 1\r\n	for c in xdict:\r\n		if xdict[c] <= 5:\r\n			xlist.append(c)\r\n	return xlist\r\n\r\ndef CountWTag(wlist):\r\n	wlen = len(wlist)\r\n	tdict = {}\r\n	for i in xrange(wlen):\r\n                wlistmp = tuple(wlist[i])\r\n		if wlistmp in tdict:\r\n			tdict[wlistmp] += 1\r\n		else:\r\n			tdict[wlistmp] = 1\r\n	return tdict\r\n</pre>\r\nCount Tags with Rare...\r\n<pre lang="python" colla="-">\r\ndef CGWithRare(wlist,n):\r\n	wlen = len(wlist)\r\n	xlist = CountX(wlist)\r\n	print xlist\r\n	for j in xrange(wlen):\r\n		if wlist[j][0] in xlist:\r\n			wlist[j][0] = "_Rare_"\r\n			print j\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict,xlist\r\n</pre>\r\nCount Tags without rare...\r\n<pre lang="python" colla="-">\r\ndef CountGram(wlist,n):\r\n	#every word in xdict should be tagged as _Rare_\r\n	#xdict = CountX(wlist)\r\n	wlen = len(wlist)\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict\r\n</pre>', 'HMM 各种count啊', '', 'publish', 'open', 'open', '', 'hmm-%e5%90%84%e7%a7%8dcount%e5%95%8a', '', '', '2014-06-09 01:35:33', '2014-06-09 01:35:33', '', 0, 'http://codeseeking.sinaapp.com/?p=201', 0, 'post', '', 0),
(202, 1, '2014-06-09 01:19:56', '2014-06-09 01:19:56', '<pre lang="python" colla="+">\ndef FRline(filetoread,n):\n	try:\n		infile = file(filetoread,"r")\n	except IOError:\n		sys.stderr.write("Can not open the file")\n		sys.exit(1)\n	tlist = (n - 1) * [[None,"*"]]\n	fl = infile.readline()\n	while fl:\n		l = fl.strip()\n		ntmp = 1\n		if l:\n			fline = l.split(" ")\n			wtag = fline[-1]\n			wd = " ".join(fline[:-1])\n			tlist.append([wd,wtag])\n		else:\n			tlist.append([None,"STOP"])\n			for i in xrange(n-1):\n				tlist.append([None,"*"])\n			ntmp += 1\n		fl = infile.readline()\n	tlist.append([None,"STOP"])\n	return tlist\n</pre>\n<pre lang="python" colla="+">\ndef CountX(wlen):\n	wlen = len(wlist)\n	xdict = {}\n	xlist = []\n	for i in xrange(wlen):\n		if wlist[i][0] in xdict:\n			xdict[wlist[i][0]] +=1\n		else:\n			xdict[wlist[i][0]] = 1\n	for c in xdict:\n		if xdict[c] <= 5:\n			xlist.append(c)\n	return xlist\n\ndef CountWTag(wlist):\n	wlen = len(wlist)\n	tdict = {}\n	for i in xrange(wlen):\n		if wlist[i] in tdict:\n			tdict[wlist[i]] += 1\n		else:\n			tdict[wlist[i]] = 1\n	return tdict\n</pre>\n<pre lang="python" colla="+">\ndef CGWithRare(wlist,n):\n	wlen = len(wlist)\n	xlist = CountX(wlist)\n	print xlist\n	for j in xrange(wlen):\n		if wlist[j][0] in xlist:\n			wlist[j][0] = "_Rare_"\n			print j\n	gdict = {}\n	for i in xrange(wlen - n + 2):\n		tmpl = wlist[i:i+n]\n		#1-gram\n		if tmpl[0][1] in gdict:\n			gdict[tmpl[0][1]] += 1\n		else:\n			gdict[tmpl[0][1]] = 1\n		#2-gram\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\n		else:\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\n		#3-gram\n		if i <= wlen - n:\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\n			else:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\n	return gdict,xlist\n</pre>\n<pre lang="python" colla="+">\n\n</pre>\n<pre lang="python" colla="+">\n\n</pre>', 'HMM 各种count啊', '', 'inherit', 'open', 'open', '', '201-revision', '', '', '2014-06-09 01:19:56', '2014-06-09 01:19:56', '', 201, 'http://codeseeking.sinaapp.com/?p=202', 0, 'revision', '', 0),
(203, 1, '2014-06-09 01:20:56', '2014-06-09 01:20:56', '<pre lang="python" colla="-">\ndef FRline(filetoread,n):\n	try:\n		infile = file(filetoread,"r")\n	except IOError:\n		sys.stderr.write("Can not open the file")\n		sys.exit(1)\n	tlist = (n - 1) * [[None,"*"]]\n	fl = infile.readline()\n	while fl:\n		l = fl.strip()\n		ntmp = 1\n		if l:\n			fline = l.split(" ")\n			wtag = fline[-1]\n			wd = " ".join(fline[:-1])\n			tlist.append([wd,wtag])\n		else:\n			tlist.append([None,"STOP"])\n			for i in xrange(n-1):\n				tlist.append([None,"*"])\n			ntmp += 1\n		fl = infile.readline()\n	tlist.append([None,"STOP"])\n	return tlist\n</pre>\n<pre lang="python" colla="-">\ndef CountX(wlen):\n	wlen = len(wlist)\n	xdict = {}\n	xlist = []\n	for i in xrange(wlen):\n		if wlist[i][0] in xdict:\n			xdict[wlist[i][0]] +=1\n		else:\n			xdict[wlist[i][0]] = 1\n	for c in xdict:\n		if xdict[c] <= 5:\n			xlist.append(c)\n	return xlist\n\ndef CountWTag(wlist):\n	wlen = len(wlist)\n	tdict = {}\n	for i in xrange(wlen):\n		if wlist[i] in tdict:\n			tdict[wlist[i]] += 1\n		else:\n			tdict[wlist[i]] = 1\n	return tdict\n</pre>\n<pre lang="python" colla="+">\ndef CGWithRare(wlist,n):\n	wlen = len(wlist)\n	xlist = CountX(wlist)\n	print xlist\n	for j in xrange(wlen):\n		if wlist[j][0] in xlist:\n			wlist[j][0] = "_Rare_"\n			print j\n	gdict = {}\n	for i in xrange(wlen - n + 2):\n		tmpl = wlist[i:i+n]\n		#1-gram\n		if tmpl[0][1] in gdict:\n			gdict[tmpl[0][1]] += 1\n		else:\n			gdict[tmpl[0][1]] = 1\n		#2-gram\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\n		else:\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\n		#3-gram\n		if i <= wlen - n:\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\n			else:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\n	return gdict,xlist\n</pre>\n<pre lang="python" colla="+">\ndef CountGram(wlist,n):\n	#every word in xdict should be tagged as _Rare_\n	#xdict = CountX(wlist)\n	wlen = len(wlist)\n	gdict = {}\n	for i in xrange(wlen - n + 2):\n		tmpl = wlist[i:i+n]\n		#1-gram\n		if tmpl[0][1] in gdict:\n			gdict[tmpl[0][1]] += 1\n		else:\n			gdict[tmpl[0][1]] = 1\n		#2-gram\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\n		else:\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\n		#3-gram\n		if i <= wlen - n:\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\n			else:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\n	return gdict\n</pre>', 'HMM 各种count啊', '', 'inherit', 'open', 'open', '', '201-revision-2', '', '', '2014-06-09 01:20:56', '2014-06-09 01:20:56', '', 201, 'http://codeseeking.sinaapp.com/?p=203', 0, 'revision', '', 0),
(204, 1, '2014-06-09 01:35:27', '2014-06-09 01:35:27', 'Read & handle for something....\n<pre lang="python" colla="-">\ndef FRline(filetoread,n):\n	try:\n		infile = file(filetoread,"r")\n	except IOError:\n		sys.stderr.write("Can not open the file")\n		sys.exit(1)\n	tlist = (n - 1) * [[None,"*"]]\n	fl = infile.readline()\n	while fl:\n		l = fl.strip()\n		ntmp = 1\n		if l:\n			fline = l.split(" ")\n			wtag = fline[-1]\n			wd = " ".join(fline[:-1])\n			tlist.append([wd,wtag])\n		else:\n			tlist.append([None,"STOP"])\n			for i in xrange(n-1):\n				tlist.append([None,"*"])\n			ntmp += 1\n		fl = infile.readline()\n	tlist.append([None,"STOP"])\n	return tlist\n</pre>\nCount & count...\n<pre lang="python" colla="-">\ndef CountX(wlen):\n	wlen = len(wlist)\n	xdict = {}\n	xlist = []\n	for i in xrange(wlen):\n		if wlist[i][0] in xdict:\n			xdict[wlist[i][0]] +=1\n		else:\n			xdict[wlist[i][0]] = 1\n	for c in xdict:\n		if xdict[c] <= 5:\n			xlist.append(c)\n	return xlist\n\ndef CountWTag(wlist):\n	wlen = len(wlist)\n	tdict = {}\n	for i in xrange(wlen):\n                wlistmp = tuple(wlist[i])\n		if wlistmp in tdict:\n			tdict[wlistmp] += 1\n		else:\n			tdict[wlistmp] = 1\n	return tdict\n</pre>\nCount Tags with Rare...\n<pre lang="python" colla="-">\ndef CGWithRare(wlist,n):\n	wlen = len(wlist)\n	xlist = CountX(wlist)\n	print xlist\n	for j in xrange(wlen):\n		if wlist[j][0] in xlist:\n			wlist[j][0] = "_Rare_"\n			print j\n	gdict = {}\n	for i in xrange(wlen - n + 2):\n		tmpl = wlist[i:i+n]\n		#1-gram\n		if tmpl[0][1] in gdict:\n			gdict[tmpl[0][1]] += 1\n		else:\n			gdict[tmpl[0][1]] = 1\n		#2-gram\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\n		else:\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\n		#3-gram\n		if i <= wlen - n:\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\n			else:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\n	return gdict,xlist\n</pre>\nCount Tag\n<pre lang="python" colla="-">\ndef CountGram(wlist,n):\n	#every word in xdict should be tagged as _Rare_\n	#xdict = CountX(wlist)\n	wlen = len(wlist)\n	gdict = {}\n	for i in xrange(wlen - n + 2):\n		tmpl = wlist[i:i+n]\n		#1-gram\n		if tmpl[0][1] in gdict:\n			gdict[tmpl[0][1]] += 1\n		else:\n			gdict[tmpl[0][1]] = 1\n		#2-gram\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\n		else:\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\n		#3-gram\n		if i <= wlen - n:\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\n			else:\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\n	return gdict\n</pre>', 'HMM 各种count啊', '', 'inherit', 'open', 'open', '', '201-autosave', '', '', '2014-06-09 01:35:27', '2014-06-09 01:35:27', '', 201, 'http://codeseeking.sinaapp.com/?p=204', 0, 'revision', '', 0),
(206, 1, '2014-06-09 01:22:21', '2014-06-09 01:22:21', '<pre lang="python" colla="-">\r\ndef FRline(filetoread,n):\r\n	try:\r\n		infile = file(filetoread,"r")\r\n	except IOError:\r\n		sys.stderr.write("Can not open the file")\r\n		sys.exit(1)\r\n	tlist = (n - 1) * [[None,"*"]]\r\n	fl = infile.readline()\r\n	while fl:\r\n		l = fl.strip()\r\n		ntmp = 1\r\n		if l:\r\n			fline = l.split(" ")\r\n			wtag = fline[-1]\r\n			wd = " ".join(fline[:-1])\r\n			tlist.append([wd,wtag])\r\n		else:\r\n			tlist.append([None,"STOP"])\r\n			for i in xrange(n-1):\r\n				tlist.append([None,"*"])\r\n			ntmp += 1\r\n		fl = infile.readline()\r\n	tlist.append([None,"STOP"])\r\n	return tlist\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CountX(wlen):\r\n	wlen = len(wlist)\r\n	xdict = {}\r\n	xlist = []\r\n	for i in xrange(wlen):\r\n		if wlist[i][0] in xdict:\r\n			xdict[wlist[i][0]] +=1\r\n		else:\r\n			xdict[wlist[i][0]] = 1\r\n	for c in xdict:\r\n		if xdict[c] <= 5:\r\n			xlist.append(c)\r\n	return xlist\r\n\r\ndef CountWTag(wlist):\r\n	wlen = len(wlist)\r\n	tdict = {}\r\n	for i in xrange(wlen):\r\n		if wlist[i] in tdict:\r\n			tdict[wlist[i]] += 1\r\n		else:\r\n			tdict[wlist[i]] = 1\r\n	return tdict\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CGWithRare(wlist,n):\r\n	wlen = len(wlist)\r\n	xlist = CountX(wlist)\r\n	print xlist\r\n	for j in xrange(wlen):\r\n		if wlist[j][0] in xlist:\r\n			wlist[j][0] = "_Rare_"\r\n			print j\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict,xlist\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CountGram(wlist,n):\r\n	#every word in xdict should be tagged as _Rare_\r\n	#xdict = CountX(wlist)\r\n	wlen = len(wlist)\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict\r\n</pre>', 'HMM 各种count啊', '', 'inherit', 'open', 'open', '', '201-revision-4', '', '', '2014-06-09 01:22:21', '2014-06-09 01:22:21', '', 201, 'http://codeseeking.sinaapp.com/?p=206', 0, 'revision', '', 0),
(205, 1, '2014-06-09 01:21:04', '2014-06-09 01:21:04', '<pre lang="python" colla="-">\r\ndef FRline(filetoread,n):\r\n	try:\r\n		infile = file(filetoread,"r")\r\n	except IOError:\r\n		sys.stderr.write("Can not open the file")\r\n		sys.exit(1)\r\n	tlist = (n - 1) * [[None,"*"]]\r\n	fl = infile.readline()\r\n	while fl:\r\n		l = fl.strip()\r\n		ntmp = 1\r\n		if l:\r\n			fline = l.split(" ")\r\n			wtag = fline[-1]\r\n			wd = " ".join(fline[:-1])\r\n			tlist.append([wd,wtag])\r\n		else:\r\n			tlist.append([None,"STOP"])\r\n			for i in xrange(n-1):\r\n				tlist.append([None,"*"])\r\n			ntmp += 1\r\n		fl = infile.readline()\r\n	tlist.append([None,"STOP"])\r\n	return tlist\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CountX(wlen):\r\n	wlen = len(wlist)\r\n	xdict = {}\r\n	xlist = []\r\n	for i in xrange(wlen):\r\n		if wlist[i][0] in xdict:\r\n			xdict[wlist[i][0]] +=1\r\n		else:\r\n			xdict[wlist[i][0]] = 1\r\n	for c in xdict:\r\n		if xdict[c] <= 5:\r\n			xlist.append(c)\r\n	return xlist\r\n\r\ndef CountWTag(wlist):\r\n	wlen = len(wlist)\r\n	tdict = {}\r\n	for i in xrange(wlen):\r\n		if wlist[i] in tdict:\r\n			tdict[wlist[i]] += 1\r\n		else:\r\n			tdict[wlist[i]] = 1\r\n	return tdict\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CGWithRare(wlist,n):\r\n	wlen = len(wlist)\r\n	xlist = CountX(wlist)\r\n	print xlist\r\n	for j in xrange(wlen):\r\n		if wlist[j][0] in xlist:\r\n			wlist[j][0] = "_Rare_"\r\n			print j\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict,xlist\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CountGram(wlist,n):\r\n	#every word in xdict should be tagged as _Rare_\r\n	#xdict = CountX(wlist)\r\n	wlen = len(wlist)\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict\r\n</pre>', 'HMM 各种count啊', '', 'inherit', 'open', 'open', '', '201-revision-3', '', '', '2014-06-09 01:21:04', '2014-06-09 01:21:04', '', 201, 'http://codeseeking.sinaapp.com/?p=205', 0, 'revision', '', 0),
(207, 1, '2014-06-09 01:34:10', '2014-06-09 01:34:10', '<pre lang="python" colla="-">\r\ndef FRline(filetoread,n):\r\n	try:\r\n		infile = file(filetoread,"r")\r\n	except IOError:\r\n		sys.stderr.write("Can not open the file")\r\n		sys.exit(1)\r\n	tlist = (n - 1) * [[None,"*"]]\r\n	fl = infile.readline()\r\n	while fl:\r\n		l = fl.strip()\r\n		ntmp = 1\r\n		if l:\r\n			fline = l.split(" ")\r\n			wtag = fline[-1]\r\n			wd = " ".join(fline[:-1])\r\n			tlist.append([wd,wtag])\r\n		else:\r\n			tlist.append([None,"STOP"])\r\n			for i in xrange(n-1):\r\n				tlist.append([None,"*"])\r\n			ntmp += 1\r\n		fl = infile.readline()\r\n	tlist.append([None,"STOP"])\r\n	return tlist\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CountX(wlen):\r\n	wlen = len(wlist)\r\n	xdict = {}\r\n	xlist = []\r\n	for i in xrange(wlen):\r\n		if wlist[i][0] in xdict:\r\n			xdict[wlist[i][0]] +=1\r\n		else:\r\n			xdict[wlist[i][0]] = 1\r\n	for c in xdict:\r\n		if xdict[c] <= 5:\r\n			xlist.append(c)\r\n	return xlist\r\n\r\ndef CountWTag(wlist):\r\n	wlen = len(wlist)\r\n	tdict = {}\r\n	for i in xrange(wlen):\r\n                wlistmp = tuple(wlist[i])\r\n		if wlistmp in tdict:\r\n			tdict[wlistmp] += 1\r\n		else:\r\n			tdict[wlistmp] = 1\r\n	return tdict\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CGWithRare(wlist,n):\r\n	wlen = len(wlist)\r\n	xlist = CountX(wlist)\r\n	print xlist\r\n	for j in xrange(wlen):\r\n		if wlist[j][0] in xlist:\r\n			wlist[j][0] = "_Rare_"\r\n			print j\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict,xlist\r\n</pre>\r\n<pre lang="python" colla="-">\r\ndef CountGram(wlist,n):\r\n	#every word in xdict should be tagged as _Rare_\r\n	#xdict = CountX(wlist)\r\n	wlen = len(wlist)\r\n	gdict = {}\r\n	for i in xrange(wlen - n + 2):\r\n		tmpl = wlist[i:i+n]\r\n		#1-gram\r\n		if tmpl[0][1] in gdict:\r\n			gdict[tmpl[0][1]] += 1\r\n		else:\r\n			gdict[tmpl[0][1]] = 1\r\n		#2-gram\r\n		if (tmpl[0][1],tmpl[1][1]) in gdict:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] += 1\r\n		else:\r\n			gdict[(tmpl[0][1],tmpl[1][1])] = 1\r\n		#3-gram\r\n		if i <= wlen - n:\r\n			if (tmpl[0][1],tmpl[1][1],tmpl[2][1]) in gdict:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] += 1\r\n			else:\r\n				gdict[(tmpl[0][1],tmpl[1][1],tmpl[2][1])] = 1\r\n	return gdict\r\n</pre>', 'HMM 各种count啊', '', 'inherit', 'open', 'open', '', '201-revision-5', '', '', '2014-06-09 01:34:10', '2014-06-09 01:34:10', '', 201, 'http://codeseeking.sinaapp.com/?p=207', 0, 'revision', '', 0),
(208, 1, '2014-06-09 01:49:14', '2014-06-09 01:49:14', '<pre lang="python" colla="+">\r\n         try:\r\n		outfile = file(filetowrite,"w")\r\n	except IOError:\r\n		sys.stderr.write("Can not open the file")\r\n		sys.exit(1)\r\n         file.write("%s %d...."%(char,int))\r\n\r\n         file.open("file''s name","w/r")\r\n         file.read([size])\r\n         file.readline([size])\r\n         file.readline()\r\n         file.readlines()\r\n         file.write(sq)\r\n         file.writelines(sq)\r\n         #写入多行\r\n         file_object.writelines(list_of_text_strings)\r\n         F.close()\r\n         #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。如果一个文件在关闭后还对其进行操作会产生ValueError\r\n         F.flush()\r\n         #把缓冲区的内容写入硬盘\r\n         F.fileno()\r\n         #返回一个长整型的”文件标签“\r\n         F.isatty()\r\n         #文件是否是一个终端设备文件（unix系统中的）\r\n         F.tell()\r\n         #返回文件操作标记的当前位置，以文件的开头为原点\r\n         F.next()\r\n         #返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in file这样的语句时，就是调用next()函数来实现遍历的。\r\n         F.seek(offset[,whence]) \r\n</pre>', 'Python Read&Write', '', 'publish', 'open', 'open', '', 'python-readwrite', '', '', '2014-06-09 02:18:10', '2014-06-09 02:18:10', '', 0, 'http://codeseeking.sinaapp.com/?p=208', 0, 'post', '', 0),
(209, 1, '2014-06-09 01:49:09', '2014-06-09 01:49:09', '<pre lang="python" colla="+">\n         try:\n		outfile = file(filetowrite,"w")\n	except IOError:\n		sys.stderr.write("Can not open the file")\n		sys.exit(1)\n         file.open("file''s name","w/r")\n         file.read([size])\n         file.readline([size])\n         file.readline()\n         file.readlines()\n         file.write(sq)\n         file.writelines(sq)\n    写入多行\n    file_object.writelines(list_of_text_strings)\n\nF.close()\n#关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。如果一个文件在关闭后还对其进行操作会产生ValueError\nF.flush()\n#把缓冲区的内容写入硬盘\nF.fileno()\n#返回一个长整型的”文件标签“\nF.isatty()\n#文件是否是一个终端设备文件（unix系统中的）\nF.tell()\n#返回文件操作标记的当前位置，以文件的开头为原点\nF.next()\n#返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in file这样的语句时，就是调用next()函数来实现遍历的。\nF.seek(offset[,whence]) \n</pre>', 'Python Read&Write', '', 'inherit', 'open', 'open', '', '208-revision', '', '', '2014-06-09 01:49:09', '2014-06-09 01:49:09', '', 208, 'http://codeseeking.sinaapp.com/?p=209', 0, 'revision', '', 0),
(210, 1, '2014-06-09 01:49:14', '2014-06-09 01:49:14', '<pre lang="python" colla="+">\r\n         try:\r\n		outfile = file(filetowrite,"w")\r\n	except IOError:\r\n		sys.stderr.write("Can not open the file")\r\n		sys.exit(1)\r\n         file.open("file''s name","w/r")\r\n         file.read([size])\r\n         file.readline([size])\r\n         file.readline()\r\n         file.readlines()\r\n         file.write(sq)\r\n         file.writelines(sq)\r\n    写入多行\r\n    file_object.writelines(list_of_text_strings)\r\nF.close()\r\n#关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。如果一个文件在关闭后还对其进行操作会产生ValueError\r\nF.flush()\r\n#把缓冲区的内容写入硬盘\r\nF.fileno()\r\n#返回一个长整型的”文件标签“\r\nF.isatty()\r\n#文件是否是一个终端设备文件（unix系统中的）\r\nF.tell()\r\n#返回文件操作标记的当前位置，以文件的开头为原点\r\nF.next()\r\n#返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in file这样的语句时，就是调用next()函数来实现遍历的。\r\nF.seek(offset[,whence]) \r\n</pre>', 'Python Read&Write', '', 'inherit', 'open', 'open', '', '208-revision-2', '', '', '2014-06-09 01:49:14', '2014-06-09 01:49:14', '', 208, 'http://codeseeking.sinaapp.com/?p=210', 0, 'revision', '', 0),
(211, 1, '2014-06-09 02:17:36', '2014-06-09 02:17:36', '<pre lang="python" colla="+">\n         try:\n		outfile = file(filetowrite,"w")\n	except IOError:\n		sys.stderr.write("Can not open the file")\n		sys.exit(1)\n         file.write("%\n\n         file.open("file''s name","w/r")\n         file.read([size])\n         file.readline([size])\n         file.readline()\n         file.readlines()\n         file.write(sq)\n         file.writelines(sq)\n         #写入多行\n         file_object.writelines(list_of_text_strings)\n         F.close()\n         #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。如果一个文件在关闭后还对其进行操作会产生ValueError\n         F.flush()\n         #把缓冲区的内容写入硬盘\n         F.fileno()\n         #返回一个长整型的”文件标签“\n         F.isatty()\n         #文件是否是一个终端设备文件（unix系统中的）\n         F.tell()\n         #返回文件操作标记的当前位置，以文件的开头为原点\n         F.next()\n         #返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in file这样的语句时，就是调用next()函数来实现遍历的。\n         F.seek(offset[,whence]) \n</pre>', 'Python Read&Write', '', 'inherit', 'open', 'open', '', '208-autosave', '', '', '2014-06-09 02:17:36', '2014-06-09 02:17:36', '', 208, 'http://codeseeking.sinaapp.com/?p=211', 0, 'revision', '', 0),
(212, 1, '2014-06-09 01:50:21', '2014-06-09 01:50:21', '<pre lang="python" colla="+">\r\n         try:\r\n		outfile = file(filetowrite,"w")\r\n	except IOError:\r\n		sys.stderr.write("Can not open the file")\r\n		sys.exit(1)\r\n         file.open("file''s name","w/r")\r\n         file.read([size])\r\n         file.readline([size])\r\n         file.readline()\r\n         file.readlines()\r\n         file.write(sq)\r\n         file.writelines(sq)\r\n         #写入多行\r\n         file_object.writelines(list_of_text_strings)\r\n         F.close()\r\n         #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。如果一个文件在关闭后还对其进行操作会产生ValueError\r\n         F.flush()\r\n         #把缓冲区的内容写入硬盘\r\n         F.fileno()\r\n         #返回一个长整型的”文件标签“\r\n         F.isatty()\r\n         #文件是否是一个终端设备文件（unix系统中的）\r\n         F.tell()\r\n         #返回文件操作标记的当前位置，以文件的开头为原点\r\n         F.next()\r\n         #返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in file这样的语句时，就是调用next()函数来实现遍历的。\r\n         F.seek(offset[,whence]) \r\n</pre>', 'Python Read&Write', '', 'inherit', 'open', 'open', '', '208-revision-3', '', '', '2014-06-09 01:50:21', '2014-06-09 01:50:21', '', 208, 'http://codeseeking.sinaapp.com/?p=212', 0, 'revision', '', 0),
(213, 1, '2014-06-09 02:47:43', '2014-06-09 02:47:43', '1.遇到的一个好用又麻烦的问题，s-3，进行查找标记后，虽然可以快速跳跃，但是标记的mark会一直保留着，导致中间粘贴什么的很麻烦，所以需要匹配完去掉。:nohl就可以了\r\n<pre lang="vim" colla="+">\r\nset hlsearch "打开高亮搜索“\r\nset nohlsearch "关闭高亮搜索”\r\n:nohl "只取消掉当前的搜索高亮“\r\n</pre>\r\n2.长行移动的问题，在行非常长的时候，挪动光标不会挪看到的下一行而是真实的下一行，所以，利用 g 然后 hjkl 或者上下左右就可以随便挪了。\r\n3.VIM 则提供了很多强大的命令来满足你控制光标的欲望。当光标从一点移动到另外一点，在这两点之间的文本（包括这两个点）称作被“跨过”，这里的命令也被称作是 motion。（简单说明一下，后面会用到这个重要的概念）这里是常用到的一些命令（motion）：\r\n<pre lang="vim" colla="-">\r\n    fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。\r\n    tx：和上面的命令类似，但是是移动到 x 的左边一个位置。（这真的很有用）\r\n    Fx：和 fx 类似，不过是往回找。\r\n    w：光标往前移动一个词。\r\n    b：光标往后移动一个词。\r\n    0：移动光标到当前行首。\r\n    ^：移动光标到当前行的第一个字母位置。\r\n    $：移动光标到行尾。\r\n    )：移动光标到下一个句子。\r\n    ( ：移动光标到上一个句子。\r\n</pre>\r\n4.在整个文件里面有效移动光标\r\nVIM 有很多命令，可以用来到达文件里面你想到达的地方。下面是一些在文件里面移动的命令：\r\n<pre lang="vim" colla="-">\r\n    <C-F>：向下移动一屏。\r\n    <C-B>：向上移动一屏。\r\n    G：到文件尾\r\n    numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）\r\n    gg：到文件首\r\n    H：移动光标到屏幕上面\r\n    M：移动光标到屏幕中间\r\n    L：移动光标到屏幕下面\r\n    *：读取光标处的字符串，并且移动光标到它再次出现的地方。\r\n    #：和上面的类似，但是是往反方向寻找。\r\n    /text：从当前光标处开始搜索字符串 text，并且到达 text 出现的地方。必须使用回车来开始这个搜索命令。如果想重复上次的搜索的话，按 n。\r\n    ？text：和上面类似，但是是反方向。\r\n    ma：在当前光标的位置标记一个书签，名字为 a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了。\r\n    `a：到书签 a 处。注意这个不是单引号，它一般位于大部分键盘的 1 的左边。\r\n    `.：到你上次编辑文件的地方。这个命令很有用，而且你不用自己去标记它。\r\n</pre>\r\n5.高效输入 \r\n<pre lang="vim" colla="-">  \r\n     i：在当前字符的左边插入\r\n    I：在当前行首插入\r\n    a：在当前字符的右边插入\r\n    A：在当前行尾插入\r\n    o：在当前行下面插入一个新行\r\n    O：在当前行上面插入一个新行\r\n    c{motion}：删除 motion 命令跨过的字符，并且进入插入模式。比如：c$，这将会删除从光标位置到行尾的字符并且进入插入模式。ct！，这会删除从光标位置到下一个叹号（但不包 括），然后进入插入模式。被删除的字符被存在了剪贴板里面，并且可以再粘贴出来。\r\n    d{motion}：和上面差不多，但是不进入插入模式。\r\n</pre>\r\n6.查找和替换\r\n替换全部的词\r\n<pre lang="vim" colla="+">\r\n  :%s/four/4/g\r\n</pre>\r\n“%” 范围前缀表示在所有行中执行替换。最后的 “g” 标记表示替换行中的所有匹配点。如果仅仅对当前行进行操作，那么只要去掉%即可,但是这样替换会将某些词中间的four给替换成4，所以要将four前后限定出来，即用 “\\<” 来指定匹配单词开头"\\>"结尾：\r\n<pre lang="vim" colla="-">\r\n  :%s/\\<four\\>/4/g\r\n</pre>\r\n如果你在编码，你可能只想替换注释中的 “four”，而保留代码中的。由于这很难指定，可以在替换命令中加一个 “c” 标 记“gc”，这样，Vim 会在每次替换前提示你\r\n', 'to VIM to code. ', '', 'publish', 'open', 'open', '', 'to-vim-to-code', '', '', '2014-06-09 02:47:43', '2014-06-09 02:47:43', '', 0, 'http://codeseeking.sinaapp.com/?p=213', 0, 'post', '', 0),
(214, 1, '2014-06-09 02:23:34', '2014-06-09 02:23:34', '首先是遇到的一个好用又麻烦的问题，s-3，进行查找标记后，虽然可以快速跳跃，但是标记的mark会一直保留着，导致中间粘贴什么的很麻烦，所以需要匹配完去掉。:nohl就可以了\n<pre lang="python" colla=', 'to VIM to code. ', '', 'inherit', 'open', 'open', '', '213-revision', '', '', '2014-06-09 02:23:34', '2014-06-09 02:23:34', '', 213, 'http://codeseeking.sinaapp.com/?p=214', 0, 'revision', '', 0),
(215, 1, '2014-06-09 02:24:34', '2014-06-09 02:24:34', '首先是遇到的一个好用又麻烦的问题，s-3，进行查找标记后，虽然可以快速跳跃，但是标记的mark会一直保留着，导致中间粘贴什么的很麻烦，所以需要匹配完去掉。:nohl就可以了\n<pre lang="shell" colla="+">\nset hlsearch "打开高亮搜索\nset nohlsearch "关闭高亮搜索\n:nohl "只取消掉当前的搜索高亮\n</pre>', 'to VIM to code. ', '', 'inherit', 'open', 'open', '', '213-revision-2', '', '', '2014-06-09 02:24:34', '2014-06-09 02:24:34', '', 213, 'http://codeseeking.sinaapp.com/?p=215', 0, 'revision', '', 0),
(216, 1, '2014-06-09 02:34:21', '2014-06-09 02:34:21', '1.遇到的一个好用又麻烦的问题，s-3，进行查找标记后，虽然可以快速跳跃，但是标记的mark会一直保留着，导致中间粘贴什么的很麻烦，所以需要匹配完去掉。:nohl就可以了\r\n<pre lang="vim" colla="+">\r\nset hlsearch "打开高亮搜索\r\nset nohlsearch "关闭高亮搜索\r\n:nohl "只取消掉当前的搜索高亮\r\n</pre>\r\n2.长行移动的问题，在行非常长的时候，挪动光标不会挪看到的下一行而是真实的下一行，所以，利用 g 然后 hjkl 或者上下左右就可以随便挪了。\r\n3.VIM 则提供了很多强大的命令来满足你控制光标的欲望。当光标从一点移动到另外一点，在这两点之间的文本（包括这两个点）称作被“跨过”，这里的命令也被称作是 motion。（简单说明一下，后面会用到这个重要的概念）这里是常用到的一些命令（motion）：\r\n<pre lang="vim" colla="-">\r\n    fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。\r\n    tx：和上面的命令类似，但是是移动到 x 的左边一个位置。（这真的很有用）\r\n    Fx：和 fx 类似，不过是往回找。\r\n    w：光标往前移动一个词。\r\n    b：光标往后移动一个词。\r\n    0：移动光标到当前行首。\r\n    ^：移动光标到当前行的第一个字母位置。\r\n    $：移动光标到行尾。\r\n    )：移动光标到下一个句子。\r\n    ( ：移动光标到上一个句子。\r\n</pre>\r\n4.在整个文件里面有效移动光标\r\nVIM 有很多命令，可以用来到达文件里面你想到达的地方。下面是一些在文件里面移动的命令：\r\n<pre lang="vim" colla="-">\r\n    <C-F>：向下移动一屏。\r\n    <C-B>：向上移动一屏。\r\n    G：到文件尾\r\n    numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）\r\n    gg：到文件首\r\n    H：移动光标到屏幕上面\r\n    M：移动光标到屏幕中间\r\n    L：移动光标到屏幕下面\r\n    *：读取光标处的字符串，并且移动光标到它再次出现的地方。\r\n    #：和上面的类似，但是是往反方向寻找。\r\n    /text：从当前光标处开始搜索字符串 text，并且到达 text 出现的地方。必须使用回车来开始这个搜索命令。如果想重复上次的搜索的话，按 n。\r\n    ？text：和上面类似，但是是反方向。\r\n    ma：在当前光标的位置标记一个书签，名字为 a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了。\r\n    `a：到书签 a 处。注意这个不是单引号，它一般位于大部分键盘的 1 的左边。\r\n    `.：到你上次编辑文件的地方。这个命令很有用，而且你不用自己去标记它。\r\n</pre>\r\n5.高效输入 \r\n<pre lang="vim" colla="-">  \r\n     i：在当前字符的左边插入\r\n    I：在当前行首插入\r\n    a：在当前字符的右边插入\r\n    A：在当前行尾插入\r\n    o：在当前行下面插入一个新行\r\n    O：在当前行上面插入一个新行\r\n    c{motion}：删除 motion 命令跨过的字符，并且进入插入模式。比如：c$，这将会删除从光标位置到行尾的字符并且进入插入模式。ct！，这会删除从光标位置到下一个叹号（但不包 括），然后进入插入模式。被删除的字符被存在了剪贴板里面，并且可以再粘贴出来。\r\n    d{motion}：和上面差不多，但是不进入插入模式。\r\n</pre>', 'to VIM to code. ', '', 'inherit', 'open', 'open', '', '213-revision-3', '', '', '2014-06-09 02:34:21', '2014-06-09 02:34:21', '', 213, 'http://codeseeking.sinaapp.com/?p=216', 0, 'revision', '', 0),
(217, 1, '2014-06-10 10:36:29', '0000-00-00 00:00:00', '', '自动草稿', '', 'auto-draft', 'open', 'open', '', '', '', '', '2014-06-10 10:36:29', '0000-00-00 00:00:00', '', 0, 'http://codeseeking.sinaapp.com/?p=217', 0, 'post', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(218, 1, '2014-06-11 01:20:29', '2014-06-11 01:20:29', '.h file\r\n<pre lang="c" colla="-">\r\n#ifndef CLIENT_H_\r\n#define CLIENT_H_\r\n\r\n#include <sys/socket.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/ioctl.h>\r\n#include <netinet/in.h>\r\n#include <sys/stat.h>\r\n#include <netdb.h>\r\n#include <errno.h>\r\n#include <arpa/inet.h>\r\n#include <sys/stat.h>\r\n#include <string>\r\n#include <list>\r\n\r\n\r\n#define INVALID_SOCKET				-1\r\n#define FTP_API						int\r\n#define MAX_PATH					260\r\n#define trace						printf\r\n\r\n#define FTP_PARAM_BASE\r\n#define FTP_DEFAULT_PORT			"21"							//FTP默认端口号\r\n#define FTP_DEFAULT_BUFFER			1024*4							//FTP下载缓冲默认大小\r\n#define FTP_DEFAULT_PATH			"/mnt/dvs/"						//FTP默认保存路径\r\n	\r\n#define FTP_COMMAND_BASE			1000\r\n#define FTP_COMMAND_END				FTP_COMMAND_BASE + 30\r\n#define FTP_COMMAND_USERNAME		FTP_COMMAND_BASE + 1			//用户名\r\n#define FTP_COMMAND_PASSWORD		FTP_COMMAND_BASE + 2			//密码\r\n#define FTP_COMMAND_QUIT			FTP_COMMAND_BASE + 3			//退出\r\n#define FTP_COMMAND_CURRENT_PATH	FTP_COMMAND_BASE + 4			// 获取文件路径\r\n#define FTP_COMMAND_TYPE_MODE		FTP_COMMAND_BASE + 5			// 改变传输模式\r\n#define FTP_COMMAND_PSAV_MODE		FTP_COMMAND_BASE + 6			// 被动端口模式\r\n#define FTP_COMMAND_DIR				FTP_COMMAND_BASE + 7			// 获取文件列表\r\n#define FTP_COMMAND_CHANGE_DIRECTORY FTP_COMMAND_BASE + 8			// 改变路径\r\n#define FTP_COMMAND_DELETE_FILE		FTP_COMMAND_BASE + 9			// 删除文件\r\n#define FTP_COMMAND_DELETE_DIRECTORY FTP_COMMAND_BASE + 10			// 删除目录/文件夹\r\n#define FTP_COMMAND_CREATE_DIRECTORY FTP_COMMAND_BASE + 11			// 创建目录/文件夹\r\n#define FTP_COMMAND_RENAME_BEGIN    FTP_COMMAND_BASE  +12			// 开始重命名\r\n#define FTP_COMMAND_RENAME_END      FTP_COMMAND_BASE + 13			// 重命名结束\r\n#define FTP_COMMAND_FILE_SIZE		FTP_COMMAND_BASE + 14			// 获取文件大小\r\n#define FTP_COMMAND_DOWNLOAD_POS	FTP_COMMAND_BASE + 15			// 下载文件从指定位置开始\r\n#define FTP_COMMAND_DOWNLOAD_FILE	FTP_COMMAND_BASE + 16			// 下载文件\r\n#define FTP_COMMAND_UPLOAD_FILE		FTP_COMMAND_BASE + 17			// 上传文件\r\n#define FTP_COMMAND_APPEND_FILE		FTP_COMMAND_BASE + 18			// 追加上载文件	\r\n\r\n/*		  登陆步骤\r\n		login2Server\r\n			|\r\n		inputUserName\r\n			|\r\n		inputPassWord\r\n			|\r\n		  具体操作\r\n			|\r\n		  quit\r\n*/\r\n\r\nclass CFTPManager \r\n{\r\npublic :\r\n	\r\n	enum type {\r\n		binary = 0x31,\r\n		ascii,\r\n	};\r\n	\r\n	CFTPManager(void);\r\n\r\n	virtual ~CFTPManager(void);\r\n	\r\n	// ! 登陆服务器\r\n	FTP_API login2Server(const std::string &serverIP);\r\n\r\n	// !输入用户名\r\n	FTP_API inputUserName(const std::string &userName);\r\n\r\n	// !输入密码\r\n	FTP_API inputPassWord(const std::string &password);\r\n\r\n	// !退出FTP\r\n	FTP_API quitServer(void);\r\n\r\n	// !命令： PWD\r\n	const std::string PWD();\r\n\r\n	// !设置传输格式 2进制  还是ascii方式传输\r\n	FTP_API setTransferMode(type mode);\r\n\r\n	// !设置为被动模式\r\n	const std::string Pasv();\r\n\r\n	// ! 命令： DIR\r\n	const std::string Dir(const std::string &path);\r\n\r\n	// !命令 ： CD\r\n	FTP_API CD(const std::string &path);\r\n\r\n	// ！删除文件\r\n	FTP_API DeleteFile(const std::string &strRemoteFile);\r\n\r\n	// ! 删除文件夹/目录\r\n	FTP_API DeleteDirectory(const std::string &strRemoteDir);\r\n\r\n	// ! 创建目录/文件夹\r\n	FTP_API CreateDirectory(const std::string &strRemoteDir);\r\n\r\n	// !重命名\r\n	FTP_API Rename(const std::string &strRemoteFile, const std::string &strNewFile);\r\n\r\n	// !获取文件大小\r\n	long getFileLength(const std::string &strRemoteFile);\r\n\r\n	// !关闭连接\r\n	void Close(int sock);\r\n\r\n	// 下载文件\r\n	FTP_API Get(const std::string &strRemoteFile, const std::string &strLocalFile);\r\n\r\n	// 上载文件  支持断电传送方式\r\n	FTP_API Put(const std::string &strRemoteFile, const std::string &strLocalFile);\r\n\r\n\r\nprivate:\r\n	// !合成发送到服务器的命令\r\n	const std::string parseCommand(const unsigned int command, const std::string &strParam);\r\n\r\n	// ! 建立连接\r\n	FTP_API Connect(int socketfd, const std::string &serverIP, unsigned int nPort);\r\n\r\n	// ! 返回服务器信息\r\n	const std::string serverResponse(int sockfd);\r\n\r\n	// !获取服务器数据\r\n	FTP_API getData(int fd, char *strBuf, unsigned long length);\r\n\r\n	// !发送命令\r\n	FTP_API Send(int fd, const std::string &cmd);\r\n\r\n	// !发送命令\r\n	FTP_API Send(int fd, const char *cmd, const size_t len);\r\n\r\n	// !建立数据连接\r\n	FTP_API createDataLink(int data_fd);\r\n\r\n	// !解析PASV模式返回的字符串获取FTP端口号和FTP服务器IP\r\n	FTP_API ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp);\r\n\r\n	// 打开本地文件\r\n	FILE *createLocalFile(const std::string &strLocalFile);\r\n\r\n	// 下载文件 \r\n	FTP_API downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos = 0, const unsigned int length = 0);\r\n\r\n	// 解析返回ftp命令的值\r\n	FTP_API parseResponse(const std::string &str);\r\n\r\nprivate:\r\n	//！控制连接套接字\r\n	int		m_cmdSocket;\r\n	\r\n	// !当前用户名\r\n	std::string m_strUserName;\r\n\r\n	// !当前用户密码\r\n	std::string m_strPassWord;\r\n\r\n	// !服务器的IP\r\n	std::string m_strServerIP;\r\n\r\n	// !服务器Port\r\n	unsigned int m_nServerPort;\r\n\r\n	// !服务器回应信息缓存\r\n	std::string m_strResponse;\r\n\r\n	// !保存命令参数\r\n	std::string m_commandStr;\r\n\r\n	// ！当前使用的命令参数\r\n	unsigned int m_nCurrentCommand;\r\n\r\n	// !是否登陆标志。\r\n	bool	m_bLogin;\r\n};\r\n#endif\r\n</pre>\r\n.cpp file\r\n<pre lang="c" colla="-">\r\n#include "../Source/FTPManager.h"\r\n\r\nstatic int SplitString( std::string strSrc, std::list<std::string> &strArray , std::string strFlag)\r\n{\r\n	int pos = 1; \r\n\r\n	while((pos = (int)strSrc.find_first_of(strFlag.c_str())) > 0) \r\n	{\r\n		strArray.insert(strArray.end(), strSrc.substr(0 , pos));\r\n		strSrc = strSrc.substr(pos + 1, strSrc.length() - pos - 1); \r\n	}\r\n\r\n	strArray.insert(strArray.end(), strSrc.substr(0, strSrc.length()));\r\n\r\n	return 0; \r\n}\r\n\r\nCFTPManager::CFTPManager(void): m_bLogin(false)\r\n{\r\n	m_cmdSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n	\r\n}\r\n\r\nCFTPManager::~CFTPManager(void)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\r\n\r\n	Send(m_cmdSocket, strCmdLine.c_str());\r\n	close(m_cmdSocket);\r\n	m_bLogin = false;\r\n}\r\n\r\nFTP_API CFTPManager::login2Server(const std::string &serverIP)\r\n{\r\n	std::string strPort;\r\n	int pos = serverIP.find_first_of(":");\r\n\r\n	if (pos > 0)\r\n	{\r\n		strPort = serverIP.substr(pos + 1, serverIP.length() - pos);\r\n	}\r\n	else\r\n	{\r\n		pos = serverIP.length();\r\n		strPort = FTP_DEFAULT_PORT;\r\n	}\r\n\r\n	m_strServerIP = serverIP.substr(0, pos);\r\n	m_nServerPort = atol(strPort.c_str());\r\n\r\n	trace("IP: %s port: %d\\n", m_strServerIP.c_str(), m_nServerPort);\r\n\r\n	if (Connect(m_cmdSocket, m_strServerIP, m_nServerPort) < 0)\r\n	{\r\n		\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("@@@@Response: %s", m_strResponse.c_str());\r\n\r\n	return	parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::inputUserName(const std::string &userName)\r\n{\r\n	std::string strCommandLine = parseCommand(FTP_COMMAND_USERNAME, userName);\r\n\r\n	m_strUserName = userName;\r\n\r\n	if (Send(m_cmdSocket, strCommandLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::inputPassWord(const std::string &password)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PASSWORD, password);\r\n\r\n	m_strPassWord = password;\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	else\r\n	{\r\n		m_bLogin = true;\r\n\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n		printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n}\r\n\r\nFTP_API CFTPManager::quitServer(void)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	else\r\n	{\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n		printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n\r\n}\r\n\r\nconst std::string CFTPManager::PWD()\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CURRENT_PATH, "");\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		return serverResponse(m_cmdSocket);\r\n	}\r\n}\r\n\r\n\r\nFTP_API CFTPManager::setTransferMode(type mode)\r\n{\r\n	std::string strCmdLine;\r\n\r\n	switch (mode)\r\n	{\r\n	case binary:\r\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "I");\r\n		break;\r\n	case ascii:\r\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "A");\r\n		break;\r\n	default:\r\n		break;\r\n	}\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		assert(false);\r\n	}\r\n	else\r\n	{	\r\n		m_strResponse  = serverResponse(m_cmdSocket);\r\n		printf("@@@@Response: %s", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n}\r\n\r\n\r\nconst std::string CFTPManager::Pasv()\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PSAV_MODE, "");\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n		return m_strResponse;\r\n	}\r\n}\r\n\r\n\r\nconst std::string CFTPManager::Dir(const std::string &path)\r\n{\r\n	int dataSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	if (createDataLink(dataSocket) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	// 数据连接成功\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DIR, path);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n		close(dataSocket);\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n		m_strResponse = serverResponse(dataSocket);\r\n\r\n		trace("@@@@Response: \\n%s\\n", m_strResponse.c_str());\r\n		close(dataSocket);\r\n\r\n		return m_strResponse;\r\n	}\r\n	\r\n}\r\n\r\n\r\nFTP_API CFTPManager::CD(const std::string &path)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CHANGE_DIRECTORY, path);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n		\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::DeleteFile(const std::string &strRemoteFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_FILE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::DeleteDirectory(const std::string &strRemoteDir)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_DIRECTORY, strRemoteDir);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::CreateDirectory(const std::string &strRemoteDir)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CREATE_DIRECTORY, strRemoteDir);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::Rename(const std::string &strRemoteFile, const std::string &strNewFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_RENAME_BEGIN, strRemoteFile);\r\n	Send(m_cmdSocket, strCmdLine);\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	Send(m_cmdSocket, parseCommand(FTP_COMMAND_RENAME_END, strNewFile));\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nlong CFTPManager::getFileLength(const std::string &strRemoteFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_FILE_SIZE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n\r\n	std::string strData = m_strResponse.substr(0, 3);\r\n	unsigned long val = atol(strData.c_str());\r\n\r\n	if (val == 213)\r\n	{\r\n		strData = m_strResponse.substr(4);\r\n		trace("strData: %s\\n", strData.c_str());\r\n		val = atol(strData.c_str());\r\n\r\n		return val;\r\n	}\r\n\r\n	return -1;\r\n}\r\n\r\n\r\nvoid CFTPManager::Close(int sock)\r\n{\r\n	shutdown(sock, SHUT_RDWR);\r\n	close(sock);\r\n	sock = INVALID_SOCKET;\r\n}\r\n\r\nFTP_API CFTPManager::Get(const std::string &strRemoteFile, const std::string &strLocalFile)\r\n{\r\n	return downLoad(strRemoteFile, strLocalFile);\r\n}\r\n\r\n\r\nFTP_API CFTPManager::Put(const std::string &strRemoteFile, const std::string &strLocalFile)\r\n{\r\n	std::string strCmdLine;\r\n	const unsigned long dataLen = FTP_DEFAULT_BUFFER;\r\n	char strBuf[dataLen] = {0};\r\n	unsigned long nSize = getFileLength(strRemoteFile);\r\n	unsigned long nLen = 0;\r\n// 	struct stat sBuf;\r\n// \r\n// 	assert(stat(strLocalFile.c_str(), &sBuf) == 0);\r\n// 	trace("size: %d\\n", sBuf.st_size);\r\n\r\n	FILE *pFile = fopen(strLocalFile.c_str(), "rb");  // 以只读方式打开  且文件必须存在\r\n	assert(pFile != NULL);\r\n\r\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\r\n	assert(data_fd != -1);\r\n\r\n	if (createDataLink(data_fd) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	if (nSize == -1)\r\n	{\r\n		strCmdLine = parseCommand(FTP_COMMAND_UPLOAD_FILE, strRemoteFile);\r\n	}\r\n	else\r\n	{\r\n		strCmdLine = parseCommand(FTP_COMMAND_APPEND_FILE, strRemoteFile);\r\n	}\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		Close(data_fd);\r\n		return -1;\r\n	}\r\n\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	fseek(pFile, nSize, SEEK_SET);\r\n	while (!feof(pFile))\r\n	{\r\n		nLen = fread(strBuf, 1, dataLen, pFile);\r\n		if (nLen < 0)\r\n		{\r\n			break;\r\n		}\r\n\r\n		if (Send(data_fd, strBuf) < 0)\r\n		{\r\n			Close(data_fd);\r\n			return -1;\r\n		}\r\n	}\r\n\r\n	trace("@@@@Response: %s\\n", serverResponse(data_fd).c_str());\r\n\r\n	Close(data_fd);\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n	fclose(pFile);\r\n\r\n	return 0;\r\n}\r\n\r\nconst std::string CFTPManager::parseCommand(const unsigned int command, const std::string &strParam)\r\n{\r\n	if (command < FTP_COMMAND_BASE || command > FTP_COMMAND_END)\r\n	{\r\n		return "";\r\n	}\r\n\r\n	std::string strCommandLine;\r\n\r\n	m_nCurrentCommand = command;\r\n	m_commandStr.clear();\r\n\r\n	switch (command)\r\n	{\r\n	case FTP_COMMAND_USERNAME:\r\n		strCommandLine = "USER ";\r\n		break;\r\n	case FTP_COMMAND_PASSWORD:\r\n		strCommandLine = "PASS ";\r\n		break;\r\n	case FTP_COMMAND_QUIT:\r\n		strCommandLine = "QUIT ";\r\n		break;\r\n	case FTP_COMMAND_CURRENT_PATH:\r\n		strCommandLine = "PWD ";\r\n		break;\r\n	case FTP_COMMAND_TYPE_MODE:\r\n		strCommandLine = "TYPE ";\r\n		break;\r\n	case FTP_COMMAND_PSAV_MODE:\r\n		strCommandLine = "PASV ";\r\n		break;\r\n	case FTP_COMMAND_DIR:\r\n		strCommandLine = "LIST ";\r\n		break;\r\n	case FTP_COMMAND_CHANGE_DIRECTORY:\r\n		strCommandLine = "CWD ";\r\n		break;\r\n	case FTP_COMMAND_DELETE_FILE:\r\n		strCommandLine = "DELE ";\r\n		break;\r\n	case FTP_COMMAND_DELETE_DIRECTORY:\r\n		strCommandLine = "RMD ";\r\n		break;\r\n	case FTP_COMMAND_CREATE_DIRECTORY:\r\n		strCommandLine = "MKD ";\r\n		break;\r\n	case FTP_COMMAND_RENAME_BEGIN:\r\n		strCommandLine = "RNFR ";\r\n		break;\r\n	case FTP_COMMAND_RENAME_END:\r\n		strCommandLine = "RNTO ";\r\n		break;\r\n	case FTP_COMMAND_FILE_SIZE:\r\n		strCommandLine = "SIZE ";\r\n		break;\r\n	case FTP_COMMAND_DOWNLOAD_FILE:\r\n		strCommandLine = "RETR ";\r\n		break;\r\n	case FTP_COMMAND_DOWNLOAD_POS:\r\n		strCommandLine = "REST ";\r\n		break;\r\n	case FTP_COMMAND_UPLOAD_FILE:\r\n		strCommandLine = "STOR ";\r\n		break;\r\n	case FTP_COMMAND_APPEND_FILE:\r\n		strCommandLine = "APPE ";\r\n		break;\r\n	default :\r\n		break;\r\n	}\r\n\r\n	strCommandLine += strParam;\r\n	strCommandLine += "\\r\\n";\r\n\r\n	m_commandStr = strCommandLine;\r\n	trace("parseCommand: %s\\n", m_commandStr.c_str());\r\n\r\n	return m_commandStr;\r\n}\r\n\r\nFTP_API CFTPManager::Connect(int socketfd, const std::string &serverIP, unsigned int nPort)\r\n{\r\n	if (socketfd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	unsigned int argp = 1;\r\n	int error = -1;\r\n	int len = sizeof(int);\r\n	struct sockaddr_in  addr;\r\n	bool ret = false;\r\n	timeval stime;\r\n	fd_set  set;\r\n\r\n	ioctl(socketfd, FIONBIO, &argp);  //设置为非阻塞模式\r\n\r\n	memset(&addr, 0, sizeof(struct sockaddr_in));\r\n	addr.sin_family = AF_INET;\r\n	addr.sin_port	= htons(nPort);\r\n	addr.sin_addr.s_addr = inet_addr(serverIP.c_str());\r\n	bzero(&(addr.sin_zero), 8);\r\n\r\n	trace("Address: %s %d\\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));\r\n	\r\n	if (connect(socketfd, (struct sockaddr*)&addr, sizeof(struct sockaddr)) == -1)   //若直接返回 则说明正在进行TCP三次握手\r\n	{\r\n		stime.tv_sec = 20;  //设置为1秒超时\r\n		stime.tv_usec = 0;\r\n		FD_ZERO(&set);\r\n		FD_SET(socketfd, &set);\r\n\r\n		if (select(socketfd + 1, NULL, &set, NULL, &stime) > 0)   ///在这边等待 阻塞 返回可以读的描述符 或者超时返回0  或者出错返回-1\r\n		{\r\n			getsockopt(socketfd, SOL_SOCKET, SO_ERROR, &error, (socklen_t*)&len);\r\n			if (error == 0)\r\n			{\r\n				ret = true;\r\n			}\r\n			else\r\n			{\r\n				ret = false;\r\n			}\r\n		}\r\n	}\r\n	else\r\n	{	trace("Connect Immediately!!!\\n");\r\n		ret = true;\r\n	}\r\n\r\n	argp = 0;\r\n	ioctl(socketfd, FIONBIO, &argp);\r\n\r\n	if (!ret)\r\n	{\r\n		close(socketfd);\r\n		fprintf(stderr, "cannot connect server!!\\n");\r\n		return -1;\r\n	}\r\n\r\n	//fprintf(stdout, "Connect!!!\\n");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\nconst std::string CFTPManager::serverResponse(int sockfd)\r\n{\r\n	if (sockfd == INVALID_SOCKET)\r\n	{\r\n		return "";\r\n	}\r\n	\r\n	int nRet = -1;\r\n	char buf[MAX_PATH] = {0};\r\n\r\n	m_strResponse.clear();\r\n\r\n	while ((nRet = getData(sockfd, buf, MAX_PATH)) > 0)\r\n	{\r\n		buf[MAX_PATH - 1] = ''\\0'';\r\n		m_strResponse += buf;\r\n	}\r\n\r\n	return m_strResponse;\r\n}\r\n\r\nFTP_API CFTPManager::getData(int fd, char *strBuf, unsigned long length)\r\n{\r\n	assert(strBuf != NULL);\r\n\r\n	if (fd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	memset(strBuf, 0, length);\r\n	timeval stime;\r\n	int nLen;\r\n\r\n	stime.tv_sec = 1;\r\n	stime.tv_usec = 0;\r\n\r\n	fd_set	readfd;\r\n	FD_ZERO( &readfd );\r\n	FD_SET(fd, &readfd );\r\n\r\n	if (select(fd + 1, &readfd, 0, 0, &stime) > 0)\r\n	{\r\n		if ((nLen = recv(fd, strBuf, length, 0)) > 0)\r\n		{\r\n			return nLen;\r\n		}\r\n		else\r\n		{\r\n			return -2;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\nFTP_API CFTPManager::Send(int fd, const std::string &cmd)\r\n{\r\n	if (fd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	return Send(fd, cmd.c_str(), cmd.length());\r\n}\r\n\r\nFTP_API CFTPManager::Send(int fd, const char *cmd, const size_t len)\r\n{\r\n	if((FTP_COMMAND_USERNAME != m_nCurrentCommand) \r\n		&&(FTP_COMMAND_PASSWORD != m_nCurrentCommand)\r\n		&&(!m_bLogin))\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	timeval timeout;\r\n	timeout.tv_sec  = 1;\r\n	timeout.tv_usec = 0;\r\n\r\n	fd_set  writefd;\r\n	FD_ZERO(&writefd);  \r\n	FD_SET(fd, &writefd);\r\n\r\n	if(select(fd + 1, 0, &writefd , 0 , &timeout) > 0)\r\n	{\r\n		size_t nlen  = len; \r\n		int nSendLen = 0; \r\n		while (nlen >0) \r\n		{\r\n			nSendLen = send(fd, cmd , (int)nlen , 0);\r\n\r\n			if(nSendLen == -1) \r\n				return -2; \r\n\r\n			nlen = nlen - nSendLen;\r\n			cmd +=  nSendLen;\r\n		}\r\n		return 0;\r\n	}\r\n	return -1;\r\n}\r\n\r\n\r\nFTP_API CFTPManager::createDataLink(int data_fd)\r\n{\r\n	assert(data_fd != INVALID_SOCKET);\r\n\r\n	std::string strData;\r\n	unsigned long nPort = 0 ;\r\n	std::string strServerIp ; \r\n	std::list<std::string> strArray ;\r\n\r\n	std::string parseStr = Pasv();\r\n\r\n	if (parseStr.size() <= 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	//trace("parseInfo: %s\\n", parseStr.c_str());\r\n\r\n	size_t nBegin = parseStr.find_first_of("(");\r\n	size_t nEnd	  = parseStr.find_first_of(")");\r\n	strData		  = parseStr.substr(nBegin + 1, nEnd - nBegin - 1);\r\n\r\n	//trace("ParseAfter: %s\\n", strData.c_str());\r\n	if( SplitString( strData , strArray , "," ) <0)\r\n		return -1;\r\n\r\n	if( ParseString( strArray , nPort , strServerIp) < 0)\r\n		return -1;\r\n\r\n	//trace("nPort: %ld IP: %s\\n", nPort, strServerIp.c_str());\r\n\r\n	if (Connect(data_fd, strServerIp, nPort) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	return 0;\r\n\r\n}\r\n\r\nFTP_API CFTPManager::ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp)\r\n{\r\n	if (strArray.size() < 6 )\r\n		return -1 ;\r\n\r\n	std::list<std::string>::iterator citor;\r\n	citor = strArray.begin();\r\n	strServerIp = *citor;\r\n	strServerIp += ".";\r\n	citor ++;\r\n	strServerIp += *citor;\r\n	strServerIp += ".";\r\n	citor ++ ;\r\n	strServerIp += *citor;\r\n	strServerIp += ".";\r\n	citor ++ ;\r\n	strServerIp += *citor;\r\n	citor = strArray.end();\r\n	citor--;\r\n	nPort = atol( (*citor).c_str());\r\n	citor--;\r\n	nPort += atol( (*(citor)).c_str()) * 256 ;\r\n	return 0 ; \r\n}\r\n\r\nFILE *CFTPManager::createLocalFile(const std::string &strLocalFile)\r\n{\r\n	return fopen(strLocalFile.c_str(), "w+b");\r\n}\r\n\r\nFTP_API CFTPManager::downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos, const unsigned int length)\r\n{\r\n	assert(length >= 0);\r\n\r\n	FILE *file = NULL;\r\n	unsigned long nDataLen = FTP_DEFAULT_BUFFER;\r\n	char strPos[MAX_PATH]  = {0};\r\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\r\n	\r\n	assert(data_fd != -1);\r\n\r\n	if ((length != 0) && (length < nDataLen))\r\n	{\r\n		nDataLen = length;\r\n	}\r\n	char *dataBuf = new char[nDataLen];\r\n	assert(dataBuf != NULL);\r\n\r\n	sprintf(strPos, "%d", pos);\r\n\r\n	if (createDataLink(data_fd) < 0)\r\n	{\r\n		trace("@@@@ Create Data Link error!!!\\n");\r\n		return -1;\r\n	}\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_POS, strPos);\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_FILE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	file = createLocalFile(std::string(FTP_DEFAULT_PATH + strLocalFile));\r\n	assert(file != NULL);\r\n	\r\n	int len = 0;\r\n	int nReceiveLen = 0;\r\n	while ((len = getData(data_fd, dataBuf, nDataLen)) > 0)\r\n	{\r\n		nReceiveLen += len;\r\n\r\n		int num = fwrite(dataBuf, 1, len, file);\r\n		memset(dataBuf, 0, sizeof(dataBuf));\r\n	\r\n		//trace("%s", dataBuf);\r\n		trace("Num:%d\\n", num);\r\n		if (nReceiveLen == length && length != 0)\r\n			break;\r\n\r\n		if ((nReceiveLen + nDataLen) > length  && length != 0)\r\n		{\r\n			delete []dataBuf;\r\n			nDataLen = length - nReceiveLen;\r\n			dataBuf = new char[nDataLen];\r\n		}\r\n	}\r\n\r\n	Close(data_fd);\r\n	fclose(file);\r\n	delete []dataBuf;\r\n\r\n	return 0;\r\n}\r\n\r\nFTP_API CFTPManager::parseResponse(const std::string &str)\r\n{\r\n	assert(!str.empty());\r\n\r\n	std::string strData = str.substr(0, 3);\r\n	unsigned int val = atoi(strData.c_str());\r\n\r\n	return val;\r\n}\r\n</pre>\r\n', 'ftp<mark>', '', 'publish', 'open', 'open', '', 'ftp', '', '', '2014-06-11 01:20:29', '2014-06-11 01:20:29', '', 0, 'http://codeseeking.sinaapp.com/?p=218', 0, 'post', '', 0),
(219, 1, '2014-06-11 01:17:39', '2014-06-11 01:17:39', '<pre lang="c++" colla="-">\n#include "../Source/FTPManager.h"\n\nstatic int SplitString( std::string strSrc, std::list<std::string> &strArray , std::string strFlag)\n{\n	int pos = 1; \n\n	while((pos = (int)strSrc.find_first_of(strFlag.c_str())) > 0) \n	{\n		strArray.insert(strArray.end(), strSrc.substr(0 , pos));\n		strSrc = strSrc.substr(pos + 1, strSrc.length() - pos - 1); \n	}\n\n	strArray.insert(strArray.end(), strSrc.substr(0, strSrc.length()));\n\n	return 0; \n}\n\nCFTPManager::CFTPManager(void): m_bLogin(false)\n{\n	m_cmdSocket = socket(AF_INET, SOCK_STREAM, 0);\n	\n}\n\nCFTPManager::~CFTPManager(void)\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\n\n	Send(m_cmdSocket, strCmdLine.c_str());\n	close(m_cmdSocket);\n	m_bLogin = false;\n}\n\nFTP_API CFTPManager::login2Server(const std::string &serverIP)\n{\n	std::string strPort;\n	int pos = serverIP.find_first_of(":");\n\n	if (pos > 0)\n	{\n		strPort = serverIP.substr(pos + 1, serverIP.length() - pos);\n	}\n	else\n	{\n		pos = serverIP.length();\n		strPort = FTP_DEFAULT_PORT;\n	}\n\n	m_strServerIP = serverIP.substr(0, pos);\n	m_nServerPort = atol(strPort.c_str());\n\n	trace("IP: %s port: %d\\n", m_strServerIP.c_str(), m_nServerPort);\n\n	if (Connect(m_cmdSocket, m_strServerIP, m_nServerPort) < 0)\n	{\n		\n		return -1;\n	}\n	\n	m_strResponse = serverResponse(m_cmdSocket);\n	printf("@@@@Response: %s", m_strResponse.c_str());\n\n	return	parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::inputUserName(const std::string &userName)\n{\n	std::string strCommandLine = parseCommand(FTP_COMMAND_USERNAME, userName);\n\n	m_strUserName = userName;\n\n	if (Send(m_cmdSocket, strCommandLine) < 0)\n	{\n		return -1;\n	}\n\n	m_strResponse = serverResponse(m_cmdSocket);\n	printf("Response: %s\\n", m_strResponse.c_str());\n\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::inputPassWord(const std::string &password)\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PASSWORD, password);\n\n	m_strPassWord = password;\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	else\n	{\n		m_bLogin = true;\n\n		m_strResponse = serverResponse(m_cmdSocket);\n		printf("Response: %s\\n", m_strResponse.c_str());\n\n		return parseResponse(m_strResponse);\n	}\n}\n\nFTP_API CFTPManager::quitServer(void)\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	else\n	{\n		m_strResponse = serverResponse(m_cmdSocket);\n		printf("Response: %s\\n", m_strResponse.c_str());\n\n		return parseResponse(m_strResponse);\n	}\n\n}\n\nconst std::string CFTPManager::PWD()\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CURRENT_PATH, "");\n\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\n	{\n		return "";\n	}\n	else\n	{\n		return serverResponse(m_cmdSocket);\n	}\n}\n\n\nFTP_API CFTPManager::setTransferMode(type mode)\n{\n	std::string strCmdLine;\n\n	switch (mode)\n	{\n	case binary:\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "I");\n		break;\n	case ascii:\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "A");\n		break;\n	default:\n		break;\n	}\n\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\n	{\n		assert(false);\n	}\n	else\n	{	\n		m_strResponse  = serverResponse(m_cmdSocket);\n		printf("@@@@Response: %s", m_strResponse.c_str());\n\n		return parseResponse(m_strResponse);\n	}\n}\n\n\nconst std::string CFTPManager::Pasv()\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PSAV_MODE, "");\n\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\n	{\n		return "";\n	}\n	else\n	{\n		m_strResponse = serverResponse(m_cmdSocket);\n\n		return m_strResponse;\n	}\n}\n\n\nconst std::string CFTPManager::Dir(const std::string &path)\n{\n	int dataSocket = socket(AF_INET, SOCK_STREAM, 0);\n\n	if (createDataLink(dataSocket) < 0)\n	{\n		return "";\n	}\n	// 数据连接成功\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DIR, path);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n		close(dataSocket);\n		return "";\n	}\n	else\n	{\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n		m_strResponse = serverResponse(dataSocket);\n\n		trace("@@@@Response: \\n%s\\n", m_strResponse.c_str());\n		close(dataSocket);\n\n		return m_strResponse;\n	}\n	\n}\n\n\nFTP_API CFTPManager::CD(const std::string &path)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CHANGE_DIRECTORY, path);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n		\n	m_strResponse = serverResponse(m_cmdSocket);\n	\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::DeleteFile(const std::string &strRemoteFile)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_FILE, strRemoteFile);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n\n	m_strResponse = serverResponse(m_cmdSocket);\n	printf("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::DeleteDirectory(const std::string &strRemoteDir)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_DIRECTORY, strRemoteDir);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	\n	m_strResponse = serverResponse(m_cmdSocket);\n\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::CreateDirectory(const std::string &strRemoteDir)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CREATE_DIRECTORY, strRemoteDir);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	\n	m_strResponse = serverResponse(m_cmdSocket);\n\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::Rename(const std::string &strRemoteFile, const std::string &strNewFile)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_RENAME_BEGIN, strRemoteFile);\n	Send(m_cmdSocket, strCmdLine);\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	Send(m_cmdSocket, parseCommand(FTP_COMMAND_RENAME_END, strNewFile));\n\n	m_strResponse = serverResponse(m_cmdSocket);\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nlong CFTPManager::getFileLength(const std::string &strRemoteFile)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_FILE_SIZE, strRemoteFile);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n\n	m_strResponse = serverResponse(m_cmdSocket);\n\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n\n	std::string strData = m_strResponse.substr(0, 3);\n	unsigned long val = atol(strData.c_str());\n\n	if (val == 213)\n	{\n		strData = m_strResponse.substr(4);\n		trace("strData: %s\\n", strData.c_str());\n		val = atol(strData.c_str());\n\n		return val;\n	}\n\n	return -1;\n}\n\n\nvoid CFTPManager::Close(int sock)\n{\n	shutdown(sock, SHUT_RDWR);\n	close(sock);\n	sock = INVALID_SOCKET;\n}\n\nFTP_API CFTPManager::Get(const std::string &strRemoteFile, const std::string &strLocalFile)\n{\n	return downLoad(strRemoteFile, strLocalFile);\n}\n\n\nFTP_API CFTPManager::Put(const std::string &strRemoteFile, const std::string &strLocalFile)\n{\n	std::string strCmdLine;\n	const unsigned long dataLen = FTP_DEFAULT_BUFFER;\n	char strBuf[dataLen] = {0};\n	unsigned long nSize = getFileLength(strRemoteFile);\n	unsigned long nLen = 0;\n// 	struct stat sBuf;\n// \n// 	assert(stat(strLocalFile.c_str(), &sBuf) == 0);\n// 	trace("size: %d\\n", sBuf.st_size);\n\n	FILE *pFile = fopen(strLocalFile.c_str(), "rb");  // 以只读方式打开  且文件必须存在\n	assert(pFile != NULL);\n\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\n	assert(data_fd != -1);\n\n	if (createDataLink(data_fd) < 0)\n	{\n		return -1;\n	}\n	\n	if (nSize == -1)\n	{\n		strCmdLine = parseCommand(FTP_COMMAND_UPLOAD_FILE, strRemoteFile);\n	}\n	else\n	{\n		strCmdLine = parseCommand(FTP_COMMAND_APPEND_FILE, strRemoteFile);\n	}\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		Close(data_fd);\n		return -1;\n	}\n\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	fseek(pFile, nSize, SEEK_SET);\n	while (!feof(pFile))\n	{\n		nLen = fread(strBuf, 1, dataLen, pFile);\n		if (nLen < 0)\n		{\n			break;\n		}\n\n		if (Send(data_fd, strBuf) < 0)\n		{\n			Close(data_fd);\n			return -1;\n		}\n	}\n\n	trace("@@@@Response: %s\\n", serverResponse(data_fd).c_str());\n\n	Close(data_fd);\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n	fclose(pFile);\n\n	return 0;\n}\n\nconst std::string CFTPManager::parseCommand(const unsigned int command, const std::string &strParam)\n{\n	if (command < FTP_COMMAND_BASE || command > FTP_COMMAND_END)\n	{\n		return "";\n	}\n\n	std::string strCommandLine;\n\n	m_nCurrentCommand = command;\n	m_commandStr.clear();\n\n	switch (command)\n	{\n	case FTP_COMMAND_USERNAME:\n		strCommandLine = "USER ";\n		break;\n	case FTP_COMMAND_PASSWORD:\n		strCommandLine = "PASS ";\n		break;\n	case FTP_COMMAND_QUIT:\n		strCommandLine = "QUIT ";\n		break;\n	case FTP_COMMAND_CURRENT_PATH:\n		strCommandLine = "PWD ";\n		break;\n	case FTP_COMMAND_TYPE_MODE:\n		strCommandLine = "TYPE ";\n		break;\n	case FTP_COMMAND_PSAV_MODE:\n		strCommandLine = "PASV ";\n		break;\n	case FTP_COMMAND_DIR:\n		strCommandLine = "LIST ";\n		break;\n	case FTP_COMMAND_CHANGE_DIRECTORY:\n		strCommandLine = "CWD ";\n		break;\n	case FTP_COMMAND_DELETE_FILE:\n		strCommandLine = "DELE ";\n		break;\n	case FTP_COMMAND_DELETE_DIRECTORY:\n		strCommandLine = "RMD ";\n		break;\n	case FTP_COMMAND_CREATE_DIRECTORY:\n		strCommandLine = "MKD ";\n		break;\n	case FTP_COMMAND_RENAME_BEGIN:\n		strCommandLine = "RNFR ";\n		break;\n	case FTP_COMMAND_RENAME_END:\n		strCommandLine = "RNTO ";\n		break;\n	case FTP_COMMAND_FILE_SIZE:\n		strCommandLine = "SIZE ";\n		break;\n	case FTP_COMMAND_DOWNLOAD_FILE:\n		strCommandLine = "RETR ";\n		break;\n	case FTP_COMMAND_DOWNLOAD_POS:\n		strCommandLine = "REST ";\n		break;\n	case FTP_COMMAND_UPLOAD_FILE:\n		strCommandLine = "STOR ";\n		break;\n	case FTP_COMMAND_APPEND_FILE:\n		strCommandLine = "APPE ";\n		break;\n	default :\n		break;\n	}\n\n	strCommandLine += strParam;\n	strCommandLine += "\\r\\n";\n\n	m_commandStr = strCommandLine;\n	trace("parseCommand: %s\\n", m_commandStr.c_str());\n\n	return m_commandStr;\n}\n\nFTP_API CFTPManager::Connect(int socketfd, const std::string &serverIP, unsigned int nPort)\n{\n	if (socketfd == INVALID_SOCKET)\n	{\n		return -1;\n	}\n\n	unsigned int argp = 1;\n	int error = -1;\n	int len = sizeof(int);\n	struct sockaddr_in  addr;\n	bool ret = false;\n	timeval stime;\n	fd_set  set;\n\n	ioctl(socketfd, FIONBIO, &argp);  //设置为非阻塞模式\n\n	memset(&addr, 0, sizeof(struct sockaddr_in));\n	addr.sin_family = AF_INET;\n	addr.sin_port	= htons(nPort);\n	addr.sin_addr.s_addr = inet_addr(serverIP.c_str());\n	bzero(&(addr.sin_zero), 8);\n\n	trace("Address: %s %d\\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));\n	\n	if (connect(socketfd, (struct sockaddr*)&addr, sizeof(struct sockaddr)) == -1)   //若直接返回 则说明正在进行TCP三次握手\n	{\n		stime.tv_sec = 20;  //设置为1秒超时\n		stime.tv_usec = 0;\n		FD_ZERO(&set);\n		FD_SET(socketfd, &set);\n\n		if (select(socketfd + 1, NULL, &set, NULL, &stime) > 0)   ///在这边等待 阻塞 返回可以读的描述符 或者超时返回0  或者出错返回-1\n		{\n			getsockopt(socketfd, SOL_SOCKET, SO_ERROR, &error, (socklen_t*)&len);\n			if (error == 0)\n			{\n				ret = true;\n			}\n			else\n			{\n				ret = false;\n			}\n		}\n	}\n	else\n	{	trace("Connect Immediately!!!\\n");\n		ret = true;\n	}\n\n	argp = 0;\n	ioctl(socketfd, FIONBIO, &argp);\n\n	if (!ret)\n	{\n		close(socketfd);\n		fprintf(stderr, "cannot connect server!!\\n");\n		return -1;\n	}\n\n	//fprintf(stdout, "Connect!!!\\n");\n\n	return 0;\n}\n\n\nconst std::string CFTPManager::serverResponse(int sockfd)\n{\n	if (sockfd == INVALID_SOCKET)\n	{\n		return "";\n	}\n	\n	int nRet = -1;\n	char buf[MAX_PATH] = {0};\n\n	m_strResponse.clear();\n\n	while ((nRet = getData(sockfd, buf, MAX_PATH)) > 0)\n	{\n		buf[MAX_PATH - 1] = ''\\0'';\n		m_strResponse += buf;\n	}\n\n	return m_strResponse;\n}\n\nFTP_API CFTPManager::getData(int fd, char *strBuf, unsigned long length)\n{\n	assert(strBuf != NULL);\n\n	if (fd == INVALID_SOCKET)\n	{\n		return -1;\n	}\n\n	memset(strBuf, 0, length);\n	timeval stime;\n	int nLen;\n\n	stime.tv_sec = 1;\n	stime.tv_usec = 0;\n\n	fd_set	readfd;\n	FD_ZERO( &readfd );\n	FD_SET(fd, &readfd );\n\n	if (select(fd + 1, &readfd, 0, 0, &stime) > 0)\n	{\n		if ((nLen = recv(fd, strBuf, length, 0)) > 0)\n		{\n			return nLen;\n		}\n		else\n		{\n			return -2;\n		}\n	}\n	return 0;\n}\n\nFTP_API CFTPManager::Send(int fd, const std::string &cmd)\n{\n	if (fd == INVALID_SOCKET)\n	{\n		return -1;\n	}\n\n	return Send(fd, cmd.c_str(), cmd.length());\n}\n\nFTP_API CFTPManager::Send(int fd, const char *cmd, const size_t len)\n{\n	if((FTP_COMMAND_USERNAME != m_nCurrentCommand) \n		&&(FTP_COMMAND_PASSWORD != m_nCurrentCommand)\n		&&(!m_bLogin))\n	{\n		return -1;\n	}\n\n	timeval timeout;\n	timeout.tv_sec  = 1;\n	timeout.tv_usec = 0;\n\n	fd_set  writefd;\n	FD_ZERO(&writefd);  \n	FD_SET(fd, &writefd);\n\n	if(select(fd + 1, 0, &writefd , 0 , &timeout) > 0)\n	{\n		size_t nlen  = len; \n		int nSendLen = 0; \n		while (nlen >0) \n		{\n			nSendLen = send(fd, cmd , (int)nlen , 0);\n\n			if(nSendLen == -1) \n				return -2; \n\n			nlen = nlen - nSendLen;\n			cmd +=  nSendLen;\n		}\n		return 0;\n	}\n	return -1;\n}\n\n\nFTP_API CFTPManager::createDataLink(int data_fd)\n{\n	assert(data_fd != INVALID_SOCKET);\n\n	std::string strData;\n	unsigned long nPort = 0 ;\n	std::string strServerIp ; \n	std::list<std::string> strArray ;\n\n	std::string parseStr = Pasv();\n\n	if (parseStr.size() <= 0)\n	{\n		return -1;\n	}\n\n	//trace("parseInfo: %s\\n", parseStr.c_str());\n\n	size_t nBegin = parseStr.find_first_of("(");\n	size_t nEnd	  = parseStr.find_first_of(")");\n	strData		  = parseStr.substr(nBegin + 1, nEnd - nBegin - 1);\n\n	//trace("ParseAfter: %s\\n", strData.c_str());\n	if( SplitString( strData , strArray , "," ) <0)\n		return -1;\n\n	if( ParseString( strArray , nPort , strServerIp) < 0)\n		return -1;\n\n	//trace("nPort: %ld IP: %s\\n", nPort, strServerIp.c_str());\n\n	if (Connect(data_fd, strServerIp, nPort) < 0)\n	{\n		return -1;\n	}\n\n	return 0;\n\n}\n\nFTP_API CFTPManager::ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp)\n{\n	if (strArray.size() < 6 )\n		return -1 ;\n\n	std::list<std::string>::iterator citor;\n	citor = strArray.begin();\n	strServerIp = *citor;\n	strServerIp += ".";\n	citor ++;\n	strServerIp += *citor;\n	strServerIp += ".";\n	citor ++ ;\n	strServerIp += *citor;\n	strServerIp += ".";\n	citor ++ ;\n	strServerIp += *citor;\n	citor = strArray.end();\n	citor--;\n	nPort = atol( (*citor).c_str());\n	citor--;\n	nPort += atol( (*(citor)).c_str()) * 256 ;\n	return 0 ; \n}\n\nFILE *CFTPManager::createLocalFile(const std::string &strLocalFile)\n{\n	return fopen(strLocalFile.c_str(), "w+b");\n}\n\nFTP_API CFTPManager::downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos, const unsigned int length)\n{\n	assert(length >= 0);\n\n	FILE *file = NULL;\n	unsigned long nDataLen = FTP_DEFAULT_BUFFER;\n	char strPos[MAX_PATH]  = {0};\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\n	\n	assert(data_fd != -1);\n\n	if ((length != 0) && (length < nDataLen))\n	{\n		nDataLen = length;\n	}\n	char *dataBuf = new char[nDataLen];\n	assert(dataBuf != NULL);\n\n	sprintf(strPos, "%d", pos);\n\n	if (createDataLink(data_fd) < 0)\n	{\n		trace("@@@@ Create Data Link error!!!\\n");\n		return -1;\n	}\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_POS, strPos);\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_FILE, strRemoteFile);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	file = createLocalFile(std::string(FTP_DEFAULT_PATH + strLocalFile));\n	assert(file != NULL);\n	\n	int len = 0;\n	int nReceiveLen = 0;\n	while ((len = getData(data_fd, dataBuf, nDataLen)) > 0)\n	{\n		nReceiveLen += len;\n\n		int num = fwrite(dataBuf, 1, len, file);\n		memset(dataBuf, 0, sizeof(dataBuf));\n	\n		//trace("%s", dataBuf);\n		trace("Num:%d\\n", num);\n		if (nReceiveLen == length && length != 0)\n			break;\n\n		if ((nReceiveLen + nDataLen) > length  && length != 0)\n		{\n			delete []dataBuf;\n			nDataLen = length - nReceiveLen;\n			dataBuf = new char[nDataLen];\n		}\n	}\n\n	Close(data_fd);\n	fclose(file);\n	delete []dataBuf;\n\n	return 0;\n}\n\nFTP_API CFTPManager::parseResponse(const std::string &str)\n{\n	assert(!str.empty());\n\n	std::string strData = str.substr(0, 3);\n	unsigned int val = atoi(strData.c_str());\n\n	return val;\n}\n</pre>\n<pre lang="c++" colla="-">\n</pre>\n<pre lang="c++" colla="-">\n</pre>\n<pre lang="c++" colla="-">\n</pre>', 'ftp<mark>', '', 'inherit', 'open', 'open', '', '218-revision', '', '', '2014-06-11 01:17:39', '2014-06-11 01:17:39', '', 218, 'http://codeseeking.sinaapp.com/?p=219', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(220, 1, '2014-06-11 01:18:39', '2014-06-11 01:18:39', '.h file\n<pre lang="c++" colla="-">\n#ifndef CLIENT_H_\n#define CLIENT_H_\n\n#include <sys/socket.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <string>\n#include <list>\n\n\n#define INVALID_SOCKET				-1\n#define FTP_API						int\n#define MAX_PATH					260\n#define trace						printf\n\n#define FTP_PARAM_BASE\n#define FTP_DEFAULT_PORT			"21"							//FTP默认端口号\n#define FTP_DEFAULT_BUFFER			1024*4							//FTP下载缓冲默认大小\n#define FTP_DEFAULT_PATH			"/mnt/dvs/"						//FTP默认保存路径\n	\n#define FTP_COMMAND_BASE			1000\n#define FTP_COMMAND_END				FTP_COMMAND_BASE + 30\n#define FTP_COMMAND_USERNAME		FTP_COMMAND_BASE + 1			//用户名\n#define FTP_COMMAND_PASSWORD		FTP_COMMAND_BASE + 2			//密码\n#define FTP_COMMAND_QUIT			FTP_COMMAND_BASE + 3			//退出\n#define FTP_COMMAND_CURRENT_PATH	FTP_COMMAND_BASE + 4			// 获取文件路径\n#define FTP_COMMAND_TYPE_MODE		FTP_COMMAND_BASE + 5			// 改变传输模式\n#define FTP_COMMAND_PSAV_MODE		FTP_COMMAND_BASE + 6			// 被动端口模式\n#define FTP_COMMAND_DIR				FTP_COMMAND_BASE + 7			// 获取文件列表\n#define FTP_COMMAND_CHANGE_DIRECTORY FTP_COMMAND_BASE + 8			// 改变路径\n#define FTP_COMMAND_DELETE_FILE		FTP_COMMAND_BASE + 9			// 删除文件\n#define FTP_COMMAND_DELETE_DIRECTORY FTP_COMMAND_BASE + 10			// 删除目录/文件夹\n#define FTP_COMMAND_CREATE_DIRECTORY FTP_COMMAND_BASE + 11			// 创建目录/文件夹\n#define FTP_COMMAND_RENAME_BEGIN    FTP_COMMAND_BASE  +12			// 开始重命名\n#define FTP_COMMAND_RENAME_END      FTP_COMMAND_BASE + 13			// 重命名结束\n#define FTP_COMMAND_FILE_SIZE		FTP_COMMAND_BASE + 14			// 获取文件大小\n#define FTP_COMMAND_DOWNLOAD_POS	FTP_COMMAND_BASE + 15			// 下载文件从指定位置开始\n#define FTP_COMMAND_DOWNLOAD_FILE	FTP_COMMAND_BASE + 16			// 下载文件\n#define FTP_COMMAND_UPLOAD_FILE		FTP_COMMAND_BASE + 17			// 上传文件\n#define FTP_COMMAND_APPEND_FILE		FTP_COMMAND_BASE + 18			// 追加上载文件	\n\n/*		  登陆步骤\n		login2Server\n			|\n		inputUserName\n			|\n		inputPassWord\n			|\n		  具体操作\n			|\n		  quit\n*/\n\nclass CFTPManager \n{\npublic :\n	\n	enum type {\n		binary = 0x31,\n		ascii,\n	};\n	\n	CFTPManager(void);\n\n	virtual ~CFTPManager(void);\n	\n	// ! 登陆服务器\n	FTP_API login2Server(const std::string &serverIP);\n\n	// !输入用户名\n	FTP_API inputUserName(const std::string &userName);\n\n	// !输入密码\n	FTP_API inputPassWord(const std::string &password);\n\n	// !退出FTP\n	FTP_API quitServer(void);\n\n	// !命令： PWD\n	const std::string PWD();\n\n	// !设置传输格式 2进制  还是ascii方式传输\n	FTP_API setTransferMode(type mode);\n\n	// !设置为被动模式\n	const std::string Pasv();\n\n	// ! 命令： DIR\n	const std::string Dir(const std::string &path);\n\n	// !命令 ： CD\n	FTP_API CD(const std::string &path);\n\n	// ！删除文件\n	FTP_API DeleteFile(const std::string &strRemoteFile);\n\n	// ! 删除文件夹/目录\n	FTP_API DeleteDirectory(const std::string &strRemoteDir);\n\n	// ! 创建目录/文件夹\n	FTP_API CreateDirectory(const std::string &strRemoteDir);\n\n	// !重命名\n	FTP_API Rename(const std::string &strRemoteFile, const std::string &strNewFile);\n\n	// !获取文件大小\n	long getFileLength(const std::string &strRemoteFile);\n\n	// !关闭连接\n	void Close(int sock);\n\n	// 下载文件\n	FTP_API Get(const std::string &strRemoteFile, const std::string &strLocalFile);\n\n	// 上载文件  支持断电传送方式\n	FTP_API Put(const std::string &strRemoteFile, const std::string &strLocalFile);\n\n\nprivate:\n	// !合成发送到服务器的命令\n	const std::string parseCommand(const unsigned int command, const std::string &strParam);\n\n	// ! 建立连接\n	FTP_API Connect(int socketfd, const std::string &serverIP, unsigned int nPort);\n\n	// ! 返回服务器信息\n	const std::string serverResponse(int sockfd);\n\n	// !获取服务器数据\n	FTP_API getData(int fd, char *strBuf, unsigned long length);\n\n	// !发送命令\n	FTP_API Send(int fd, const std::string &cmd);\n\n	// !发送命令\n	FTP_API Send(int fd, const char *cmd, const size_t len);\n\n	// !建立数据连接\n	FTP_API createDataLink(int data_fd);\n\n	// !解析PASV模式返回的字符串获取FTP端口号和FTP服务器IP\n	FTP_API ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp);\n\n	// 打开本地文件\n	FILE *createLocalFile(const std::string &strLocalFile);\n\n	// 下载文件 \n	FTP_API downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos = 0, const unsigned int length = 0);\n\n	// 解析返回ftp命令的值\n	FTP_API parseResponse(const std::string &str);\n\nprivate:\n	//！控制连接套接字\n	int		m_cmdSocket;\n	\n	// !当前用户名\n	std::string m_strUserName;\n\n	// !当前用户密码\n	std::string m_strPassWord;\n\n	// !服务器的IP\n	std::string m_strServerIP;\n\n	// !服务器Port\n	unsigned int m_nServerPort;\n\n	// !服务器回应信息缓存\n	std::string m_strResponse;\n\n	// !保存命令参数\n	std::string m_commandStr;\n\n	// ！当前使用的命令参数\n	unsigned int m_nCurrentCommand;\n\n	// !是否登陆标志。\n	bool	m_bLogin;\n};\n\n\n#endif\n\n</pre>\n.cpp file\n<pre lang="c++" colla="-">\n#include "../Source/FTPManager.h"\n\nstatic int SplitString( std::string strSrc, std::list<std::string> &strArray , std::string strFlag)\n{\n	int pos = 1; \n\n	while((pos = (int)strSrc.find_first_of(strFlag.c_str())) > 0) \n	{\n		strArray.insert(strArray.end(), strSrc.substr(0 , pos));\n		strSrc = strSrc.substr(pos + 1, strSrc.length() - pos - 1); \n	}\n\n	strArray.insert(strArray.end(), strSrc.substr(0, strSrc.length()));\n\n	return 0; \n}\n\nCFTPManager::CFTPManager(void): m_bLogin(false)\n{\n	m_cmdSocket = socket(AF_INET, SOCK_STREAM, 0);\n	\n}\n\nCFTPManager::~CFTPManager(void)\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\n\n	Send(m_cmdSocket, strCmdLine.c_str());\n	close(m_cmdSocket);\n	m_bLogin = false;\n}\n\nFTP_API CFTPManager::login2Server(const std::string &serverIP)\n{\n	std::string strPort;\n	int pos = serverIP.find_first_of(":");\n\n	if (pos > 0)\n	{\n		strPort = serverIP.substr(pos + 1, serverIP.length() - pos);\n	}\n	else\n	{\n		pos = serverIP.length();\n		strPort = FTP_DEFAULT_PORT;\n	}\n\n	m_strServerIP = serverIP.substr(0, pos);\n	m_nServerPort = atol(strPort.c_str());\n\n	trace("IP: %s port: %d\\n", m_strServerIP.c_str(), m_nServerPort);\n\n	if (Connect(m_cmdSocket, m_strServerIP, m_nServerPort) < 0)\n	{\n		\n		return -1;\n	}\n	\n	m_strResponse = serverResponse(m_cmdSocket);\n	printf("@@@@Response: %s", m_strResponse.c_str());\n\n	return	parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::inputUserName(const std::string &userName)\n{\n	std::string strCommandLine = parseCommand(FTP_COMMAND_USERNAME, userName);\n\n	m_strUserName = userName;\n\n	if (Send(m_cmdSocket, strCommandLine) < 0)\n	{\n		return -1;\n	}\n\n	m_strResponse = serverResponse(m_cmdSocket);\n	printf("Response: %s\\n", m_strResponse.c_str());\n\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::inputPassWord(const std::string &password)\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PASSWORD, password);\n\n	m_strPassWord = password;\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	else\n	{\n		m_bLogin = true;\n\n		m_strResponse = serverResponse(m_cmdSocket);\n		printf("Response: %s\\n", m_strResponse.c_str());\n\n		return parseResponse(m_strResponse);\n	}\n}\n\nFTP_API CFTPManager::quitServer(void)\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	else\n	{\n		m_strResponse = serverResponse(m_cmdSocket);\n		printf("Response: %s\\n", m_strResponse.c_str());\n\n		return parseResponse(m_strResponse);\n	}\n\n}\n\nconst std::string CFTPManager::PWD()\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CURRENT_PATH, "");\n\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\n	{\n		return "";\n	}\n	else\n	{\n		return serverResponse(m_cmdSocket);\n	}\n}\n\n\nFTP_API CFTPManager::setTransferMode(type mode)\n{\n	std::string strCmdLine;\n\n	switch (mode)\n	{\n	case binary:\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "I");\n		break;\n	case ascii:\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "A");\n		break;\n	default:\n		break;\n	}\n\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\n	{\n		assert(false);\n	}\n	else\n	{	\n		m_strResponse  = serverResponse(m_cmdSocket);\n		printf("@@@@Response: %s", m_strResponse.c_str());\n\n		return parseResponse(m_strResponse);\n	}\n}\n\n\nconst std::string CFTPManager::Pasv()\n{\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PSAV_MODE, "");\n\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\n	{\n		return "";\n	}\n	else\n	{\n		m_strResponse = serverResponse(m_cmdSocket);\n\n		return m_strResponse;\n	}\n}\n\n\nconst std::string CFTPManager::Dir(const std::string &path)\n{\n	int dataSocket = socket(AF_INET, SOCK_STREAM, 0);\n\n	if (createDataLink(dataSocket) < 0)\n	{\n		return "";\n	}\n	// 数据连接成功\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DIR, path);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n		close(dataSocket);\n		return "";\n	}\n	else\n	{\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n		m_strResponse = serverResponse(dataSocket);\n\n		trace("@@@@Response: \\n%s\\n", m_strResponse.c_str());\n		close(dataSocket);\n\n		return m_strResponse;\n	}\n	\n}\n\n\nFTP_API CFTPManager::CD(const std::string &path)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CHANGE_DIRECTORY, path);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n		\n	m_strResponse = serverResponse(m_cmdSocket);\n	\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::DeleteFile(const std::string &strRemoteFile)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_FILE, strRemoteFile);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n\n	m_strResponse = serverResponse(m_cmdSocket);\n	printf("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::DeleteDirectory(const std::string &strRemoteDir)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_DIRECTORY, strRemoteDir);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	\n	m_strResponse = serverResponse(m_cmdSocket);\n\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::CreateDirectory(const std::string &strRemoteDir)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CREATE_DIRECTORY, strRemoteDir);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	\n	m_strResponse = serverResponse(m_cmdSocket);\n\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nFTP_API CFTPManager::Rename(const std::string &strRemoteFile, const std::string &strNewFile)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_RENAME_BEGIN, strRemoteFile);\n	Send(m_cmdSocket, strCmdLine);\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	Send(m_cmdSocket, parseCommand(FTP_COMMAND_RENAME_END, strNewFile));\n\n	m_strResponse = serverResponse(m_cmdSocket);\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n	return parseResponse(m_strResponse);\n}\n\nlong CFTPManager::getFileLength(const std::string &strRemoteFile)\n{\n	assert(m_cmdSocket != INVALID_SOCKET);\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_FILE_SIZE, strRemoteFile);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n\n	m_strResponse = serverResponse(m_cmdSocket);\n\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\n\n	std::string strData = m_strResponse.substr(0, 3);\n	unsigned long val = atol(strData.c_str());\n\n	if (val == 213)\n	{\n		strData = m_strResponse.substr(4);\n		trace("strData: %s\\n", strData.c_str());\n		val = atol(strData.c_str());\n\n		return val;\n	}\n\n	return -1;\n}\n\n\nvoid CFTPManager::Close(int sock)\n{\n	shutdown(sock, SHUT_RDWR);\n	close(sock);\n	sock = INVALID_SOCKET;\n}\n\nFTP_API CFTPManager::Get(const std::string &strRemoteFile, const std::string &strLocalFile)\n{\n	return downLoad(strRemoteFile, strLocalFile);\n}\n\n\nFTP_API CFTPManager::Put(const std::string &strRemoteFile, const std::string &strLocalFile)\n{\n	std::string strCmdLine;\n	const unsigned long dataLen = FTP_DEFAULT_BUFFER;\n	char strBuf[dataLen] = {0};\n	unsigned long nSize = getFileLength(strRemoteFile);\n	unsigned long nLen = 0;\n// 	struct stat sBuf;\n// \n// 	assert(stat(strLocalFile.c_str(), &sBuf) == 0);\n// 	trace("size: %d\\n", sBuf.st_size);\n\n	FILE *pFile = fopen(strLocalFile.c_str(), "rb");  // 以只读方式打开  且文件必须存在\n	assert(pFile != NULL);\n\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\n	assert(data_fd != -1);\n\n	if (createDataLink(data_fd) < 0)\n	{\n		return -1;\n	}\n	\n	if (nSize == -1)\n	{\n		strCmdLine = parseCommand(FTP_COMMAND_UPLOAD_FILE, strRemoteFile);\n	}\n	else\n	{\n		strCmdLine = parseCommand(FTP_COMMAND_APPEND_FILE, strRemoteFile);\n	}\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		Close(data_fd);\n		return -1;\n	}\n\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	fseek(pFile, nSize, SEEK_SET);\n	while (!feof(pFile))\n	{\n		nLen = fread(strBuf, 1, dataLen, pFile);\n		if (nLen < 0)\n		{\n			break;\n		}\n\n		if (Send(data_fd, strBuf) < 0)\n		{\n			Close(data_fd);\n			return -1;\n		}\n	}\n\n	trace("@@@@Response: %s\\n", serverResponse(data_fd).c_str());\n\n	Close(data_fd);\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n	fclose(pFile);\n\n	return 0;\n}\n\nconst std::string CFTPManager::parseCommand(const unsigned int command, const std::string &strParam)\n{\n	if (command < FTP_COMMAND_BASE || command > FTP_COMMAND_END)\n	{\n		return "";\n	}\n\n	std::string strCommandLine;\n\n	m_nCurrentCommand = command;\n	m_commandStr.clear();\n\n	switch (command)\n	{\n	case FTP_COMMAND_USERNAME:\n		strCommandLine = "USER ";\n		break;\n	case FTP_COMMAND_PASSWORD:\n		strCommandLine = "PASS ";\n		break;\n	case FTP_COMMAND_QUIT:\n		strCommandLine = "QUIT ";\n		break;\n	case FTP_COMMAND_CURRENT_PATH:\n		strCommandLine = "PWD ";\n		break;\n	case FTP_COMMAND_TYPE_MODE:\n		strCommandLine = "TYPE ";\n		break;\n	case FTP_COMMAND_PSAV_MODE:\n		strCommandLine = "PASV ";\n		break;\n	case FTP_COMMAND_DIR:\n		strCommandLine = "LIST ";\n		break;\n	case FTP_COMMAND_CHANGE_DIRECTORY:\n		strCommandLine = "CWD ";\n		break;\n	case FTP_COMMAND_DELETE_FILE:\n		strCommandLine = "DELE ";\n		break;\n	case FTP_COMMAND_DELETE_DIRECTORY:\n		strCommandLine = "RMD ";\n		break;\n	case FTP_COMMAND_CREATE_DIRECTORY:\n		strCommandLine = "MKD ";\n		break;\n	case FTP_COMMAND_RENAME_BEGIN:\n		strCommandLine = "RNFR ";\n		break;\n	case FTP_COMMAND_RENAME_END:\n		strCommandLine = "RNTO ";\n		break;\n	case FTP_COMMAND_FILE_SIZE:\n		strCommandLine = "SIZE ";\n		break;\n	case FTP_COMMAND_DOWNLOAD_FILE:\n		strCommandLine = "RETR ";\n		break;\n	case FTP_COMMAND_DOWNLOAD_POS:\n		strCommandLine = "REST ";\n		break;\n	case FTP_COMMAND_UPLOAD_FILE:\n		strCommandLine = "STOR ";\n		break;\n	case FTP_COMMAND_APPEND_FILE:\n		strCommandLine = "APPE ";\n		break;\n	default :\n		break;\n	}\n\n	strCommandLine += strParam;\n	strCommandLine += "\\r\\n";\n\n	m_commandStr = strCommandLine;\n	trace("parseCommand: %s\\n", m_commandStr.c_str());\n\n	return m_commandStr;\n}\n\nFTP_API CFTPManager::Connect(int socketfd, const std::string &serverIP, unsigned int nPort)\n{\n	if (socketfd == INVALID_SOCKET)\n	{\n		return -1;\n	}\n\n	unsigned int argp = 1;\n	int error = -1;\n	int len = sizeof(int);\n	struct sockaddr_in  addr;\n	bool ret = false;\n	timeval stime;\n	fd_set  set;\n\n	ioctl(socketfd, FIONBIO, &argp);  //设置为非阻塞模式\n\n	memset(&addr, 0, sizeof(struct sockaddr_in));\n	addr.sin_family = AF_INET;\n	addr.sin_port	= htons(nPort);\n	addr.sin_addr.s_addr = inet_addr(serverIP.c_str());\n	bzero(&(addr.sin_zero), 8);\n\n	trace("Address: %s %d\\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));\n	\n	if (connect(socketfd, (struct sockaddr*)&addr, sizeof(struct sockaddr)) == -1)   //若直接返回 则说明正在进行TCP三次握手\n	{\n		stime.tv_sec = 20;  //设置为1秒超时\n		stime.tv_usec = 0;\n		FD_ZERO(&set);\n		FD_SET(socketfd, &set);\n\n		if (select(socketfd + 1, NULL, &set, NULL, &stime) > 0)   ///在这边等待 阻塞 返回可以读的描述符 或者超时返回0  或者出错返回-1\n		{\n			getsockopt(socketfd, SOL_SOCKET, SO_ERROR, &error, (socklen_t*)&len);\n			if (error == 0)\n			{\n				ret = true;\n			}\n			else\n			{\n				ret = false;\n			}\n		}\n	}\n	else\n	{	trace("Connect Immediately!!!\\n");\n		ret = true;\n	}\n\n	argp = 0;\n	ioctl(socketfd, FIONBIO, &argp);\n\n	if (!ret)\n	{\n		close(socketfd);\n		fprintf(stderr, "cannot connect server!!\\n");\n		return -1;\n	}\n\n	//fprintf(stdout, "Connect!!!\\n");\n\n	return 0;\n}\n\n\nconst std::string CFTPManager::serverResponse(int sockfd)\n{\n	if (sockfd == INVALID_SOCKET)\n	{\n		return "";\n	}\n	\n	int nRet = -1;\n	char buf[MAX_PATH] = {0};\n\n	m_strResponse.clear();\n\n	while ((nRet = getData(sockfd, buf, MAX_PATH)) > 0)\n	{\n		buf[MAX_PATH - 1] = ''\\0'';\n		m_strResponse += buf;\n	}\n\n	return m_strResponse;\n}\n\nFTP_API CFTPManager::getData(int fd, char *strBuf, unsigned long length)\n{\n	assert(strBuf != NULL);\n\n	if (fd == INVALID_SOCKET)\n	{\n		return -1;\n	}\n\n	memset(strBuf, 0, length);\n	timeval stime;\n	int nLen;\n\n	stime.tv_sec = 1;\n	stime.tv_usec = 0;\n\n	fd_set	readfd;\n	FD_ZERO( &readfd );\n	FD_SET(fd, &readfd );\n\n	if (select(fd + 1, &readfd, 0, 0, &stime) > 0)\n	{\n		if ((nLen = recv(fd, strBuf, length, 0)) > 0)\n		{\n			return nLen;\n		}\n		else\n		{\n			return -2;\n		}\n	}\n	return 0;\n}\n\nFTP_API CFTPManager::Send(int fd, const std::string &cmd)\n{\n	if (fd == INVALID_SOCKET)\n	{\n		return -1;\n	}\n\n	return Send(fd, cmd.c_str(), cmd.length());\n}\n\nFTP_API CFTPManager::Send(int fd, const char *cmd, const size_t len)\n{\n	if((FTP_COMMAND_USERNAME != m_nCurrentCommand) \n		&&(FTP_COMMAND_PASSWORD != m_nCurrentCommand)\n		&&(!m_bLogin))\n	{\n		return -1;\n	}\n\n	timeval timeout;\n	timeout.tv_sec  = 1;\n	timeout.tv_usec = 0;\n\n	fd_set  writefd;\n	FD_ZERO(&writefd);  \n	FD_SET(fd, &writefd);\n\n	if(select(fd + 1, 0, &writefd , 0 , &timeout) > 0)\n	{\n		size_t nlen  = len; \n		int nSendLen = 0; \n		while (nlen >0) \n		{\n			nSendLen = send(fd, cmd , (int)nlen , 0);\n\n			if(nSendLen == -1) \n				return -2; \n\n			nlen = nlen - nSendLen;\n			cmd +=  nSendLen;\n		}\n		return 0;\n	}\n	return -1;\n}\n\n\nFTP_API CFTPManager::createDataLink(int data_fd)\n{\n	assert(data_fd != INVALID_SOCKET);\n\n	std::string strData;\n	unsigned long nPort = 0 ;\n	std::string strServerIp ; \n	std::list<std::string> strArray ;\n\n	std::string parseStr = Pasv();\n\n	if (parseStr.size() <= 0)\n	{\n		return -1;\n	}\n\n	//trace("parseInfo: %s\\n", parseStr.c_str());\n\n	size_t nBegin = parseStr.find_first_of("(");\n	size_t nEnd	  = parseStr.find_first_of(")");\n	strData		  = parseStr.substr(nBegin + 1, nEnd - nBegin - 1);\n\n	//trace("ParseAfter: %s\\n", strData.c_str());\n	if( SplitString( strData , strArray , "," ) <0)\n		return -1;\n\n	if( ParseString( strArray , nPort , strServerIp) < 0)\n		return -1;\n\n	//trace("nPort: %ld IP: %s\\n", nPort, strServerIp.c_str());\n\n	if (Connect(data_fd, strServerIp, nPort) < 0)\n	{\n		return -1;\n	}\n\n	return 0;\n\n}\n\nFTP_API CFTPManager::ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp)\n{\n	if (strArray.size() < 6 )\n		return -1 ;\n\n	std::list<std::string>::iterator citor;\n	citor = strArray.begin();\n	strServerIp = *citor;\n	strServerIp += ".";\n	citor ++;\n	strServerIp += *citor;\n	strServerIp += ".";\n	citor ++ ;\n	strServerIp += *citor;\n	strServerIp += ".";\n	citor ++ ;\n	strServerIp += *citor;\n	citor = strArray.end();\n	citor--;\n	nPort = atol( (*citor).c_str());\n	citor--;\n	nPort += atol( (*(citor)).c_str()) * 256 ;\n	return 0 ; \n}\n\nFILE *CFTPManager::createLocalFile(const std::string &strLocalFile)\n{\n	return fopen(strLocalFile.c_str(), "w+b");\n}\n\nFTP_API CFTPManager::downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos, const unsigned int length)\n{\n	assert(length >= 0);\n\n	FILE *file = NULL;\n	unsigned long nDataLen = FTP_DEFAULT_BUFFER;\n	char strPos[MAX_PATH]  = {0};\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\n	\n	assert(data_fd != -1);\n\n	if ((length != 0) && (length < nDataLen))\n	{\n		nDataLen = length;\n	}\n	char *dataBuf = new char[nDataLen];\n	assert(dataBuf != NULL);\n\n	sprintf(strPos, "%d", pos);\n\n	if (createDataLink(data_fd) < 0)\n	{\n		trace("@@@@ Create Data Link error!!!\\n");\n		return -1;\n	}\n\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_POS, strPos);\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_FILE, strRemoteFile);\n\n	if (Send(m_cmdSocket, strCmdLine) < 0)\n	{\n		return -1;\n	}\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\n\n	file = createLocalFile(std::string(FTP_DEFAULT_PATH + strLocalFile));\n	assert(file != NULL);\n	\n	int len = 0;\n	int nReceiveLen = 0;\n	while ((len = getData(data_fd, dataBuf, nDataLen)) > 0)\n	{\n		nReceiveLen += len;\n\n		int num = fwrite(dataBuf, 1, len, file);\n		memset(dataBuf, 0, sizeof(dataBuf));\n	\n		//trace("%s", dataBuf);\n		trace("Num:%d\\n", num);\n		if (nReceiveLen == length && length != 0)\n			break;\n\n		if ((nReceiveLen + nDataLen) > length  && length != 0)\n		{\n			delete []dataBuf;\n			nDataLen = length - nReceiveLen;\n			dataBuf = new char[nDataLen];\n		}\n	}\n\n	Close(data_fd);\n	fclose(file);\n	delete []dataBuf;\n\n	return 0;\n}\n\nFTP_API CFTPManager::parseResponse(const std::string &str)\n{\n	assert(!str.empty());\n\n	std::string strData = str.substr(0, 3);\n	unsigned int val = atoi(strData.c_str());\n\n	return val;\n}\n</pre>\n<pre lang="c++" colla="-">\n</pre>\n<pre lang="c++" colla="-">\n</pre>\n<pre lang="c++" colla="-">\n</pre>', 'ftp<mark>', '', 'inherit', 'open', 'open', '', '218-revision-2', '', '', '2014-06-11 01:18:39', '2014-06-11 01:18:39', '', 218, 'http://codeseeking.sinaapp.com/?p=220', 0, 'revision', '', 0),
(223, 1, '2014-06-11 01:50:47', '0000-00-00 00:00:00', '', '自动草稿', '', 'auto-draft', 'open', 'open', '', '', '', '', '2014-06-11 01:50:47', '0000-00-00 00:00:00', '', 0, 'http://codeseeking.sinaapp.com/?p=223', 0, 'post', '', 0),
(221, 1, '2014-06-11 01:19:28', '2014-06-11 01:19:28', '.h file\r\n<pre lang="c" colla="-">\r\n#ifndef CLIENT_H_\r\n#define CLIENT_H_\r\n\r\n#include <sys/socket.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/ioctl.h>\r\n#include <netinet/in.h>\r\n#include <sys/stat.h>\r\n#include <netdb.h>\r\n#include <errno.h>\r\n#include <arpa/inet.h>\r\n#include <sys/stat.h>\r\n#include <string>\r\n#include <list>\r\n\r\n\r\n#define INVALID_SOCKET				-1\r\n#define FTP_API						int\r\n#define MAX_PATH					260\r\n#define trace						printf\r\n\r\n#define FTP_PARAM_BASE\r\n#define FTP_DEFAULT_PORT			"21"							//FTP默认端口号\r\n#define FTP_DEFAULT_BUFFER			1024*4							//FTP下载缓冲默认大小\r\n#define FTP_DEFAULT_PATH			"/mnt/dvs/"						//FTP默认保存路径\r\n	\r\n#define FTP_COMMAND_BASE			1000\r\n#define FTP_COMMAND_END				FTP_COMMAND_BASE + 30\r\n#define FTP_COMMAND_USERNAME		FTP_COMMAND_BASE + 1			//用户名\r\n#define FTP_COMMAND_PASSWORD		FTP_COMMAND_BASE + 2			//密码\r\n#define FTP_COMMAND_QUIT			FTP_COMMAND_BASE + 3			//退出\r\n#define FTP_COMMAND_CURRENT_PATH	FTP_COMMAND_BASE + 4			// 获取文件路径\r\n#define FTP_COMMAND_TYPE_MODE		FTP_COMMAND_BASE + 5			// 改变传输模式\r\n#define FTP_COMMAND_PSAV_MODE		FTP_COMMAND_BASE + 6			// 被动端口模式\r\n#define FTP_COMMAND_DIR				FTP_COMMAND_BASE + 7			// 获取文件列表\r\n#define FTP_COMMAND_CHANGE_DIRECTORY FTP_COMMAND_BASE + 8			// 改变路径\r\n#define FTP_COMMAND_DELETE_FILE		FTP_COMMAND_BASE + 9			// 删除文件\r\n#define FTP_COMMAND_DELETE_DIRECTORY FTP_COMMAND_BASE + 10			// 删除目录/文件夹\r\n#define FTP_COMMAND_CREATE_DIRECTORY FTP_COMMAND_BASE + 11			// 创建目录/文件夹\r\n#define FTP_COMMAND_RENAME_BEGIN    FTP_COMMAND_BASE  +12			// 开始重命名\r\n#define FTP_COMMAND_RENAME_END      FTP_COMMAND_BASE + 13			// 重命名结束\r\n#define FTP_COMMAND_FILE_SIZE		FTP_COMMAND_BASE + 14			// 获取文件大小\r\n#define FTP_COMMAND_DOWNLOAD_POS	FTP_COMMAND_BASE + 15			// 下载文件从指定位置开始\r\n#define FTP_COMMAND_DOWNLOAD_FILE	FTP_COMMAND_BASE + 16			// 下载文件\r\n#define FTP_COMMAND_UPLOAD_FILE		FTP_COMMAND_BASE + 17			// 上传文件\r\n#define FTP_COMMAND_APPEND_FILE		FTP_COMMAND_BASE + 18			// 追加上载文件	\r\n\r\n/*		  登陆步骤\r\n		login2Server\r\n			|\r\n		inputUserName\r\n			|\r\n		inputPassWord\r\n			|\r\n		  具体操作\r\n			|\r\n		  quit\r\n*/\r\n\r\nclass CFTPManager \r\n{\r\npublic :\r\n	\r\n	enum type {\r\n		binary = 0x31,\r\n		ascii,\r\n	};\r\n	\r\n	CFTPManager(void);\r\n\r\n	virtual ~CFTPManager(void);\r\n	\r\n	// ! 登陆服务器\r\n	FTP_API login2Server(const std::string &serverIP);\r\n\r\n	// !输入用户名\r\n	FTP_API inputUserName(const std::string &userName);\r\n\r\n	// !输入密码\r\n	FTP_API inputPassWord(const std::string &password);\r\n\r\n	// !退出FTP\r\n	FTP_API quitServer(void);\r\n\r\n	// !命令： PWD\r\n	const std::string PWD();\r\n\r\n	// !设置传输格式 2进制  还是ascii方式传输\r\n	FTP_API setTransferMode(type mode);\r\n\r\n	// !设置为被动模式\r\n	const std::string Pasv();\r\n\r\n	// ! 命令： DIR\r\n	const std::string Dir(const std::string &path);\r\n\r\n	// !命令 ： CD\r\n	FTP_API CD(const std::string &path);\r\n\r\n	// ！删除文件\r\n	FTP_API DeleteFile(const std::string &strRemoteFile);\r\n\r\n	// ! 删除文件夹/目录\r\n	FTP_API DeleteDirectory(const std::string &strRemoteDir);\r\n\r\n	// ! 创建目录/文件夹\r\n	FTP_API CreateDirectory(const std::string &strRemoteDir);\r\n\r\n	// !重命名\r\n	FTP_API Rename(const std::string &strRemoteFile, const std::string &strNewFile);\r\n\r\n	// !获取文件大小\r\n	long getFileLength(const std::string &strRemoteFile);\r\n\r\n	// !关闭连接\r\n	void Close(int sock);\r\n\r\n	// 下载文件\r\n	FTP_API Get(const std::string &strRemoteFile, const std::string &strLocalFile);\r\n\r\n	// 上载文件  支持断电传送方式\r\n	FTP_API Put(const std::string &strRemoteFile, const std::string &strLocalFile);\r\n\r\n\r\nprivate:\r\n	// !合成发送到服务器的命令\r\n	const std::string parseCommand(const unsigned int command, const std::string &strParam);\r\n\r\n	// ! 建立连接\r\n	FTP_API Connect(int socketfd, const std::string &serverIP, unsigned int nPort);\r\n\r\n	// ! 返回服务器信息\r\n	const std::string serverResponse(int sockfd);\r\n\r\n	// !获取服务器数据\r\n	FTP_API getData(int fd, char *strBuf, unsigned long length);\r\n\r\n	// !发送命令\r\n	FTP_API Send(int fd, const std::string &cmd);\r\n\r\n	// !发送命令\r\n	FTP_API Send(int fd, const char *cmd, const size_t len);\r\n\r\n	// !建立数据连接\r\n	FTP_API createDataLink(int data_fd);\r\n\r\n	// !解析PASV模式返回的字符串获取FTP端口号和FTP服务器IP\r\n	FTP_API ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp);\r\n\r\n	// 打开本地文件\r\n	FILE *createLocalFile(const std::string &strLocalFile);\r\n\r\n	// 下载文件 \r\n	FTP_API downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos = 0, const unsigned int length = 0);\r\n\r\n	// 解析返回ftp命令的值\r\n	FTP_API parseResponse(const std::string &str);\r\n\r\nprivate:\r\n	//！控制连接套接字\r\n	int		m_cmdSocket;\r\n	\r\n	// !当前用户名\r\n	std::string m_strUserName;\r\n\r\n	// !当前用户密码\r\n	std::string m_strPassWord;\r\n\r\n	// !服务器的IP\r\n	std::string m_strServerIP;\r\n\r\n	// !服务器Port\r\n	unsigned int m_nServerPort;\r\n\r\n	// !服务器回应信息缓存\r\n	std::string m_strResponse;\r\n\r\n	// !保存命令参数\r\n	std::string m_commandStr;\r\n\r\n	// ！当前使用的命令参数\r\n	unsigned int m_nCurrentCommand;\r\n\r\n	// !是否登陆标志。\r\n	bool	m_bLogin;\r\n};\r\n#endif\r\n</pre>\r\n.cpp file\r\n<pre lang="c++" colla="-">\r\n#include "../Source/FTPManager.h"\r\n\r\nstatic int SplitString( std::string strSrc, std::list<std::string> &strArray , std::string strFlag)\r\n{\r\n	int pos = 1; \r\n\r\n	while((pos = (int)strSrc.find_first_of(strFlag.c_str())) > 0) \r\n	{\r\n		strArray.insert(strArray.end(), strSrc.substr(0 , pos));\r\n		strSrc = strSrc.substr(pos + 1, strSrc.length() - pos - 1); \r\n	}\r\n\r\n	strArray.insert(strArray.end(), strSrc.substr(0, strSrc.length()));\r\n\r\n	return 0; \r\n}\r\n\r\nCFTPManager::CFTPManager(void): m_bLogin(false)\r\n{\r\n	m_cmdSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n	\r\n}\r\n\r\nCFTPManager::~CFTPManager(void)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\r\n\r\n	Send(m_cmdSocket, strCmdLine.c_str());\r\n	close(m_cmdSocket);\r\n	m_bLogin = false;\r\n}\r\n\r\nFTP_API CFTPManager::login2Server(const std::string &serverIP)\r\n{\r\n	std::string strPort;\r\n	int pos = serverIP.find_first_of(":");\r\n\r\n	if (pos > 0)\r\n	{\r\n		strPort = serverIP.substr(pos + 1, serverIP.length() - pos);\r\n	}\r\n	else\r\n	{\r\n		pos = serverIP.length();\r\n		strPort = FTP_DEFAULT_PORT;\r\n	}\r\n\r\n	m_strServerIP = serverIP.substr(0, pos);\r\n	m_nServerPort = atol(strPort.c_str());\r\n\r\n	trace("IP: %s port: %d\\n", m_strServerIP.c_str(), m_nServerPort);\r\n\r\n	if (Connect(m_cmdSocket, m_strServerIP, m_nServerPort) < 0)\r\n	{\r\n		\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("@@@@Response: %s", m_strResponse.c_str());\r\n\r\n	return	parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::inputUserName(const std::string &userName)\r\n{\r\n	std::string strCommandLine = parseCommand(FTP_COMMAND_USERNAME, userName);\r\n\r\n	m_strUserName = userName;\r\n\r\n	if (Send(m_cmdSocket, strCommandLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::inputPassWord(const std::string &password)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PASSWORD, password);\r\n\r\n	m_strPassWord = password;\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	else\r\n	{\r\n		m_bLogin = true;\r\n\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n		printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n}\r\n\r\nFTP_API CFTPManager::quitServer(void)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	else\r\n	{\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n		printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n\r\n}\r\n\r\nconst std::string CFTPManager::PWD()\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CURRENT_PATH, "");\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		return serverResponse(m_cmdSocket);\r\n	}\r\n}\r\n\r\n\r\nFTP_API CFTPManager::setTransferMode(type mode)\r\n{\r\n	std::string strCmdLine;\r\n\r\n	switch (mode)\r\n	{\r\n	case binary:\r\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "I");\r\n		break;\r\n	case ascii:\r\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "A");\r\n		break;\r\n	default:\r\n		break;\r\n	}\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		assert(false);\r\n	}\r\n	else\r\n	{	\r\n		m_strResponse  = serverResponse(m_cmdSocket);\r\n		printf("@@@@Response: %s", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n}\r\n\r\n\r\nconst std::string CFTPManager::Pasv()\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PSAV_MODE, "");\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n		return m_strResponse;\r\n	}\r\n}\r\n\r\n\r\nconst std::string CFTPManager::Dir(const std::string &path)\r\n{\r\n	int dataSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	if (createDataLink(dataSocket) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	// 数据连接成功\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DIR, path);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n		close(dataSocket);\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n		m_strResponse = serverResponse(dataSocket);\r\n\r\n		trace("@@@@Response: \\n%s\\n", m_strResponse.c_str());\r\n		close(dataSocket);\r\n\r\n		return m_strResponse;\r\n	}\r\n	\r\n}\r\n\r\n\r\nFTP_API CFTPManager::CD(const std::string &path)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CHANGE_DIRECTORY, path);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n		\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::DeleteFile(const std::string &strRemoteFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_FILE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::DeleteDirectory(const std::string &strRemoteDir)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_DIRECTORY, strRemoteDir);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::CreateDirectory(const std::string &strRemoteDir)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CREATE_DIRECTORY, strRemoteDir);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::Rename(const std::string &strRemoteFile, const std::string &strNewFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_RENAME_BEGIN, strRemoteFile);\r\n	Send(m_cmdSocket, strCmdLine);\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	Send(m_cmdSocket, parseCommand(FTP_COMMAND_RENAME_END, strNewFile));\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nlong CFTPManager::getFileLength(const std::string &strRemoteFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_FILE_SIZE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n\r\n	std::string strData = m_strResponse.substr(0, 3);\r\n	unsigned long val = atol(strData.c_str());\r\n\r\n	if (val == 213)\r\n	{\r\n		strData = m_strResponse.substr(4);\r\n		trace("strData: %s\\n", strData.c_str());\r\n		val = atol(strData.c_str());\r\n\r\n		return val;\r\n	}\r\n\r\n	return -1;\r\n}\r\n\r\n\r\nvoid CFTPManager::Close(int sock)\r\n{\r\n	shutdown(sock, SHUT_RDWR);\r\n	close(sock);\r\n	sock = INVALID_SOCKET;\r\n}\r\n\r\nFTP_API CFTPManager::Get(const std::string &strRemoteFile, const std::string &strLocalFile)\r\n{\r\n	return downLoad(strRemoteFile, strLocalFile);\r\n}\r\n\r\n\r\nFTP_API CFTPManager::Put(const std::string &strRemoteFile, const std::string &strLocalFile)\r\n{\r\n	std::string strCmdLine;\r\n	const unsigned long dataLen = FTP_DEFAULT_BUFFER;\r\n	char strBuf[dataLen] = {0};\r\n	unsigned long nSize = getFileLength(strRemoteFile);\r\n	unsigned long nLen = 0;\r\n// 	struct stat sBuf;\r\n// \r\n// 	assert(stat(strLocalFile.c_str(), &sBuf) == 0);\r\n// 	trace("size: %d\\n", sBuf.st_size);\r\n\r\n	FILE *pFile = fopen(strLocalFile.c_str(), "rb");  // 以只读方式打开  且文件必须存在\r\n	assert(pFile != NULL);\r\n\r\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\r\n	assert(data_fd != -1);\r\n\r\n	if (createDataLink(data_fd) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	if (nSize == -1)\r\n	{\r\n		strCmdLine = parseCommand(FTP_COMMAND_UPLOAD_FILE, strRemoteFile);\r\n	}\r\n	else\r\n	{\r\n		strCmdLine = parseCommand(FTP_COMMAND_APPEND_FILE, strRemoteFile);\r\n	}\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		Close(data_fd);\r\n		return -1;\r\n	}\r\n\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	fseek(pFile, nSize, SEEK_SET);\r\n	while (!feof(pFile))\r\n	{\r\n		nLen = fread(strBuf, 1, dataLen, pFile);\r\n		if (nLen < 0)\r\n		{\r\n			break;\r\n		}\r\n\r\n		if (Send(data_fd, strBuf) < 0)\r\n		{\r\n			Close(data_fd);\r\n			return -1;\r\n		}\r\n	}\r\n\r\n	trace("@@@@Response: %s\\n", serverResponse(data_fd).c_str());\r\n\r\n	Close(data_fd);\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n	fclose(pFile);\r\n\r\n	return 0;\r\n}\r\n\r\nconst std::string CFTPManager::parseCommand(const unsigned int command, const std::string &strParam)\r\n{\r\n	if (command < FTP_COMMAND_BASE || command > FTP_COMMAND_END)\r\n	{\r\n		return "";\r\n	}\r\n\r\n	std::string strCommandLine;\r\n\r\n	m_nCurrentCommand = command;\r\n	m_commandStr.clear();\r\n\r\n	switch (command)\r\n	{\r\n	case FTP_COMMAND_USERNAME:\r\n		strCommandLine = "USER ";\r\n		break;\r\n	case FTP_COMMAND_PASSWORD:\r\n		strCommandLine = "PASS ";\r\n		break;\r\n	case FTP_COMMAND_QUIT:\r\n		strCommandLine = "QUIT ";\r\n		break;\r\n	case FTP_COMMAND_CURRENT_PATH:\r\n		strCommandLine = "PWD ";\r\n		break;\r\n	case FTP_COMMAND_TYPE_MODE:\r\n		strCommandLine = "TYPE ";\r\n		break;\r\n	case FTP_COMMAND_PSAV_MODE:\r\n		strCommandLine = "PASV ";\r\n		break;\r\n	case FTP_COMMAND_DIR:\r\n		strCommandLine = "LIST ";\r\n		break;\r\n	case FTP_COMMAND_CHANGE_DIRECTORY:\r\n		strCommandLine = "CWD ";\r\n		break;\r\n	case FTP_COMMAND_DELETE_FILE:\r\n		strCommandLine = "DELE ";\r\n		break;\r\n	case FTP_COMMAND_DELETE_DIRECTORY:\r\n		strCommandLine = "RMD ";\r\n		break;\r\n	case FTP_COMMAND_CREATE_DIRECTORY:\r\n		strCommandLine = "MKD ";\r\n		break;\r\n	case FTP_COMMAND_RENAME_BEGIN:\r\n		strCommandLine = "RNFR ";\r\n		break;\r\n	case FTP_COMMAND_RENAME_END:\r\n		strCommandLine = "RNTO ";\r\n		break;\r\n	case FTP_COMMAND_FILE_SIZE:\r\n		strCommandLine = "SIZE ";\r\n		break;\r\n	case FTP_COMMAND_DOWNLOAD_FILE:\r\n		strCommandLine = "RETR ";\r\n		break;\r\n	case FTP_COMMAND_DOWNLOAD_POS:\r\n		strCommandLine = "REST ";\r\n		break;\r\n	case FTP_COMMAND_UPLOAD_FILE:\r\n		strCommandLine = "STOR ";\r\n		break;\r\n	case FTP_COMMAND_APPEND_FILE:\r\n		strCommandLine = "APPE ";\r\n		break;\r\n	default :\r\n		break;\r\n	}\r\n\r\n	strCommandLine += strParam;\r\n	strCommandLine += "\\r\\n";\r\n\r\n	m_commandStr = strCommandLine;\r\n	trace("parseCommand: %s\\n", m_commandStr.c_str());\r\n\r\n	return m_commandStr;\r\n}\r\n\r\nFTP_API CFTPManager::Connect(int socketfd, const std::string &serverIP, unsigned int nPort)\r\n{\r\n	if (socketfd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	unsigned int argp = 1;\r\n	int error = -1;\r\n	int len = sizeof(int);\r\n	struct sockaddr_in  addr;\r\n	bool ret = false;\r\n	timeval stime;\r\n	fd_set  set;\r\n\r\n	ioctl(socketfd, FIONBIO, &argp);  //设置为非阻塞模式\r\n\r\n	memset(&addr, 0, sizeof(struct sockaddr_in));\r\n	addr.sin_family = AF_INET;\r\n	addr.sin_port	= htons(nPort);\r\n	addr.sin_addr.s_addr = inet_addr(serverIP.c_str());\r\n	bzero(&(addr.sin_zero), 8);\r\n\r\n	trace("Address: %s %d\\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));\r\n	\r\n	if (connect(socketfd, (struct sockaddr*)&addr, sizeof(struct sockaddr)) == -1)   //若直接返回 则说明正在进行TCP三次握手\r\n	{\r\n		stime.tv_sec = 20;  //设置为1秒超时\r\n		stime.tv_usec = 0;\r\n		FD_ZERO(&set);\r\n		FD_SET(socketfd, &set);\r\n\r\n		if (select(socketfd + 1, NULL, &set, NULL, &stime) > 0)   ///在这边等待 阻塞 返回可以读的描述符 或者超时返回0  或者出错返回-1\r\n		{\r\n			getsockopt(socketfd, SOL_SOCKET, SO_ERROR, &error, (socklen_t*)&len);\r\n			if (error == 0)\r\n			{\r\n				ret = true;\r\n			}\r\n			else\r\n			{\r\n				ret = false;\r\n			}\r\n		}\r\n	}\r\n	else\r\n	{	trace("Connect Immediately!!!\\n");\r\n		ret = true;\r\n	}\r\n\r\n	argp = 0;\r\n	ioctl(socketfd, FIONBIO, &argp);\r\n\r\n	if (!ret)\r\n	{\r\n		close(socketfd);\r\n		fprintf(stderr, "cannot connect server!!\\n");\r\n		return -1;\r\n	}\r\n\r\n	//fprintf(stdout, "Connect!!!\\n");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\nconst std::string CFTPManager::serverResponse(int sockfd)\r\n{\r\n	if (sockfd == INVALID_SOCKET)\r\n	{\r\n		return "";\r\n	}\r\n	\r\n	int nRet = -1;\r\n	char buf[MAX_PATH] = {0};\r\n\r\n	m_strResponse.clear();\r\n\r\n	while ((nRet = getData(sockfd, buf, MAX_PATH)) > 0)\r\n	{\r\n		buf[MAX_PATH - 1] = ''\\0'';\r\n		m_strResponse += buf;\r\n	}\r\n\r\n	return m_strResponse;\r\n}\r\n\r\nFTP_API CFTPManager::getData(int fd, char *strBuf, unsigned long length)\r\n{\r\n	assert(strBuf != NULL);\r\n\r\n	if (fd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	memset(strBuf, 0, length);\r\n	timeval stime;\r\n	int nLen;\r\n\r\n	stime.tv_sec = 1;\r\n	stime.tv_usec = 0;\r\n\r\n	fd_set	readfd;\r\n	FD_ZERO( &readfd );\r\n	FD_SET(fd, &readfd );\r\n\r\n	if (select(fd + 1, &readfd, 0, 0, &stime) > 0)\r\n	{\r\n		if ((nLen = recv(fd, strBuf, length, 0)) > 0)\r\n		{\r\n			return nLen;\r\n		}\r\n		else\r\n		{\r\n			return -2;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\nFTP_API CFTPManager::Send(int fd, const std::string &cmd)\r\n{\r\n	if (fd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	return Send(fd, cmd.c_str(), cmd.length());\r\n}\r\n\r\nFTP_API CFTPManager::Send(int fd, const char *cmd, const size_t len)\r\n{\r\n	if((FTP_COMMAND_USERNAME != m_nCurrentCommand) \r\n		&&(FTP_COMMAND_PASSWORD != m_nCurrentCommand)\r\n		&&(!m_bLogin))\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	timeval timeout;\r\n	timeout.tv_sec  = 1;\r\n	timeout.tv_usec = 0;\r\n\r\n	fd_set  writefd;\r\n	FD_ZERO(&writefd);  \r\n	FD_SET(fd, &writefd);\r\n\r\n	if(select(fd + 1, 0, &writefd , 0 , &timeout) > 0)\r\n	{\r\n		size_t nlen  = len; \r\n		int nSendLen = 0; \r\n		while (nlen >0) \r\n		{\r\n			nSendLen = send(fd, cmd , (int)nlen , 0);\r\n\r\n			if(nSendLen == -1) \r\n				return -2; \r\n\r\n			nlen = nlen - nSendLen;\r\n			cmd +=  nSendLen;\r\n		}\r\n		return 0;\r\n	}\r\n	return -1;\r\n}\r\n\r\n\r\nFTP_API CFTPManager::createDataLink(int data_fd)\r\n{\r\n	assert(data_fd != INVALID_SOCKET);\r\n\r\n	std::string strData;\r\n	unsigned long nPort = 0 ;\r\n	std::string strServerIp ; \r\n	std::list<std::string> strArray ;\r\n\r\n	std::string parseStr = Pasv();\r\n\r\n	if (parseStr.size() <= 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	//trace("parseInfo: %s\\n", parseStr.c_str());\r\n\r\n	size_t nBegin = parseStr.find_first_of("(");\r\n	size_t nEnd	  = parseStr.find_first_of(")");\r\n	strData		  = parseStr.substr(nBegin + 1, nEnd - nBegin - 1);\r\n\r\n	//trace("ParseAfter: %s\\n", strData.c_str());\r\n	if( SplitString( strData , strArray , "," ) <0)\r\n		return -1;\r\n\r\n	if( ParseString( strArray , nPort , strServerIp) < 0)\r\n		return -1;\r\n\r\n	//trace("nPort: %ld IP: %s\\n", nPort, strServerIp.c_str());\r\n\r\n	if (Connect(data_fd, strServerIp, nPort) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	return 0;\r\n\r\n}\r\n\r\nFTP_API CFTPManager::ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp)\r\n{\r\n	if (strArray.size() < 6 )\r\n		return -1 ;\r\n\r\n	std::list<std::string>::iterator citor;\r\n	citor = strArray.begin();\r\n	strServerIp = *citor;\r\n	strServerIp += ".";\r\n	citor ++;\r\n	strServerIp += *citor;\r\n	strServerIp += ".";\r\n	citor ++ ;\r\n	strServerIp += *citor;\r\n	strServerIp += ".";\r\n	citor ++ ;\r\n	strServerIp += *citor;\r\n	citor = strArray.end();\r\n	citor--;\r\n	nPort = atol( (*citor).c_str());\r\n	citor--;\r\n	nPort += atol( (*(citor)).c_str()) * 256 ;\r\n	return 0 ; \r\n}\r\n\r\nFILE *CFTPManager::createLocalFile(const std::string &strLocalFile)\r\n{\r\n	return fopen(strLocalFile.c_str(), "w+b");\r\n}\r\n\r\nFTP_API CFTPManager::downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos, const unsigned int length)\r\n{\r\n	assert(length >= 0);\r\n\r\n	FILE *file = NULL;\r\n	unsigned long nDataLen = FTP_DEFAULT_BUFFER;\r\n	char strPos[MAX_PATH]  = {0};\r\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\r\n	\r\n	assert(data_fd != -1);\r\n\r\n	if ((length != 0) && (length < nDataLen))\r\n	{\r\n		nDataLen = length;\r\n	}\r\n	char *dataBuf = new char[nDataLen];\r\n	assert(dataBuf != NULL);\r\n\r\n	sprintf(strPos, "%d", pos);\r\n\r\n	if (createDataLink(data_fd) < 0)\r\n	{\r\n		trace("@@@@ Create Data Link error!!!\\n");\r\n		return -1;\r\n	}\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_POS, strPos);\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_FILE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	file = createLocalFile(std::string(FTP_DEFAULT_PATH + strLocalFile));\r\n	assert(file != NULL);\r\n	\r\n	int len = 0;\r\n	int nReceiveLen = 0;\r\n	while ((len = getData(data_fd, dataBuf, nDataLen)) > 0)\r\n	{\r\n		nReceiveLen += len;\r\n\r\n		int num = fwrite(dataBuf, 1, len, file);\r\n		memset(dataBuf, 0, sizeof(dataBuf));\r\n	\r\n		//trace("%s", dataBuf);\r\n		trace("Num:%d\\n", num);\r\n		if (nReceiveLen == length && length != 0)\r\n			break;\r\n\r\n		if ((nReceiveLen + nDataLen) > length  && length != 0)\r\n		{\r\n			delete []dataBuf;\r\n			nDataLen = length - nReceiveLen;\r\n			dataBuf = new char[nDataLen];\r\n		}\r\n	}\r\n\r\n	Close(data_fd);\r\n	fclose(file);\r\n	delete []dataBuf;\r\n\r\n	return 0;\r\n}\r\n\r\nFTP_API CFTPManager::parseResponse(const std::string &str)\r\n{\r\n	assert(!str.empty());\r\n\r\n	std::string strData = str.substr(0, 3);\r\n	unsigned int val = atoi(strData.c_str());\r\n\r\n	return val;\r\n}\r\n</pre>\r\n<pre lang="c++" colla="-">\r\n</pre>\r\n<pre lang="c++" colla="-">\r\n</pre>\r\n<pre lang="c++" colla="-">\r\n</pre>', 'ftp<mark>', '', 'inherit', 'open', 'open', '', '218-revision-3', '', '', '2014-06-11 01:19:28', '2014-06-11 01:19:28', '', 218, 'http://codeseeking.sinaapp.com/?p=221', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(222, 1, '2014-06-11 01:20:08', '2014-06-11 01:20:08', '.h file\r\n<pre lang="c" colla="-">\r\n#ifndef CLIENT_H_\r\n#define CLIENT_H_\r\n\r\n#include <sys/socket.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/ioctl.h>\r\n#include <netinet/in.h>\r\n#include <sys/stat.h>\r\n#include <netdb.h>\r\n#include <errno.h>\r\n#include <arpa/inet.h>\r\n#include <sys/stat.h>\r\n#include <string>\r\n#include <list>\r\n\r\n\r\n#define INVALID_SOCKET				-1\r\n#define FTP_API						int\r\n#define MAX_PATH					260\r\n#define trace						printf\r\n\r\n#define FTP_PARAM_BASE\r\n#define FTP_DEFAULT_PORT			"21"							//FTP默认端口号\r\n#define FTP_DEFAULT_BUFFER			1024*4							//FTP下载缓冲默认大小\r\n#define FTP_DEFAULT_PATH			"/mnt/dvs/"						//FTP默认保存路径\r\n	\r\n#define FTP_COMMAND_BASE			1000\r\n#define FTP_COMMAND_END				FTP_COMMAND_BASE + 30\r\n#define FTP_COMMAND_USERNAME		FTP_COMMAND_BASE + 1			//用户名\r\n#define FTP_COMMAND_PASSWORD		FTP_COMMAND_BASE + 2			//密码\r\n#define FTP_COMMAND_QUIT			FTP_COMMAND_BASE + 3			//退出\r\n#define FTP_COMMAND_CURRENT_PATH	FTP_COMMAND_BASE + 4			// 获取文件路径\r\n#define FTP_COMMAND_TYPE_MODE		FTP_COMMAND_BASE + 5			// 改变传输模式\r\n#define FTP_COMMAND_PSAV_MODE		FTP_COMMAND_BASE + 6			// 被动端口模式\r\n#define FTP_COMMAND_DIR				FTP_COMMAND_BASE + 7			// 获取文件列表\r\n#define FTP_COMMAND_CHANGE_DIRECTORY FTP_COMMAND_BASE + 8			// 改变路径\r\n#define FTP_COMMAND_DELETE_FILE		FTP_COMMAND_BASE + 9			// 删除文件\r\n#define FTP_COMMAND_DELETE_DIRECTORY FTP_COMMAND_BASE + 10			// 删除目录/文件夹\r\n#define FTP_COMMAND_CREATE_DIRECTORY FTP_COMMAND_BASE + 11			// 创建目录/文件夹\r\n#define FTP_COMMAND_RENAME_BEGIN    FTP_COMMAND_BASE  +12			// 开始重命名\r\n#define FTP_COMMAND_RENAME_END      FTP_COMMAND_BASE + 13			// 重命名结束\r\n#define FTP_COMMAND_FILE_SIZE		FTP_COMMAND_BASE + 14			// 获取文件大小\r\n#define FTP_COMMAND_DOWNLOAD_POS	FTP_COMMAND_BASE + 15			// 下载文件从指定位置开始\r\n#define FTP_COMMAND_DOWNLOAD_FILE	FTP_COMMAND_BASE + 16			// 下载文件\r\n#define FTP_COMMAND_UPLOAD_FILE		FTP_COMMAND_BASE + 17			// 上传文件\r\n#define FTP_COMMAND_APPEND_FILE		FTP_COMMAND_BASE + 18			// 追加上载文件	\r\n\r\n/*		  登陆步骤\r\n		login2Server\r\n			|\r\n		inputUserName\r\n			|\r\n		inputPassWord\r\n			|\r\n		  具体操作\r\n			|\r\n		  quit\r\n*/\r\n\r\nclass CFTPManager \r\n{\r\npublic :\r\n	\r\n	enum type {\r\n		binary = 0x31,\r\n		ascii,\r\n	};\r\n	\r\n	CFTPManager(void);\r\n\r\n	virtual ~CFTPManager(void);\r\n	\r\n	// ! 登陆服务器\r\n	FTP_API login2Server(const std::string &serverIP);\r\n\r\n	// !输入用户名\r\n	FTP_API inputUserName(const std::string &userName);\r\n\r\n	// !输入密码\r\n	FTP_API inputPassWord(const std::string &password);\r\n\r\n	// !退出FTP\r\n	FTP_API quitServer(void);\r\n\r\n	// !命令： PWD\r\n	const std::string PWD();\r\n\r\n	// !设置传输格式 2进制  还是ascii方式传输\r\n	FTP_API setTransferMode(type mode);\r\n\r\n	// !设置为被动模式\r\n	const std::string Pasv();\r\n\r\n	// ! 命令： DIR\r\n	const std::string Dir(const std::string &path);\r\n\r\n	// !命令 ： CD\r\n	FTP_API CD(const std::string &path);\r\n\r\n	// ！删除文件\r\n	FTP_API DeleteFile(const std::string &strRemoteFile);\r\n\r\n	// ! 删除文件夹/目录\r\n	FTP_API DeleteDirectory(const std::string &strRemoteDir);\r\n\r\n	// ! 创建目录/文件夹\r\n	FTP_API CreateDirectory(const std::string &strRemoteDir);\r\n\r\n	// !重命名\r\n	FTP_API Rename(const std::string &strRemoteFile, const std::string &strNewFile);\r\n\r\n	// !获取文件大小\r\n	long getFileLength(const std::string &strRemoteFile);\r\n\r\n	// !关闭连接\r\n	void Close(int sock);\r\n\r\n	// 下载文件\r\n	FTP_API Get(const std::string &strRemoteFile, const std::string &strLocalFile);\r\n\r\n	// 上载文件  支持断电传送方式\r\n	FTP_API Put(const std::string &strRemoteFile, const std::string &strLocalFile);\r\n\r\n\r\nprivate:\r\n	// !合成发送到服务器的命令\r\n	const std::string parseCommand(const unsigned int command, const std::string &strParam);\r\n\r\n	// ! 建立连接\r\n	FTP_API Connect(int socketfd, const std::string &serverIP, unsigned int nPort);\r\n\r\n	// ! 返回服务器信息\r\n	const std::string serverResponse(int sockfd);\r\n\r\n	// !获取服务器数据\r\n	FTP_API getData(int fd, char *strBuf, unsigned long length);\r\n\r\n	// !发送命令\r\n	FTP_API Send(int fd, const std::string &cmd);\r\n\r\n	// !发送命令\r\n	FTP_API Send(int fd, const char *cmd, const size_t len);\r\n\r\n	// !建立数据连接\r\n	FTP_API createDataLink(int data_fd);\r\n\r\n	// !解析PASV模式返回的字符串获取FTP端口号和FTP服务器IP\r\n	FTP_API ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp);\r\n\r\n	// 打开本地文件\r\n	FILE *createLocalFile(const std::string &strLocalFile);\r\n\r\n	// 下载文件 \r\n	FTP_API downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos = 0, const unsigned int length = 0);\r\n\r\n	// 解析返回ftp命令的值\r\n	FTP_API parseResponse(const std::string &str);\r\n\r\nprivate:\r\n	//！控制连接套接字\r\n	int		m_cmdSocket;\r\n	\r\n	// !当前用户名\r\n	std::string m_strUserName;\r\n\r\n	// !当前用户密码\r\n	std::string m_strPassWord;\r\n\r\n	// !服务器的IP\r\n	std::string m_strServerIP;\r\n\r\n	// !服务器Port\r\n	unsigned int m_nServerPort;\r\n\r\n	// !服务器回应信息缓存\r\n	std::string m_strResponse;\r\n\r\n	// !保存命令参数\r\n	std::string m_commandStr;\r\n\r\n	// ！当前使用的命令参数\r\n	unsigned int m_nCurrentCommand;\r\n\r\n	// !是否登陆标志。\r\n	bool	m_bLogin;\r\n};\r\n#endif\r\n</pre>\r\n.cpp file\r\n<pre lang="c" colla="-">\r\n#include "../Source/FTPManager.h"\r\n\r\nstatic int SplitString( std::string strSrc, std::list<std::string> &strArray , std::string strFlag)\r\n{\r\n	int pos = 1; \r\n\r\n	while((pos = (int)strSrc.find_first_of(strFlag.c_str())) > 0) \r\n	{\r\n		strArray.insert(strArray.end(), strSrc.substr(0 , pos));\r\n		strSrc = strSrc.substr(pos + 1, strSrc.length() - pos - 1); \r\n	}\r\n\r\n	strArray.insert(strArray.end(), strSrc.substr(0, strSrc.length()));\r\n\r\n	return 0; \r\n}\r\n\r\nCFTPManager::CFTPManager(void): m_bLogin(false)\r\n{\r\n	m_cmdSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n	\r\n}\r\n\r\nCFTPManager::~CFTPManager(void)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\r\n\r\n	Send(m_cmdSocket, strCmdLine.c_str());\r\n	close(m_cmdSocket);\r\n	m_bLogin = false;\r\n}\r\n\r\nFTP_API CFTPManager::login2Server(const std::string &serverIP)\r\n{\r\n	std::string strPort;\r\n	int pos = serverIP.find_first_of(":");\r\n\r\n	if (pos > 0)\r\n	{\r\n		strPort = serverIP.substr(pos + 1, serverIP.length() - pos);\r\n	}\r\n	else\r\n	{\r\n		pos = serverIP.length();\r\n		strPort = FTP_DEFAULT_PORT;\r\n	}\r\n\r\n	m_strServerIP = serverIP.substr(0, pos);\r\n	m_nServerPort = atol(strPort.c_str());\r\n\r\n	trace("IP: %s port: %d\\n", m_strServerIP.c_str(), m_nServerPort);\r\n\r\n	if (Connect(m_cmdSocket, m_strServerIP, m_nServerPort) < 0)\r\n	{\r\n		\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("@@@@Response: %s", m_strResponse.c_str());\r\n\r\n	return	parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::inputUserName(const std::string &userName)\r\n{\r\n	std::string strCommandLine = parseCommand(FTP_COMMAND_USERNAME, userName);\r\n\r\n	m_strUserName = userName;\r\n\r\n	if (Send(m_cmdSocket, strCommandLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::inputPassWord(const std::string &password)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PASSWORD, password);\r\n\r\n	m_strPassWord = password;\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	else\r\n	{\r\n		m_bLogin = true;\r\n\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n		printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n}\r\n\r\nFTP_API CFTPManager::quitServer(void)\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_QUIT, "");\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	else\r\n	{\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n		printf("Response: %s\\n", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n\r\n}\r\n\r\nconst std::string CFTPManager::PWD()\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CURRENT_PATH, "");\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		return serverResponse(m_cmdSocket);\r\n	}\r\n}\r\n\r\n\r\nFTP_API CFTPManager::setTransferMode(type mode)\r\n{\r\n	std::string strCmdLine;\r\n\r\n	switch (mode)\r\n	{\r\n	case binary:\r\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "I");\r\n		break;\r\n	case ascii:\r\n		strCmdLine = parseCommand(FTP_COMMAND_TYPE_MODE, "A");\r\n		break;\r\n	default:\r\n		break;\r\n	}\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		assert(false);\r\n	}\r\n	else\r\n	{	\r\n		m_strResponse  = serverResponse(m_cmdSocket);\r\n		printf("@@@@Response: %s", m_strResponse.c_str());\r\n\r\n		return parseResponse(m_strResponse);\r\n	}\r\n}\r\n\r\n\r\nconst std::string CFTPManager::Pasv()\r\n{\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_PSAV_MODE, "");\r\n\r\n	if (Send(m_cmdSocket, strCmdLine.c_str()) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n		return m_strResponse;\r\n	}\r\n}\r\n\r\n\r\nconst std::string CFTPManager::Dir(const std::string &path)\r\n{\r\n	int dataSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	if (createDataLink(dataSocket) < 0)\r\n	{\r\n		return "";\r\n	}\r\n	// 数据连接成功\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DIR, path);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n		close(dataSocket);\r\n		return "";\r\n	}\r\n	else\r\n	{\r\n		trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n		m_strResponse = serverResponse(dataSocket);\r\n\r\n		trace("@@@@Response: \\n%s\\n", m_strResponse.c_str());\r\n		close(dataSocket);\r\n\r\n		return m_strResponse;\r\n	}\r\n	\r\n}\r\n\r\n\r\nFTP_API CFTPManager::CD(const std::string &path)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CHANGE_DIRECTORY, path);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n		\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::DeleteFile(const std::string &strRemoteFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_FILE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	printf("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::DeleteDirectory(const std::string &strRemoteDir)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DELETE_DIRECTORY, strRemoteDir);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::CreateDirectory(const std::string &strRemoteDir)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_CREATE_DIRECTORY, strRemoteDir);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nFTP_API CFTPManager::Rename(const std::string &strRemoteFile, const std::string &strNewFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_RENAME_BEGIN, strRemoteFile);\r\n	Send(m_cmdSocket, strCmdLine);\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	Send(m_cmdSocket, parseCommand(FTP_COMMAND_RENAME_END, strNewFile));\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n	return parseResponse(m_strResponse);\r\n}\r\n\r\nlong CFTPManager::getFileLength(const std::string &strRemoteFile)\r\n{\r\n	assert(m_cmdSocket != INVALID_SOCKET);\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_FILE_SIZE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	m_strResponse = serverResponse(m_cmdSocket);\r\n\r\n	trace("@@@@Response: %s\\n", m_strResponse.c_str());\r\n\r\n	std::string strData = m_strResponse.substr(0, 3);\r\n	unsigned long val = atol(strData.c_str());\r\n\r\n	if (val == 213)\r\n	{\r\n		strData = m_strResponse.substr(4);\r\n		trace("strData: %s\\n", strData.c_str());\r\n		val = atol(strData.c_str());\r\n\r\n		return val;\r\n	}\r\n\r\n	return -1;\r\n}\r\n\r\n\r\nvoid CFTPManager::Close(int sock)\r\n{\r\n	shutdown(sock, SHUT_RDWR);\r\n	close(sock);\r\n	sock = INVALID_SOCKET;\r\n}\r\n\r\nFTP_API CFTPManager::Get(const std::string &strRemoteFile, const std::string &strLocalFile)\r\n{\r\n	return downLoad(strRemoteFile, strLocalFile);\r\n}\r\n\r\n\r\nFTP_API CFTPManager::Put(const std::string &strRemoteFile, const std::string &strLocalFile)\r\n{\r\n	std::string strCmdLine;\r\n	const unsigned long dataLen = FTP_DEFAULT_BUFFER;\r\n	char strBuf[dataLen] = {0};\r\n	unsigned long nSize = getFileLength(strRemoteFile);\r\n	unsigned long nLen = 0;\r\n// 	struct stat sBuf;\r\n// \r\n// 	assert(stat(strLocalFile.c_str(), &sBuf) == 0);\r\n// 	trace("size: %d\\n", sBuf.st_size);\r\n\r\n	FILE *pFile = fopen(strLocalFile.c_str(), "rb");  // 以只读方式打开  且文件必须存在\r\n	assert(pFile != NULL);\r\n\r\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\r\n	assert(data_fd != -1);\r\n\r\n	if (createDataLink(data_fd) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	\r\n	if (nSize == -1)\r\n	{\r\n		strCmdLine = parseCommand(FTP_COMMAND_UPLOAD_FILE, strRemoteFile);\r\n	}\r\n	else\r\n	{\r\n		strCmdLine = parseCommand(FTP_COMMAND_APPEND_FILE, strRemoteFile);\r\n	}\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		Close(data_fd);\r\n		return -1;\r\n	}\r\n\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	fseek(pFile, nSize, SEEK_SET);\r\n	while (!feof(pFile))\r\n	{\r\n		nLen = fread(strBuf, 1, dataLen, pFile);\r\n		if (nLen < 0)\r\n		{\r\n			break;\r\n		}\r\n\r\n		if (Send(data_fd, strBuf) < 0)\r\n		{\r\n			Close(data_fd);\r\n			return -1;\r\n		}\r\n	}\r\n\r\n	trace("@@@@Response: %s\\n", serverResponse(data_fd).c_str());\r\n\r\n	Close(data_fd);\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n	fclose(pFile);\r\n\r\n	return 0;\r\n}\r\n\r\nconst std::string CFTPManager::parseCommand(const unsigned int command, const std::string &strParam)\r\n{\r\n	if (command < FTP_COMMAND_BASE || command > FTP_COMMAND_END)\r\n	{\r\n		return "";\r\n	}\r\n\r\n	std::string strCommandLine;\r\n\r\n	m_nCurrentCommand = command;\r\n	m_commandStr.clear();\r\n\r\n	switch (command)\r\n	{\r\n	case FTP_COMMAND_USERNAME:\r\n		strCommandLine = "USER ";\r\n		break;\r\n	case FTP_COMMAND_PASSWORD:\r\n		strCommandLine = "PASS ";\r\n		break;\r\n	case FTP_COMMAND_QUIT:\r\n		strCommandLine = "QUIT ";\r\n		break;\r\n	case FTP_COMMAND_CURRENT_PATH:\r\n		strCommandLine = "PWD ";\r\n		break;\r\n	case FTP_COMMAND_TYPE_MODE:\r\n		strCommandLine = "TYPE ";\r\n		break;\r\n	case FTP_COMMAND_PSAV_MODE:\r\n		strCommandLine = "PASV ";\r\n		break;\r\n	case FTP_COMMAND_DIR:\r\n		strCommandLine = "LIST ";\r\n		break;\r\n	case FTP_COMMAND_CHANGE_DIRECTORY:\r\n		strCommandLine = "CWD ";\r\n		break;\r\n	case FTP_COMMAND_DELETE_FILE:\r\n		strCommandLine = "DELE ";\r\n		break;\r\n	case FTP_COMMAND_DELETE_DIRECTORY:\r\n		strCommandLine = "RMD ";\r\n		break;\r\n	case FTP_COMMAND_CREATE_DIRECTORY:\r\n		strCommandLine = "MKD ";\r\n		break;\r\n	case FTP_COMMAND_RENAME_BEGIN:\r\n		strCommandLine = "RNFR ";\r\n		break;\r\n	case FTP_COMMAND_RENAME_END:\r\n		strCommandLine = "RNTO ";\r\n		break;\r\n	case FTP_COMMAND_FILE_SIZE:\r\n		strCommandLine = "SIZE ";\r\n		break;\r\n	case FTP_COMMAND_DOWNLOAD_FILE:\r\n		strCommandLine = "RETR ";\r\n		break;\r\n	case FTP_COMMAND_DOWNLOAD_POS:\r\n		strCommandLine = "REST ";\r\n		break;\r\n	case FTP_COMMAND_UPLOAD_FILE:\r\n		strCommandLine = "STOR ";\r\n		break;\r\n	case FTP_COMMAND_APPEND_FILE:\r\n		strCommandLine = "APPE ";\r\n		break;\r\n	default :\r\n		break;\r\n	}\r\n\r\n	strCommandLine += strParam;\r\n	strCommandLine += "\\r\\n";\r\n\r\n	m_commandStr = strCommandLine;\r\n	trace("parseCommand: %s\\n", m_commandStr.c_str());\r\n\r\n	return m_commandStr;\r\n}\r\n\r\nFTP_API CFTPManager::Connect(int socketfd, const std::string &serverIP, unsigned int nPort)\r\n{\r\n	if (socketfd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	unsigned int argp = 1;\r\n	int error = -1;\r\n	int len = sizeof(int);\r\n	struct sockaddr_in  addr;\r\n	bool ret = false;\r\n	timeval stime;\r\n	fd_set  set;\r\n\r\n	ioctl(socketfd, FIONBIO, &argp);  //设置为非阻塞模式\r\n\r\n	memset(&addr, 0, sizeof(struct sockaddr_in));\r\n	addr.sin_family = AF_INET;\r\n	addr.sin_port	= htons(nPort);\r\n	addr.sin_addr.s_addr = inet_addr(serverIP.c_str());\r\n	bzero(&(addr.sin_zero), 8);\r\n\r\n	trace("Address: %s %d\\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));\r\n	\r\n	if (connect(socketfd, (struct sockaddr*)&addr, sizeof(struct sockaddr)) == -1)   //若直接返回 则说明正在进行TCP三次握手\r\n	{\r\n		stime.tv_sec = 20;  //设置为1秒超时\r\n		stime.tv_usec = 0;\r\n		FD_ZERO(&set);\r\n		FD_SET(socketfd, &set);\r\n\r\n		if (select(socketfd + 1, NULL, &set, NULL, &stime) > 0)   ///在这边等待 阻塞 返回可以读的描述符 或者超时返回0  或者出错返回-1\r\n		{\r\n			getsockopt(socketfd, SOL_SOCKET, SO_ERROR, &error, (socklen_t*)&len);\r\n			if (error == 0)\r\n			{\r\n				ret = true;\r\n			}\r\n			else\r\n			{\r\n				ret = false;\r\n			}\r\n		}\r\n	}\r\n	else\r\n	{	trace("Connect Immediately!!!\\n");\r\n		ret = true;\r\n	}\r\n\r\n	argp = 0;\r\n	ioctl(socketfd, FIONBIO, &argp);\r\n\r\n	if (!ret)\r\n	{\r\n		close(socketfd);\r\n		fprintf(stderr, "cannot connect server!!\\n");\r\n		return -1;\r\n	}\r\n\r\n	//fprintf(stdout, "Connect!!!\\n");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\nconst std::string CFTPManager::serverResponse(int sockfd)\r\n{\r\n	if (sockfd == INVALID_SOCKET)\r\n	{\r\n		return "";\r\n	}\r\n	\r\n	int nRet = -1;\r\n	char buf[MAX_PATH] = {0};\r\n\r\n	m_strResponse.clear();\r\n\r\n	while ((nRet = getData(sockfd, buf, MAX_PATH)) > 0)\r\n	{\r\n		buf[MAX_PATH - 1] = ''\\0'';\r\n		m_strResponse += buf;\r\n	}\r\n\r\n	return m_strResponse;\r\n}\r\n\r\nFTP_API CFTPManager::getData(int fd, char *strBuf, unsigned long length)\r\n{\r\n	assert(strBuf != NULL);\r\n\r\n	if (fd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	memset(strBuf, 0, length);\r\n	timeval stime;\r\n	int nLen;\r\n\r\n	stime.tv_sec = 1;\r\n	stime.tv_usec = 0;\r\n\r\n	fd_set	readfd;\r\n	FD_ZERO( &readfd );\r\n	FD_SET(fd, &readfd );\r\n\r\n	if (select(fd + 1, &readfd, 0, 0, &stime) > 0)\r\n	{\r\n		if ((nLen = recv(fd, strBuf, length, 0)) > 0)\r\n		{\r\n			return nLen;\r\n		}\r\n		else\r\n		{\r\n			return -2;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\nFTP_API CFTPManager::Send(int fd, const std::string &cmd)\r\n{\r\n	if (fd == INVALID_SOCKET)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	return Send(fd, cmd.c_str(), cmd.length());\r\n}\r\n\r\nFTP_API CFTPManager::Send(int fd, const char *cmd, const size_t len)\r\n{\r\n	if((FTP_COMMAND_USERNAME != m_nCurrentCommand) \r\n		&&(FTP_COMMAND_PASSWORD != m_nCurrentCommand)\r\n		&&(!m_bLogin))\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	timeval timeout;\r\n	timeout.tv_sec  = 1;\r\n	timeout.tv_usec = 0;\r\n\r\n	fd_set  writefd;\r\n	FD_ZERO(&writefd);  \r\n	FD_SET(fd, &writefd);\r\n\r\n	if(select(fd + 1, 0, &writefd , 0 , &timeout) > 0)\r\n	{\r\n		size_t nlen  = len; \r\n		int nSendLen = 0; \r\n		while (nlen >0) \r\n		{\r\n			nSendLen = send(fd, cmd , (int)nlen , 0);\r\n\r\n			if(nSendLen == -1) \r\n				return -2; \r\n\r\n			nlen = nlen - nSendLen;\r\n			cmd +=  nSendLen;\r\n		}\r\n		return 0;\r\n	}\r\n	return -1;\r\n}\r\n\r\n\r\nFTP_API CFTPManager::createDataLink(int data_fd)\r\n{\r\n	assert(data_fd != INVALID_SOCKET);\r\n\r\n	std::string strData;\r\n	unsigned long nPort = 0 ;\r\n	std::string strServerIp ; \r\n	std::list<std::string> strArray ;\r\n\r\n	std::string parseStr = Pasv();\r\n\r\n	if (parseStr.size() <= 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	//trace("parseInfo: %s\\n", parseStr.c_str());\r\n\r\n	size_t nBegin = parseStr.find_first_of("(");\r\n	size_t nEnd	  = parseStr.find_first_of(")");\r\n	strData		  = parseStr.substr(nBegin + 1, nEnd - nBegin - 1);\r\n\r\n	//trace("ParseAfter: %s\\n", strData.c_str());\r\n	if( SplitString( strData , strArray , "," ) <0)\r\n		return -1;\r\n\r\n	if( ParseString( strArray , nPort , strServerIp) < 0)\r\n		return -1;\r\n\r\n	//trace("nPort: %ld IP: %s\\n", nPort, strServerIp.c_str());\r\n\r\n	if (Connect(data_fd, strServerIp, nPort) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	return 0;\r\n\r\n}\r\n\r\nFTP_API CFTPManager::ParseString(std::list<std::string> strArray, unsigned long & nPort ,std::string & strServerIp)\r\n{\r\n	if (strArray.size() < 6 )\r\n		return -1 ;\r\n\r\n	std::list<std::string>::iterator citor;\r\n	citor = strArray.begin();\r\n	strServerIp = *citor;\r\n	strServerIp += ".";\r\n	citor ++;\r\n	strServerIp += *citor;\r\n	strServerIp += ".";\r\n	citor ++ ;\r\n	strServerIp += *citor;\r\n	strServerIp += ".";\r\n	citor ++ ;\r\n	strServerIp += *citor;\r\n	citor = strArray.end();\r\n	citor--;\r\n	nPort = atol( (*citor).c_str());\r\n	citor--;\r\n	nPort += atol( (*(citor)).c_str()) * 256 ;\r\n	return 0 ; \r\n}\r\n\r\nFILE *CFTPManager::createLocalFile(const std::string &strLocalFile)\r\n{\r\n	return fopen(strLocalFile.c_str(), "w+b");\r\n}\r\n\r\nFTP_API CFTPManager::downLoad(const std::string &strRemoteFile, const std::string &strLocalFile, const int pos, const unsigned int length)\r\n{\r\n	assert(length >= 0);\r\n\r\n	FILE *file = NULL;\r\n	unsigned long nDataLen = FTP_DEFAULT_BUFFER;\r\n	char strPos[MAX_PATH]  = {0};\r\n	int data_fd = socket(AF_INET, SOCK_STREAM, 0);\r\n	\r\n	assert(data_fd != -1);\r\n\r\n	if ((length != 0) && (length < nDataLen))\r\n	{\r\n		nDataLen = length;\r\n	}\r\n	char *dataBuf = new char[nDataLen];\r\n	assert(dataBuf != NULL);\r\n\r\n	sprintf(strPos, "%d", pos);\r\n\r\n	if (createDataLink(data_fd) < 0)\r\n	{\r\n		trace("@@@@ Create Data Link error!!!\\n");\r\n		return -1;\r\n	}\r\n\r\n	std::string strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_POS, strPos);\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	strCmdLine = parseCommand(FTP_COMMAND_DOWNLOAD_FILE, strRemoteFile);\r\n\r\n	if (Send(m_cmdSocket, strCmdLine) < 0)\r\n	{\r\n		return -1;\r\n	}\r\n	trace("@@@@Response: %s\\n", serverResponse(m_cmdSocket).c_str());\r\n\r\n	file = createLocalFile(std::string(FTP_DEFAULT_PATH + strLocalFile));\r\n	assert(file != NULL);\r\n	\r\n	int len = 0;\r\n	int nReceiveLen = 0;\r\n	while ((len = getData(data_fd, dataBuf, nDataLen)) > 0)\r\n	{\r\n		nReceiveLen += len;\r\n\r\n		int num = fwrite(dataBuf, 1, len, file);\r\n		memset(dataBuf, 0, sizeof(dataBuf));\r\n	\r\n		//trace("%s", dataBuf);\r\n		trace("Num:%d\\n", num);\r\n		if (nReceiveLen == length && length != 0)\r\n			break;\r\n\r\n		if ((nReceiveLen + nDataLen) > length  && length != 0)\r\n		{\r\n			delete []dataBuf;\r\n			nDataLen = length - nReceiveLen;\r\n			dataBuf = new char[nDataLen];\r\n		}\r\n	}\r\n\r\n	Close(data_fd);\r\n	fclose(file);\r\n	delete []dataBuf;\r\n\r\n	return 0;\r\n}\r\n\r\nFTP_API CFTPManager::parseResponse(const std::string &str)\r\n{\r\n	assert(!str.empty());\r\n\r\n	std::string strData = str.substr(0, 3);\r\n	unsigned int val = atoi(strData.c_str());\r\n\r\n	return val;\r\n}\r\n</pre>\r\n<pre lang="c++" colla="-">\r\n</pre>\r\n<pre lang="c++" colla="-">\r\n</pre>\r\n<pre lang="c++" colla="-">\r\n</pre>', 'ftp<mark>', '', 'inherit', 'open', 'open', '', '218-revision-4', '', '', '2014-06-11 01:20:08', '2014-06-11 01:20:08', '', 218, 'http://codeseeking.sinaapp.com/?p=222', 0, 'revision', '', 0),
(224, 1, '2014-06-11 13:30:11', '2014-06-11 13:30:11', 'UDPclient，实现登录，连接，路径操作，和数据传输..虽然有点粗糙，咋也是第一个像样的java prog阿\r\n<pre lang="java" colla="-">\r\npublic class xnClient{\r\n	public static void main(String[] args){\r\n		new xnClient();\r\n	}\r\n\r\n	private String dir;\r\n	private DatagramSocket client;\r\n	private String serverip = "";\r\n	private DatagramPacket initPacket;\r\n	private int port;\r\n	private InetAddress addr;\r\n\r\n	public xnClient(){\r\n		initData();\r\n		serverip = "192.168.140.6";\r\n		try {\r\n			addr = InetAddress.getByName(serverip);\r\n		} catch (UnknownHostException e) {\r\n			e.printStackTrace();\r\n		}\r\n		String rec = null;\r\n		udpsent("hello");\r\n		rec = udpread();\r\n		port = Integer.parseInt(rec);\r\n		String infostr = "port is changed to :" + rec;\r\n		System.out.println(infostr);\r\n		udpsent("USER -XiaoNa-");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n			\r\n		udpsent("PASS -13S103022-");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n		\r\n		udpsent("cwd /");\r\n		udpread();\r\n\r\n		winput();\r\n\r\n		udpsent("quit");\r\n		System.out.println(udpread());\r\n	}\r\n\r\n	public void initData(){\r\n		port = 5050;\r\n		dir = "/";\r\n		try{\r\n			client = new DatagramSocket();\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public void udpsent(String sendStr){\r\n		try {\r\n			byte[] sendBuf;\r\n			sendBuf = sendStr.getBytes();\r\n			DatagramPacket sendPacket = new DatagramPacket(sendBuf,sendBuf.length,addr,port);\r\n			client.send(sendPacket);\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public String udpread(){\r\n		String recStr = null;\r\n		try {\r\n			byte[] recBuf = new byte[1024];\r\n			DatagramPacket recPacket = new DatagramPacket(recBuf,recBuf.length);\r\n			client.receive(recPacket);\r\n			recStr = new String(recPacket.getData(),0,recPacket.getLength());\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return recStr;\r\n	}\r\n\r\n	public void winput(){\r\n		String strin = "";\r\n		String rec = null;\r\n		while(!strin.equals("#")){\r\n			System.out.println("Please Input the command line : ");\r\n			Scanner input = new Scanner(System.in);\r\n			strin = input.nextLine();\r\n			strin = strin.toUpperCase();\r\n			switch(strin) {\r\n			case "TYPE":\r\n				System.out.println("You''ve entered the TYPE cmdline.Please input the cmd like eg. type A/I.");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "LIST":\r\n				udpsent(strin);\r\n				udpread();\r\n				rec = udpread();\r\n				String[] items = rec.split("\\r\\n");\r\n				for(int i = 0;i < items.length;i++){\r\n					if(items[i].startsWith("d")){\r\n						System.out.println("/"+items[i].substring(2)+"/");\r\n					}else {\r\n						System.out.println("/"+items[i].substring(2));\r\n					}\r\n				}\r\n				rec = udpread();\r\n				break;\r\n			case "CWD":\r\n				System.out.println("You''ve entered the cd cmdline.Please input the cmd like eg. cwd //..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				break;\r\n			case "CDUP":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n			case "MKD":\r\n				System.out.println("You''ve entered the mkdir commandline.please input the cmd like mkd dir..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "STOR":\r\n				System.out.println("You''ve entered the store file cmdline.please input the cmd like stor file..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				System.out.println("Please input the context..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "DELE":\r\n				System.out.println("You''ve entered the del cmdline.please input the cmd like dele filename..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "PWD":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "RETR":\r\n				System.out.println("You''ve entered the get cmdline.please input the cmd like retr filename..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				System.out.println(udpread());\r\n				break;\r\n			default:\r\n				break;\r\n			}\r\n		}\r\n	}\r\n}\r\n</pre>\r\n除却这个，再发个udpserver端的吧，tcp端的就是将datagramPacket改成用一般的socket连接\r\n<pre lang="java" colla="-">\r\npublic class udpServer {\r\n\r\n	public static void main(String[] args) {\r\n		new udpServer();\r\n	}\r\n	public udpServer() {\r\n		\r\n        try {\r\n        	DatagramSocket  server = new DatagramSocket(5050);\r\n        	byte[] recvBuf = new byte[1024];\r\n        	DatagramPacket recvPacket \r\n            	= new DatagramPacket(recvBuf , recvBuf.length);\r\n        	while(true){\r\n        		server.receive(recvPacket);\r\n                FtpHandler h = new FtpHandler(recvPacket);\r\n				h.start();\r\n        	}\r\n		} catch (IOException e1) {\r\n			e1.printStackTrace();\r\n		}\r\n\r\n	}\r\n\r\n	public ArrayList<FtpHandler> users = new ArrayList<FtpHandler>();\r\n	public static int counter = 0;\r\n	public static String initDir = "ftp/";\r\n\r\n	class UserInfo {\r\n		String user;\r\n		String password;\r\n		String workDir;\r\n		\r\n		public UserInfo(String a, String b, String c)\r\n		{\r\n			user = a;\r\n			password = b;\r\n			workDir = c;\r\n		}\r\n	}\r\n\r\n	class FtpHandler extends Thread {\r\n		String ServerIP = "192.168.140.6";\r\n\r\n		DatagramSocket server;\r\n		int port; \r\n		InetAddress clientAddr = null;\r\n		int id;\r\n		String cmd = ""; //the command\r\n		String param = ""; //parameters\r\n		String user;\r\n		String remoteHost = " "; // client''s ip\r\n		int remotePort = 0; // client''s tcp port\r\n		String dir = "/";//pwd\r\n		String rootdir = "/home/char/javawork/ftp-train/ftp/"; //root dir.checkPASS to set\r\n		int state = 0; //user''s state\r\n		String reply; //report of the command\r\n		int type = 0; //file type\r\n		String requestfile = "";\r\n		boolean isrest = false;\r\n\r\n		int sendPort;\r\n        InetAddress addr;\r\n		\r\n		public FtpHandler(DatagramPacket reciPacket) {\r\n			\r\n			dir = "/";\r\n			sendPort = reciPacket.getPort();\r\n			addr = reciPacket.getAddress();\r\n			port = getPort();\r\n			System.out.println(port);\r\n			try {\r\n				server = new DatagramSocket(port);\r\n			} catch (SocketException e) {\r\n				e.printStackTrace();\r\n			}\r\n			udpSend(""+port);\r\n		}\r\n\r\n		public void run() {\r\n			String str = "";\r\n			int parseResult; //No. of command\r\n\r\n			try {\r\n				state = FtpState.FS_WAIT_LOGIN; //0\r\n				boolean finished = false;\r\n				while (!finished) {\r\n					str = UdpRead(); // /\r\n					if (str == null)\r\n						finished = true; //jump out\r\n					else {\r\n						parseResult = parseInput(str); // cmd=>num\r\n						System.out.println("Command : " + cmd + " Parameter : " + param);\r\n						System.out.print("->");\r\n						switch (state) // user''s state to check what to do\r\n						{\r\n						case FtpState.FS_WAIT_LOGIN:\r\n							finished = commandUSER();\r\n							break;\r\n						case FtpState.FS_WAIT_PASS:\r\n							finished = commandPASS();\r\n							break;\r\n						case FtpState.FS_LOGIN: {\r\n							switch (parseResult)// key point\r\n							{\r\n							case -1:\r\n								errCMD(); // gramerror\r\n								break;\r\n							case 2:\r\n								finished = commandPASV();\r\n								break;\r\n							case 3:\r\n								finished = commandSYST();\r\n								break;\r\n							case 4:\r\n								finished = commandCDUP(); // cd ..\r\n								break;\r\n							case 6:\r\n								finished = commandCWD(); // cd path\r\n								break;\r\n							case 7:\r\n								finished = commandQUIT(); // quit\r\n								break;\r\n							case 9:\r\n								finished = commandPORT(); // client''s ip tcp''s port\r\n								break;\r\n							case 11:\r\n								finished = commandTYPE(); // file type set\r\n								break;\r\n							case 14:\r\n								finished = commandRETR(); // get a file from the server\r\n								break;\r\n							case 15:\r\n								finished = commandSTOR(); // send a file to server\r\n								break;\r\n							case 22:\r\n								finished = commandABOR(); // close the datasocket\r\n								break;\r\n							case 23:\r\n								finished = commandDELE(); // delete the file in server\r\n								break;\r\n							case 25:\r\n								finished = commandMKD(); // make dir\r\n								break;\r\n							case 27:\r\n								finished = commandLIST(); // ls\r\n								break;\r\n							case 26:\r\n							case 33:\r\n								finished = commandPWD(); // pwd\r\n								break;\r\n							case 32:\r\n								finished = commandNOOP(); // correct\r\n								break;\r\n\r\n							}\r\n						}\r\n							break;\r\n\r\n						}\r\n					}\r\n					System.out.println(reply);\r\n					udpSend(reply);\r\n\r\n				}\r\n			} catch (Exception e) {\r\n				System.out.println("connection reset!");\r\n			} \r\n		}\r\n\r\n		void udpSend(String sendStr)\r\n		{\r\n			try {\r\n\r\n		        byte[] sendBuf;\r\n		        sendBuf = sendStr.getBytes();\r\n		        DatagramPacket sendPacket \r\n		            = new DatagramPacket(sendBuf , sendBuf.length , addr , sendPort );\r\n		        \r\n				server.send(sendPacket);\r\n			} catch (SocketException e) {\r\n				e.printStackTrace();\r\n			}catch (IOException e) {\r\n				e.printStackTrace();\r\n			}\r\n		}\r\n		\r\n		String UdpRead()\r\n		{\r\n			String reciStr=null;\r\n	        try {\r\n				byte[] recvBuf = new byte[1024];\r\n		        DatagramPacket recvPacket \r\n		            = new DatagramPacket(recvBuf , recvBuf.length);\r\n	        	server.receive(recvPacket);\r\n				reciStr = new String(recvPacket.getData() , 0 , recvPacket.getLength());\r\n				\r\n			} catch (IOException e) {\r\n				e.printStackTrace();\r\n			}\r\n	        return reciStr;\r\n		}\r\n		\r\n		public int getPort() {   \r\n		    DatagramSocket s = null;//udp''s socket just can figure out the port udp occupy\r\n		    // test tht ports between two value  \r\n		    int MINPORT = 10000;  \r\n		    int MAXPORT = 65000;  \r\n		  \r\n		    for (; MINPORT < MAXPORT; MINPORT++) {  \r\n		  \r\n		        try {  \r\n		            s = new DatagramSocket(MINPORT);  \r\n		            s.close();  \r\n		            return MINPORT;  \r\n		        } catch (IOException e) {  \r\n		            continue;  \r\n		        }  \r\n		  \r\n		    }  \r\n		    return -1;  \r\n		}  \r\n		\r\n		int parseInput(String s) {\r\n			int p = 0;\r\n			int i = -1;\r\n			p = s.indexOf(" ");\r\n			if (p == -1) // no parameter\r\n				cmd = s;\r\n			else\r\n				cmd = s.substring(0, p); // get the param\r\n\r\n			if (p >= s.length() || p == -1)\r\n				param = "";\r\n			else\r\n				param = s.substring(p + 1, s.length());\r\n			cmd = cmd.toUpperCase(); // Upper\r\n\r\n			if(cmd.equals("PASV"))\r\n				i = 2;\r\n			if(cmd.equals("SYST"))\r\n				i = 3;\r\n			if (cmd.equals("CDUP"))\r\n				i = 4;\r\n			if (cmd.equals("CWD"))\r\n				i = 6;\r\n			if (cmd.equals("QUIT"))\r\n				i = 7;\r\n			if (cmd.equals("PORT"))\r\n				i = 9;\r\n			if (cmd.equals("TYPE"))\r\n				i = 11;\r\n			if (cmd.equals("RETR"))\r\n				i = 14;\r\n			if (cmd.equals("STOR"))\r\n				i = 15;\r\n			if (cmd.equals("ABOR"))\r\n				i = 22;\r\n			if (cmd.equals("DELE"))\r\n				i = 23;\r\n			if (cmd.equals("MKD"))\r\n				i = 25;\r\n			if (cmd.equals("PWD"))\r\n				i = 26;\r\n			if (cmd.equals("LIST"))\r\n				i = 27;\r\n			if (cmd.equals("NOOP"))\r\n				i = 32;\r\n			if (cmd.equals("XPWD"))\r\n				i = 33;\r\n			return i;\r\n		}\r\n\r\n		int validatePath(String s) {\r\n			File f = new File(s); // /...\r\n			if (f.exists() && !f.isDirectory()) {\r\n				String s1 = s.toLowerCase();\r\n				String s2 = rootdir.toLowerCase();\r\n				if (s1.startsWith(s2))\r\n					return 1; //the file is existed begin with rootdir\r\n				else\r\n					return 0; //the file.....without the rootdir\r\n			}\r\n			f = new File(addTail(dir) + s);// .../...\r\n			if (f.exists() && !f.isDirectory()) {\r\n				String s1 = (addTail(dir) + s).toLowerCase();\r\n				String s2 = rootdir.toLowerCase();\r\n				if (s1.startsWith(s2))\r\n					return 2;  \r\n				else\r\n					return 0; \r\n			}\r\n			return 0; \r\n		}\r\n\r\n		private boolean commandPASV() {\r\n			reply = "227 Entering Passive Mode ("+ServerIP+","+(port/256)+","+(port%256)+").";\r\n			return false;\r\n		}\r\n		\r\n		private boolean commandSYST() {\r\n			reply = "215 UNIX Type: L8";\r\n			return false;\r\n		}\r\n		\r\n		boolean commandUSER() {\r\n			if (cmd.equals("USER")) {\r\n				reply = "User name correct,Please input the password..";\r\n				user = param;\r\n				state = FtpState.FS_WAIT_PASS;\r\n				return false;\r\n			} else {\r\n				reply = "Param error,user name not match..";\r\n				return true;\r\n			}\r\n\r\n		}\r\n\r\n		boolean commandPASS() {\r\n			if (cmd.equals("PASS")) {\r\n				reply = "User login..";\r\n				state = FtpState.FS_LOGIN;\r\n				System.out.println("User : " + param +  "Login..");\r\n				System.out.print("->");\r\n				return false;\r\n			} else {\r\n				reply = "Param error,password is wrong..";\r\n				return true;\r\n			}\r\n\r\n		}\r\n\r\n		void errCMD() {\r\n			reply = "Param error";\r\n		}\r\n\r\n		boolean commandCDUP()// cd ..\r\n		{\r\n			File f = new File(dir);\r\n			if (f.getParent() != null && (!dir.equals(rootdir)))//have father path but is not root path\r\n			{\r\n				dir = f.getParent();\r\n				reply = "Correct..";\r\n			} else {\r\n				reply = "There is no such father path..";\r\n			}\r\n\r\n			return false;\r\n		}// commandCDUP() end\r\n\r\n		boolean commandCWD()// CWD (CHANGE WORKING DIRECTORY)\r\n		{ \r\n			if(param.equals("/"))\r\n				param = rootdir;\r\n			else if(param.startsWith("/"))\r\n				param = rootdir+param.substring(1, param.length());\r\n			File f = new File(param);\r\n			String s = "";\r\n			String s1 = "";\r\n			if (dir.endsWith("/"))\r\n				s = dir;\r\n			else{\r\n				s = dir + "/";\r\n			}\r\n			File f1 = new File(s + param);\r\n\r\n			if (f.isDirectory() && f.exists()) {\r\n				if (param.equals("..") || param.equals("..\\\\")) {\r\n					if (dir.compareToIgnoreCase(rootdir) == 0) {\r\n						reply = "There is no such directory..";\r\n						// return false;\r\n					} else {\r\n						s1 = new File(dir).getParent();\r\n						if (s1 != null) {\r\n							dir = s1;\r\n							reply = "Directory change to : " + dir;\r\n						} else\r\n							reply = "There is no such path..";\r\n					}\r\n				} else if (param.equals(".") || param.equals(".\\\\")) {\r\n				} else {\r\n					dir = param;\r\n					reply = "The directory change to : " + dir;\r\n				}\r\n			} else if (f1.isDirectory() && f1.exists()) {\r\n				dir = s + param;\r\n				reply = "The directory change to : " + dir;\r\n			} else\r\n				reply = "Param error..";\r\n\r\n			return false;\r\n		} // commandCDW() end\r\n\r\n		boolean commandQUIT() {\r\n			reply = "Service close the connection..";\r\n			return true;\r\n		}// commandQuit() end\r\n\r\n		boolean commandPORT() {\r\n			int p1 = 0;\r\n			int p2 = 0;\r\n			int[] a = new int[6];// store ip+tcp\r\n			int i = 0; //\r\n			try {\r\n				while ((p2 = param.indexOf(",", p1)) != -1)// first 5 bit\r\n				{\r\n					a[i] = Integer.parseInt(param.substring(p1, p2));\r\n					p2 = p2 + 1;\r\n					p1 = p2;\r\n					i++;\r\n				}\r\n				a[i] = Integer.parseInt(param.substring(p1, param.length()));// last bit\r\n			} catch (NumberFormatException e) {\r\n				reply = "Param error..";\r\n				return false;\r\n			}\r\n\r\n			remoteHost = a[0] + "." + a[1] + "." + a[2] + "." + a[3];\r\n			remotePort = a[4] * 256 + a[5];\r\n			reply = "Correct..";\r\n			return false;\r\n		}// commandPort() end\r\n\r\n		boolean commandLIST()\r\n		{\r\n\r\n				udpSend("Correct,ls works as ASCII..");\r\n							\r\n							File f = new File(dir);\r\n							System.out.println(dir);\r\n							String[] dirStructure = f.list();\r\n							String fileType;\r\n							String out="";\r\n							for (int i = 0; i < dirStructure.length; i++) {\r\n								if (dirStructure[i].indexOf(".") != -1) {\r\n									fileType = "- "; \r\n								} else {\r\n									fileType = "d "; \r\n								}\r\n								out = out + fileType + dirStructure[i] + "\\r\\n";\r\n							}\r\n							udpSend(out);\r\n							reply = "Data transport over...";\r\n\r\n			return false;\r\n		}// commandLIST() end\r\n\r\n		boolean commandTYPE() \r\n		{\r\n			if (param.equals("A")) {\r\n				type = FtpState.FTYPE_ASCII;// 0\r\n				reply = "Correct,turn to ASCII Model";\r\n			} else if (param.equals("I")) {\r\n				type = FtpState.FTYPE_IMAGE;// 1\r\n				reply = "Correct,turn to BINARY Model";\r\n			} else\r\n				reply = "The command can not be done..";\r\n\r\n			return false;\r\n		}\r\n\r\n		boolean commandRETR() {\r\n			String fillname = dir;\r\n			if(param.startsWith("/"))\r\n				fillname += param.substring(1);\r\n			else\r\n				fillname += param;\r\n			System.out.println(dir);\r\n			System.out.println(addTail(dir.substring(1)));\r\n			System.out.println(fillname);\r\n			requestfile = fillname;\r\n			File f = new File(requestfile);\r\n			if (!f.exists()) {\r\n				f = new File(fillname);\r\n				if (!f.exists()) {\r\n					reply = "The file is not existed..";\r\n					return false;\r\n				}\r\n			}\r\n			if (f.isDirectory()) {\r\n\r\n			} else {\r\n				if (type == FtpState.FTYPE_IMAGE) // bin\r\n				{\r\n					try {\r\n						udpSend("Correct.open it as binary file."\r\n								+ requestfile);\r\n						BufferedInputStream fin = new BufferedInputStream(\r\n								new FileInputStream(requestfile));\r\n						byte[] buf = new byte[1024]; // target buff\r\n						int l = 0;\r\n						String sendStr="";\r\n						while ((l = fin.read(buf, 0, 1024)) != -1) // buff still not full\r\n						{\r\n							sendStr = sendStr + new String(buf, 0, l);\r\n						}\r\n						udpSend(sendStr);\r\n						fin.close();\r\n						reply = "Data transport over..";\r\n\r\n					} catch (Exception e) {\r\n						e.printStackTrace();\r\n						reply = "Request failed...";\r\n						return false;\r\n					}\r\n\r\n				}\r\n				if (type == FtpState.FTYPE_ASCII)// ascII\r\n				{\r\n					try {\r\n						udpSend("Opening ASCII mode data connection for "\r\n										+ requestfile);\r\n						BufferedReader fin = new BufferedReader(new FileReader(\r\n								requestfile));\r\n						String s;\r\n						String sendStr="";\r\n						while ((s = fin.readLine()) != null) {\r\n							sendStr+=s; // /???\r\n						}\r\n						fin.close();\r\n						udpSend(sendStr);\r\n						reply = "The data tansport over...";\r\n					} catch (Exception e) {\r\n						e.printStackTrace();\r\n						reply = "The request failed..";\r\n						return false;\r\n					}\r\n				}\r\n			}\r\n			return false;\r\n\r\n		}\r\n\r\n		boolean commandSTOR() {\r\n			if (param.equals("")) {\r\n				reply = "Param error..";\r\n				return false;\r\n			}\r\n			requestfile = addTail(dir) + param;\r\n			if (type == FtpState.FTYPE_IMAGE)// bin\r\n			{\r\n				try {\r\n					udpSend("Opening Binary mode data connection for "\r\n									+ requestfile);\r\n\r\n					BufferedOutputStream fout = new BufferedOutputStream(\r\n							new FileOutputStream(requestfile));\r\n					byte[] buf = new byte[1024];\r\n					int l = 0;\r\n					String tmp = null;\r\n					/*while ((tmp = UdpRead()) != null) {\r\n						fout.write(tmp.getBytes(), 0, tmp.getBytes().length);\r\n					}*/\r\n					tmp = UdpRead();\r\n					fout.write(tmp.getBytes(), 0, tmp.getBytes().length);\r\n					fout.close();\r\n					reply = "Data transport over..";\r\n				} catch (Exception e) {\r\n					e.printStackTrace();\r\n					reply = "Request failed..";\r\n					return false;\r\n				}\r\n			}\r\n			if (type == FtpState.FTYPE_ASCII)// ascII\r\n			{\r\n				try {\r\n					udpSend("Opening ASCII mode data connection for "\r\n									+ requestfile);\r\n					PrintWriter fout = new PrintWriter(new FileOutputStream(\r\n							requestfile));\r\n					String line = UdpRead();\r\n					/*while ((line = UdpRead()) != null) {\r\n						fout.println(line);\r\n					}*/\r\n					fout.println(line);\r\n					fout.close();\r\n					reply = "The data transport over...";\r\n				} catch (Exception e) {\r\n					e.printStackTrace();\r\n					reply = "Request failed..";\r\n					return false;\r\n				}\r\n			}\r\n			return false;\r\n		}\r\n\r\n		boolean commandPWD() {\r\n			reply = " " + dir + "  is the pwd..";\r\n			return false;\r\n		}\r\n\r\n		boolean commandNOOP() {\r\n			reply = "Correct..";\r\n			return false;\r\n		}\r\n\r\n		boolean commandABOR() {\r\n			try {\r\n			} catch (Exception e) {\r\n				e.printStackTrace();\r\n				reply = "Request failed..";\r\n				return false;\r\n			}\r\n			reply = "Out of service,connection closed..";\r\n			return false;\r\n		}\r\n\r\n		boolean commandDELE() {\r\n			int i = validatePath(param);\r\n			if (i == 0) {\r\n				reply = "Request failed.No such file or dir.";\r\n				return false;\r\n			}\r\n			if (i == 1) {\r\n				File f = new File(param);\r\n				f.delete();\r\n			}\r\n			if (i == 2) {\r\n				File f = new File(addTail(dir) + param);\r\n				f.delete();\r\n			}\r\n\r\n			reply = "Request done.file deleted..";\r\n			return false;\r\n\r\n		}\r\n\r\n		boolean commandMKD() {\r\n			String s1 = param.toLowerCase();\r\n			String s2 = rootdir.toLowerCase();\r\n			if (s1.startsWith(s2)) {\r\n				File f = new File(param);\r\n				if (f.exists()) {\r\n					reply = "Dir is existed..";\r\n					return false;\r\n				} else {\r\n					f.mkdirs();\r\n					reply = "Dir build done..";\r\n				}\r\n			} else {\r\n				File f = new File(addTail(dir) + param);\r\n				if (f.exists()) {\r\n					reply = "Dir is existed..";\r\n					return false;\r\n				} else {\r\n					f.mkdirs();\r\n					reply = "Dir building done..";\r\n				}\r\n			}\r\n\r\n			return false;\r\n		}\r\n\r\n		String addTail(String s) {\r\n			if (!s.endsWith("/"))\r\n				s = s + "/";\r\n			return s;\r\n		}\r\n\r\n	}\r\n\r\n	class FtpState {\r\n		final static int FS_WAIT_LOGIN = 0; // wait for user name.\r\n		final static int FS_WAIT_PASS = 1; // wait for the password.\r\n		final static int FS_LOGIN = 2; // Login in..\r\n\r\n		final static int FTYPE_ASCII = 0;\r\n		final static int FTYPE_IMAGE = 1;\r\n		final static int FMODE_STREAM = 0;\r\n		final static int FMODE_COMPRESSED = 1;\r\n		final static int FSTRU_FILE = 0;\r\n		final static int FSTRU_PAGE = 1;\r\n	}\r\n}\r\n</pre>', 'Java ftp', '', 'publish', 'open', 'open', '', 'java-ftp', '', '', '2014-06-13 02:37:21', '2014-06-13 02:37:21', '', 0, 'http://codeseeking.sinaapp.com/?p=224', 0, 'post', '', 0),
(225, 1, '2014-06-11 13:27:01', '2014-06-11 13:27:01', '', 'Java ftp', '', 'inherit', 'open', 'open', '', '224-revision', '', '', '2014-06-11 13:27:01', '2014-06-11 13:27:01', '', 224, 'http://codeseeking.sinaapp.com/?p=225', 0, 'revision', '', 0),
(226, 1, '2014-06-11 13:27:38', '2014-06-11 13:27:38', 'UDPclient\r\n<pre lang="java" colla="-">\r\n</pre>', 'Java ftp', '', 'inherit', 'open', 'open', '', '224-revision-2', '', '', '2014-06-11 13:27:38', '2014-06-11 13:27:38', '', 224, 'http://codeseeking.sinaapp.com/?p=226', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(227, 1, '2014-06-11 13:29:21', '2014-06-11 13:29:21', 'UDPclient\r\n<pre lang="java" colla="-">\r\npublic class TestClient{\r\n	public static void main(String[] args){\r\n		new TestClient();\r\n	}\r\n\r\n	private String dir;\r\n	private DatagramSocket client;\r\n	private String serverip = "";\r\n	private DatagramPacket initPacket;\r\n	private int port;\r\n	private InetAddress addr;\r\n\r\n	public TestClient(){\r\n		initData();\r\n		serverip = "192.168.140.6";\r\n		try {\r\n			addr = InetAddress.getByName(serverip);\r\n		} catch (UnknownHostException e) {\r\n			e.printStackTrace();\r\n		}\r\n		String rec = null;\r\n		udpsent("hello");\r\n		rec = udpread();\r\n		port = Integer.parseInt(rec);\r\n		String infostr = "port is changed to :" + rec;\r\n		System.out.println(infostr);\r\n		udpsent("USER XiaoNa");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n			\r\n		udpsent("PASS 13S...");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n		\r\n		udpsent("cwd /");\r\n		udpread();\r\n\r\n		winput();\r\n	}\r\n	public void initData(){\r\n		port = 5050;\r\n		dir = "/";\r\n		try{\r\n			client = new DatagramSocket();\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public void udpsent(String sendStr){\r\n		try {\r\n			byte[] sendBuf;\r\n			sendBuf = sendStr.getBytes();\r\n			DatagramPacket sendPacket = new DatagramPacket(sendBuf,sendBuf.length,addr,port);\r\n			client.send(sendPacket);\r\n			System.out.println("??");\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public String udpread(){\r\n		String recStr = null;\r\n		try {\r\n			byte[] recBuf = new byte[1024];\r\n			DatagramPacket recPacket = new DatagramPacket(recBuf,recBuf.length);\r\n			client.receive(recPacket);\r\n			recStr = new String(recPacket.getData(),0,recPacket.getLength());\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return recStr;\r\n	}\r\n\r\n	public void winput(){\r\n		String strin = "";\r\n		String rec = null;\r\n		while(!strin.equals("#")){\r\n			System.out.println("Please Input the command line : ");\r\n			Scanner input = new Scanner(System.in);\r\n			strin = input.nextLine();\r\n			strin = strin.toUpperCase();\r\n			switch(strin) {\r\n			case "TYPE":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "LIST":\r\n				udpsent(strin);\r\n				udpread();\r\n				rec = udpread();\r\n				String[] items = rec.split("\\r\\n");\r\n				for(int i = 0;i < items.length;i++){\r\n					if(items[i].startsWith("d")){\r\n						System.out.println("/"+items[i].substring(2)+"/");\r\n					}else {\r\n						System.out.println("/"+items[i].substring(2));\r\n					}\r\n				}\r\n				rec = udpread();\r\n				break;\r\n			case "CWD":\r\n				System.out.println("You''ve entered the cd cmdline.Please input the cmd like eg. cwd //..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				//System.out.println(rec);\r\n				break;\r\n			case "CDUP":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				//System.out.println(rec);\r\n			case "MKD":\r\n				System.out.println("You''ve entered the mkdir commandline:please input the cmd like mkd dir..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			default:\r\n				break;\r\n			}\r\n		}\r\n	}\r\n}\r\n</pre>', 'Java ftp', '', 'inherit', 'open', 'open', '', '224-revision-3', '', '', '2014-06-11 13:29:21', '2014-06-11 13:29:21', '', 224, 'http://codeseeking.sinaapp.com/?p=227', 0, 'revision', '', 0),
(228, 1, '2014-06-11 13:30:11', '2014-06-11 13:30:11', 'UDPclient\r\n<pre lang="java" colla="-">\r\npublic class TestClient{\r\n	public static void main(String[] args){\r\n		new TestClient();\r\n	}\r\n\r\n	private String dir;\r\n	private DatagramSocket client;\r\n	private String serverip = "";\r\n	private DatagramPacket initPacket;\r\n	private int port;\r\n	private InetAddress addr;\r\n\r\n	public TestClient(){\r\n		initData();\r\n		serverip = "192.168.140.6";\r\n		try {\r\n			addr = InetAddress.getByName(serverip);\r\n		} catch (UnknownHostException e) {\r\n			e.printStackTrace();\r\n		}\r\n		String rec = null;\r\n		udpsent("hello");\r\n		rec = udpread();\r\n		port = Integer.parseInt(rec);\r\n		String infostr = "port is changed to :" + rec;\r\n		System.out.println(infostr);\r\n		udpsent("USER XiaoNa");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n			\r\n		udpsent("PASS 13S...");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n		\r\n		udpsent("cwd /");\r\n		udpread();\r\n\r\n		winput();\r\n	}\r\n	public void initData(){\r\n		port = 5050;\r\n		dir = "/";\r\n		try{\r\n			client = new DatagramSocket();\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public void udpsent(String sendStr){\r\n		try {\r\n			byte[] sendBuf;\r\n			sendBuf = sendStr.getBytes();\r\n			DatagramPacket sendPacket = new DatagramPacket(sendBuf,sendBuf.length,addr,port);\r\n			client.send(sendPacket);\r\n			System.out.println("??");\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public String udpread(){\r\n		String recStr = null;\r\n		try {\r\n			byte[] recBuf = new byte[1024];\r\n			DatagramPacket recPacket = new DatagramPacket(recBuf,recBuf.length);\r\n			client.receive(recPacket);\r\n			recStr = new String(recPacket.getData(),0,recPacket.getLength());\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return recStr;\r\n	}\r\n\r\n	public void winput(){\r\n		String strin = "";\r\n		String rec = null;\r\n		while(!strin.equals("#")){\r\n			System.out.println("Please Input the command line : ");\r\n			Scanner input = new Scanner(System.in);\r\n			strin = input.nextLine();\r\n			strin = strin.toUpperCase();\r\n			switch(strin) {\r\n			case "TYPE":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "LIST":\r\n				udpsent(strin);\r\n				udpread();\r\n				rec = udpread();\r\n				String[] items = rec.split("\\r\\n");\r\n				for(int i = 0;i < items.length;i++){\r\n					if(items[i].startsWith("d")){\r\n						System.out.println("/"+items[i].substring(2)+"/");\r\n					}else {\r\n						System.out.println("/"+items[i].substring(2));\r\n					}\r\n				}\r\n				rec = udpread();\r\n				break;\r\n			case "CWD":\r\n				System.out.println("You''ve entered the cd cmdline.Please input the cmd like eg. cwd //..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				//System.out.println(rec);\r\n				break;\r\n			case "CDUP":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				//System.out.println(rec);\r\n			case "MKD":\r\n				System.out.println("You''ve entered the mkdir commandline:please input the cmd like mkd dir..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			default:\r\n				break;\r\n			}\r\n		}\r\n	}\r\n}\r\n</pre>', 'Java ftp', '', 'inherit', 'open', 'open', '', '224-revision-4', '', '', '2014-06-11 13:30:11', '2014-06-11 13:30:11', '', 224, 'http://codeseeking.sinaapp.com/?p=228', 0, 'revision', '', 0),
(229, 1, '2014-06-12 02:12:11', '2014-06-12 02:12:11', '好久不用忘记了，但是最近老是手贱撤销多次，所以必须要记住阿。\r\n<pre lang="shell" colla="+">\r\nu => 撤销\r\nCtrl + r => 撤销撤销\r\n</pre>', 'vim 撤销和撤销撤销', '', 'publish', 'open', 'open', '', 'vim-%e6%92%a4%e9%94%80%e5%92%8c%e6%92%a4%e9%94%80%e6%92%a4%e9%94%80', '', '', '2014-06-12 02:12:11', '2014-06-12 02:12:11', '', 0, 'http://codeseeking.sinaapp.com/?p=229', 0, 'post', '', 0),
(230, 1, '2014-06-12 02:11:31', '2014-06-12 02:11:31', '好久不用忘记了，但是最近老是手贱撤销多次，所以必须要记住阿。\n<pre lang="shell" colla="+">\n ', 'vim 撤销和撤销撤销', '', 'inherit', 'open', 'open', '', '229-revision', '', '', '2014-06-12 02:11:31', '2014-06-12 02:11:31', '', 229, 'http://codeseeking.sinaapp.com/?p=230', 0, 'revision', '', 0),
(231, 1, '2014-06-13 02:36:43', '2014-06-13 02:36:43', 'UDPclient，实现登录，连接，路径操作，和数据传输..虽然有点粗糙，咋也是第一个像样的java prog阿\n<pre lang="java" colla="-">\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Scanner;\n\npublic class xnClient{\n	public static void main(String[] args){\n		new xnClient();\n	}\n\n	private String dir;\n	private DatagramSocket client;\n	private String serverip = "";\n	private DatagramPacket initPacket;\n	private int port;\n	private InetAddress addr;\n\n	public xnClient(){\n		initData();\n		serverip = "192.168.140.6";\n		try {\n			addr = InetAddress.getByName(serverip);\n		} catch (UnknownHostException e) {\n			e.printStackTrace();\n		}\n		String rec = null;\n		udpsent("hello");\n		rec = udpread();\n		port = Integer.parseInt(rec);\n		String infostr = "port is changed to :" + rec;\n		System.out.println(infostr);\n		udpsent("USER -XiaoNa-");\n		rec = udpread();\n		System.out.println(rec);\n			\n		udpsent("PASS -13S103022-");\n		rec = udpread();\n		System.out.println(rec);\n		\n		udpsent("cwd /");\n		udpread();\n\n		winput();\n\n		udpsent("quit");\n		System.out.println(udpread());\n	}\n\n	public void initData(){\n		port = 5050;\n		dir = "/";\n		try{\n			client = new DatagramSocket();\n		} catch (SocketException e) {\n			e.printStackTrace();\n		}\n	}\n\n	public void udpsent(String sendStr){\n		try {\n			byte[] sendBuf;\n			sendBuf = sendStr.getBytes();\n			DatagramPacket sendPacket = new DatagramPacket(sendBuf,sendBuf.length,addr,port);\n			client.send(sendPacket);\n		} catch (SocketException e) {\n			e.printStackTrace();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	public String udpread(){\n		String recStr = null;\n		try {\n			byte[] recBuf = new byte[1024];\n			DatagramPacket recPacket = new DatagramPacket(recBuf,recBuf.length);\n			client.receive(recPacket);\n			recStr = new String(recPacket.getData(),0,recPacket.getLength());\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return recStr;\n	}\n\n	public void winput(){\n		String strin = "";\n		String rec = null;\n		while(!strin.equals("#")){\n			System.out.println("Please Input the command line : ");\n			Scanner input = new Scanner(System.in);\n			strin = input.nextLine();\n			strin = strin.toUpperCase();\n			switch(strin) {\n			case "TYPE":\n				System.out.println("You''ve entered the TYPE cmdline.Please input the cmd like eg. type A/I.");\n				strin = input.nextLine();\n				udpsent(strin);\n				rec = udpread();\n				System.out.println(rec);\n				break;\n			case "LIST":\n				udpsent(strin);\n				udpread();\n				rec = udpread();\n				String[] items = rec.split("\\r\\n");\n				for(int i = 0;i < items.length;i++){\n					if(items[i].startsWith("d")){\n						System.out.println("/"+items[i].substring(2)+"/");\n					}else {\n						System.out.println("/"+items[i].substring(2));\n					}\n				}\n				rec = udpread();\n				break;\n			case "CWD":\n				System.out.println("You''ve entered the cd cmdline.Please input the cmd like eg. cwd //..");\n				strin = input.nextLine();\n				udpsent(strin);\n				rec = udpread();\n				break;\n			case "CDUP":\n				udpsent(strin);\n				rec = udpread();\n			case "MKD":\n				System.out.println("You''ve entered the mkdir commandline.please input the cmd like mkd dir..");\n				strin = input.nextLine();\n				udpsent(strin);\n				rec = udpread();\n				System.out.println(rec);\n				break;\n			case "STOR":\n				System.out.println("You''ve entered the store file cmdline.please input the cmd like stor file..");\n				strin = input.nextLine();\n				udpsent(strin);\n				rec = udpread();\n				System.out.println(rec);\n				System.out.println("Please input the context..");\n				strin = input.nextLine();\n				udpsent(strin);\n				rec = udpread();\n				System.out.println(rec);\n				break;\n			case "DELE":\n				System.out.println("You''ve entered the del cmdline.please input the cmd like dele filename..");\n				strin = input.nextLine();\n				udpsent(strin);\n				rec = udpread();\n				System.out.println(rec);\n				break;\n			case "PWD":\n				udpsent(strin);\n				rec = udpread();\n				System.out.println(rec);\n				break;\n			case "RETR":\n				System.out.println("You''ve entered the get cmdline.please input the cmd like retr filename..");\n				strin = input.nextLine();\n				udpsent(strin);\n				rec = udpread();\n				System.out.println(rec);\n				System.out.println(udpread());\n				break;\n			default:\n				break;\n			}\n		}\n	}\n}\n</pre>\n除却这个，再发个udpserver端的吧，tcp端的就是将datagramPacket改成用一般的socket连接\n<pre lang="java" colla="-">\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.ArrayList;\n\n\npublic class udpServer {\n\n	public static void main(String[] args) {\n		new udpServer();\n	}\n	public udpServer() {\n		\n        try {\n        	DatagramSocket  server = new DatagramSocket(5050);\n        	byte[] recvBuf = new byte[1024];\n        	DatagramPacket recvPacket \n            	= new DatagramPacket(recvBuf , recvBuf.length);\n        	while(true){\n        		server.receive(recvPacket);\n                FtpHandler h = new FtpHandler(recvPacket);\n				h.start();\n        	}\n		} catch (IOException e1) {\n			e1.printStackTrace();\n		}\n\n	}\n\n	public ArrayList<FtpHandler> users = new ArrayList<FtpHandler>();\n	public static int counter = 0;\n	public static String initDir = "ftp/";\n\n	class UserInfo {\n		String user;\n		String password;\n		String workDir;\n		\n		public UserInfo(String a, String b, String c)\n		{\n			user = a;\n			password = b;\n			workDir = c;\n		}\n	}\n\n	class FtpHandler extends Thread {\n		String ServerIP = "192.168.140.6";\n\n		DatagramSocket server;\n		int port; \n		InetAddress clientAddr = null;\n		int id;\n		String cmd = ""; //the command\n		String param = ""; //parameters\n		String user;\n		String remoteHost = " "; // client''s ip\n		int remotePort = 0; // client''s tcp port\n		String dir = "/";//pwd\n		String rootdir = "/home/char/javawork/ftp-train/ftp/"; //root dir.checkPASS to set\n		int state = 0; //user''s state\n		String reply; //report of the command\n		int type = 0; //file type\n		String requestfile = "";\n		boolean isrest = false;\n\n		int sendPort;\n        InetAddress addr;\n		\n		public FtpHandler(DatagramPacket reciPacket) {\n			\n			dir = "/";\n			sendPort = reciPacket.getPort();\n			addr = reciPacket.getAddress();\n			port = getPort();\n			System.out.println(port);\n			try {\n				server = new DatagramSocket(port);\n			} catch (SocketException e) {\n				e.printStackTrace();\n			}\n			udpSend(""+port);\n		}\n\n		public void run() {\n			String str = "";\n			int parseResult; //No. of command\n\n			try {\n				state = FtpState.FS_WAIT_LOGIN; //0\n				boolean finished = false;\n				while (!finished) {\n					str = UdpRead(); // /\n					if (str == null)\n						finished = true; //jump out\n					else {\n						parseResult = parseInput(str); // cmd=>num\n						System.out.println("Command : " + cmd + " Parameter : " + param);\n						System.out.print("->");\n						switch (state) // user''s state to check what to do\n						{\n						case FtpState.FS_WAIT_LOGIN:\n							finished = commandUSER();\n							break;\n						case FtpState.FS_WAIT_PASS:\n							finished = commandPASS();\n							break;\n						case FtpState.FS_LOGIN: {\n							switch (parseResult)// key point\n							{\n							case -1:\n								errCMD(); // gramerror\n								break;\n							case 2:\n								finished = commandPASV();\n								break;\n							case 3:\n								finished = commandSYST();\n								break;\n							case 4:\n								finished = commandCDUP(); // cd ..\n								break;\n							case 6:\n								finished = commandCWD(); // cd path\n								break;\n							case 7:\n								finished = commandQUIT(); // quit\n								break;\n							case 9:\n								finished = commandPORT(); // client''s ip tcp''s port\n								break;\n							case 11:\n								finished = commandTYPE(); // file type set\n								break;\n							case 14:\n								finished = commandRETR(); // get a file from the server\n								break;\n							case 15:\n								finished = commandSTOR(); // send a file to server\n								break;\n							case 22:\n								finished = commandABOR(); // close the datasocket\n								break;\n							case 23:\n								finished = commandDELE(); // delete the file in server\n								break;\n							case 25:\n								finished = commandMKD(); // make dir\n								break;\n							case 27:\n								finished = commandLIST(); // ls\n								break;\n							case 26:\n							case 33:\n								finished = commandPWD(); // pwd\n								break;\n							case 32:\n								finished = commandNOOP(); // correct\n								break;\n\n							}\n						}\n							break;\n\n						}\n					}\n					System.out.println(reply);\n					udpSend(reply);\n\n				}\n			} catch (Exception e) {\n				System.out.println("connection reset!");\n			} \n		}\n\n		void udpSend(String sendStr)\n		{\n			try {\n\n		        byte[] sendBuf;\n		        sendBuf = sendStr.getBytes();\n		        DatagramPacket sendPacket \n		            = new DatagramPacket(sendBuf , sendBuf.length , addr , sendPort );\n		        \n				server.send(sendPacket);\n			} catch (SocketException e) {\n				e.printStackTrace();\n			}catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n		\n		String UdpRead()\n		{\n			String reciStr=null;\n	        try {\n				byte[] recvBuf = new byte[1024];\n		        DatagramPacket recvPacket \n		            = new DatagramPacket(recvBuf , recvBuf.length);\n	        	server.receive(recvPacket);\n				reciStr = new String(recvPacket.getData() , 0 , recvPacket.getLength());\n				\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n	        return reciStr;\n		}\n		\n		public int getPort() {   \n		    DatagramSocket s = null;//udp''s socket just can figure out the port udp occupy\n		    // test tht ports between two value  \n		    int MINPORT = 10000;  \n		    int MAXPORT = 65000;  \n		  \n		    for (; MINPORT < MAXPORT; MINPORT++) {  \n		  \n		        try {  \n		            s = new DatagramSocket(MINPORT);  \n		            s.close();  \n		            return MINPORT;  \n		        } catch (IOException e) {  \n		            continue;  \n		        }  \n		  \n		    }  \n		    return -1;  \n		}  \n		\n		int parseInput(String s) {\n			int p = 0;\n			int i = -1;\n			p = s.indexOf(" ");\n			if (p == -1) // no parameter\n				cmd = s;\n			else\n				cmd = s.substring(0, p); // get the param\n\n			if (p >= s.length() || p == -1)\n				param = "";\n			else\n				param = s.substring(p + 1, s.length());\n			cmd = cmd.toUpperCase(); // Upper\n\n			if(cmd.equals("PASV"))\n				i = 2;\n			if(cmd.equals("SYST"))\n				i = 3;\n			if (cmd.equals("CDUP"))\n				i = 4;\n			if (cmd.equals("CWD"))\n				i = 6;\n			if (cmd.equals("QUIT"))\n				i = 7;\n			if (cmd.equals("PORT"))\n				i = 9;\n			if (cmd.equals("TYPE"))\n				i = 11;\n			if (cmd.equals("RETR"))\n				i = 14;\n			if (cmd.equals("STOR"))\n				i = 15;\n			if (cmd.equals("ABOR"))\n				i = 22;\n			if (cmd.equals("DELE"))\n				i = 23;\n			if (cmd.equals("MKD"))\n				i = 25;\n			if (cmd.equals("PWD"))\n				i = 26;\n			if (cmd.equals("LIST"))\n				i = 27;\n			if (cmd.equals("NOOP"))\n				i = 32;\n			if (cmd.equals("XPWD"))\n				i = 33;\n			return i;\n		}\n\n		int validatePath(String s) {\n			File f = new File(s); // /...\n			if (f.exists() && !f.isDirectory()) {\n				String s1 = s.toLowerCase();\n				String s2 = rootdir.toLowerCase();\n				if (s1.startsWith(s2))\n					return 1; //the file is existed begin with rootdir\n				else\n					return 0; //the file.....without the rootdir\n			}\n			f = new File(addTail(dir) + s);// .../...\n			if (f.exists() && !f.isDirectory()) {\n				String s1 = (addTail(dir) + s).toLowerCase();\n				String s2 = rootdir.toLowerCase();\n				if (s1.startsWith(s2))\n					return 2;  \n				else\n					return 0; \n			}\n			return 0; \n		}\n\n		private boolean commandPASV() {\n			reply = "227 Entering Passive Mode ("+ServerIP+","+(port/256)+","+(port%256)+").";\n			return false;\n		}\n		\n		private boolean commandSYST() {\n			reply = "215 UNIX Type: L8";\n			return false;\n		}\n		\n		boolean commandUSER() {\n			if (cmd.equals("USER")) {\n				reply = "User name correct,Please input the password..";\n				user = param;\n				state = FtpState.FS_WAIT_PASS;\n				return false;\n			} else {\n				reply = "Param error,user name not match..";\n				return true;\n			}\n\n		}\n\n		boolean commandPASS() {\n			if (cmd.equals("PASS")) {\n				reply = "User login..";\n				state = FtpState.FS_LOGIN;\n				System.out.println("User : " + param +  "Login..");\n				System.out.print("->");\n				return false;\n			} else {\n				reply = "Param error,password is wrong..";\n				return true;\n			}\n\n		}\n\n		void errCMD() {\n			reply = "Param error";\n		}\n\n		boolean commandCDUP()// cd ..\n		{\n			File f = new File(dir);\n			if (f.getParent() != null && (!dir.equals(rootdir)))//have father path but is not root path\n			{\n				dir = f.getParent();\n				reply = "Correct..";\n			} else {\n				reply = "There is no such father path..";\n			}\n\n			return false;\n		}// commandCDUP() end\n\n		boolean commandCWD()// CWD (CHANGE WORKING DIRECTORY)\n		{ \n			if(param.equals("/"))\n				param = rootdir;\n			else if(param.startsWith("/"))\n				param = rootdir+param.substring(1, param.length());\n			File f = new File(param);\n			String s = "";\n			String s1 = "";\n			if (dir.endsWith("/"))\n				s = dir;\n			else{\n				s = dir + "/";\n			}\n			File f1 = new File(s + param);\n\n			if (f.isDirectory() && f.exists()) {\n				if (param.equals("..") || param.equals("..\\\\")) {\n					if (dir.compareToIgnoreCase(rootdir) == 0) {\n						reply = "There is no such directory..";\n						// return false;\n					} else {\n						s1 = new File(dir).getParent();\n						if (s1 != null) {\n							dir = s1;\n							reply = "Directory change to : " + dir;\n						} else\n							reply = "There is no such path..";\n					}\n				} else if (param.equals(".") || param.equals(".\\\\")) {\n				} else {\n					dir = param;\n					reply = "The directory change to : " + dir;\n				}\n			} else if (f1.isDirectory() && f1.exists()) {\n				dir = s + param;\n				reply = "The directory change to : " + dir;\n			} else\n				reply = "Param error..";\n\n			return false;\n		} // commandCDW() end\n\n		boolean commandQUIT() {\n			reply = "Service close the connection..";\n			return true;\n		}// commandQuit() end\n\n		boolean commandPORT() {\n			int p1 = 0;\n			int p2 = 0;\n			int[] a = new int[6];// store ip+tcp\n			int i = 0; //\n			try {\n				while ((p2 = param.indexOf(",", p1)) != -1)// first 5 bit\n				{\n					a[i] = Integer.parseInt(param.substring(p1, p2));\n					p2 = p2 + 1;\n					p1 = p2;\n					i++;\n				}\n				a[i] = Integer.parseInt(param.substring(p1, param.length()));// last bit\n			} catch (NumberFormatException e) {\n				reply = "Param error..";\n				return false;\n			}\n\n			remoteHost = a[0] + "." + a[1] + "." + a[2] + "." + a[3];\n			remotePort = a[4] * 256 + a[5];\n			reply = "Correct..";\n			return false;\n		}// commandPort() end\n\n		boolean commandLIST()\n		{\n\n				udpSend("Correct,ls works as ASCII..");\n							\n							File f = new File(dir);\n							System.out.println(dir);\n							String[] dirStructure = f.list();\n							String fileType;\n							String out="";\n							for (int i = 0; i < dirStructure.length; i++) {\n								if (dirStructure[i].indexOf(".") != -1) {\n									fileType = "- "; \n								} else {\n									fileType = "d "; \n								}\n								out = out + fileType + dirStructure[i] + "\\r\\n";\n							}\n							udpSend(out);\n							reply = "Data transport over...";\n\n			return false;\n		}// commandLIST() end\n\n		boolean commandTYPE() \n		{\n			if (param.equals("A")) {\n				type = FtpState.FTYPE_ASCII;// 0\n				reply = "Correct,turn to ASCII Model";\n			} else if (param.equals("I")) {\n				type = FtpState.FTYPE_IMAGE;// 1\n				reply = "Correct,turn to BINARY Model";\n			} else\n				reply = "The command can not be done..";\n\n			return false;\n		}\n\n		boolean commandRETR() {\n			String fillname = dir;\n			if(param.startsWith("/"))\n				fillname += param.substring(1);\n			else\n				fillname += param;\n			System.out.println(dir);\n			System.out.println(addTail(dir.substring(1)));\n			System.out.println(fillname);\n			requestfile = fillname;\n			File f = new File(requestfile);\n			if (!f.exists()) {\n				f = new File(fillname);\n				if (!f.exists()) {\n					reply = "The file is not existed..";\n					return false;\n				}\n			}\n			if (f.isDirectory()) {\n\n			} else {\n				if (type == FtpState.FTYPE_IMAGE) // bin\n				{\n					try {\n						udpSend("Correct.open it as binary file."\n								+ requestfile);\n						BufferedInputStream fin = new BufferedInputStream(\n								new FileInputStream(requestfile));\n						byte[] buf = new byte[1024]; // target buff\n						int l = 0;\n						String sendStr="";\n						while ((l = fin.read(buf, 0, 1024)) != -1) // buff still not full\n						{\n							sendStr = sendStr + new String(buf, 0, l);\n						}\n						udpSend(sendStr);\n						fin.close();\n						reply = "Data transport over..";\n\n					} catch (Exception e) {\n						e.printStackTrace();\n						reply = "Request failed...";\n						return false;\n					}\n\n				}\n				if (type == FtpState.FTYPE_ASCII)// ascII\n				{\n					try {\n						udpSend("Opening ASCII mode data connection for "\n										+ requestfile);\n						BufferedReader fin = new BufferedReader(new FileReader(\n								requestfile));\n						String s;\n						String sendStr="";\n						while ((s = fin.readLine()) != null) {\n							sendStr+=s; // /???\n						}\n						fin.close();\n						udpSend(sendStr);\n						reply = "The data tansport over...";\n					} catch (Exception e) {\n						e.printStackTrace();\n						reply = "The request failed..";\n						return false;\n					}\n				}\n			}\n			return false;\n\n		}\n\n		boolean commandSTOR() {\n			if (param.equals("")) {\n				reply = "Param error..";\n				return false;\n			}\n			requestfile = addTail(dir) + param;\n			if (type == FtpState.FTYPE_IMAGE)// bin\n			{\n				try {\n					udpSend("Opening Binary mode data connection for "\n									+ requestfile);\n\n					BufferedOutputStream fout = new BufferedOutputStream(\n							new FileOutputStream(requestfile));\n					byte[] buf = new byte[1024];\n					int l = 0;\n					String tmp = null;\n					/*while ((tmp = UdpRead()) != null) {\n						fout.write(tmp.getBytes(), 0, tmp.getBytes().length);\n					}*/\n					tmp = UdpRead();\n					fout.write(tmp.getBytes(), 0, tmp.getBytes().length);\n					fout.close();\n					reply = "Data transport over..";\n				} catch (Exception e) {\n					e.printStackTrace();\n					reply = "Request failed..";\n					return false;\n				}\n			}\n			if (type == FtpState.FTYPE_ASCII)// ascII\n			{\n				try {\n					udpSend("Opening ASCII mode data connection for "\n									+ requestfile);\n					PrintWriter fout = new PrintWriter(new FileOutputStream(\n							requestfile));\n					String line = UdpRead();\n					/*while ((line = UdpRead()) != null) {\n						fout.println(line);\n					}*/\n					fout.println(line);\n					fout.close();\n					reply = "The data transport over...";\n				} catch (Exception e) {\n					e.printStackTrace();\n					reply = "Request failed..";\n					return false;\n				}\n			}\n			return false;\n		}\n\n		boolean commandPWD() {\n			reply = " " + dir + "  is the pwd..";\n			return false;\n		}\n\n		boolean commandNOOP() {\n			reply = "Correct..";\n			return false;\n		}\n\n		boolean commandABOR() {\n			try {\n			} catch (Exception e) {\n				e.printStackTrace();\n				reply = "Request failed..";\n				return false;\n			}\n			reply = "Out of service,connection closed..";\n			return false;\n		}\n\n		boolean commandDELE() {\n			int i = validatePath(param);\n			if (i == 0) {\n				reply = "Request failed.No such file or dir.";\n				return false;\n			}\n			if (i == 1) {\n				File f = new File(param);\n				f.delete();\n			}\n			if (i == 2) {\n				File f = new File(addTail(dir) + param);\n				f.delete();\n			}\n\n			reply = "Request done.file deleted..";\n			return false;\n\n		}\n\n		boolean commandMKD() {\n			String s1 = param.toLowerCase();\n			String s2 = rootdir.toLowerCase();\n			if (s1.startsWith(s2)) {\n				File f = new File(param);\n				if (f.exists()) {\n					reply = "Dir is existed..";\n					return false;\n				} else {\n					f.mkdirs();\n					reply = "Dir build done..";\n				}\n			} else {\n				File f = new File(addTail(dir) + param);\n				if (f.exists()) {\n					reply = "Dir is existed..";\n					return false;\n				} else {\n					f.mkdirs();\n					reply = "Dir building done..";\n				}\n			}\n\n			return false;\n		}\n\n		String addTail(String s) {\n			if (!s.endsWith("/"))\n				s = s + "/";\n			return s;\n		}\n\n	}\n\n	class FtpState {\n		final static int FS_WAIT_LOGIN = 0; // wait for user name.\n		final static int FS_WAIT_PASS = 1; // wait for the password.\n		final static int FS_LOGIN = 2; // Login in..\n\n		final static int FTYPE_ASCII = 0;\n		final static int FTYPE_IMAGE = 1;\n		final static int FMODE_STREAM = 0;\n		final static int FMODE_COMPRESSED = 1;\n		final static int FSTRU_FILE = 0;\n		final static int FSTRU_PAGE = 1;\n	}\n}\n</pre>', 'Java ftp', '', 'inherit', 'open', 'open', '', '224-autosave', '', '', '2014-06-13 02:36:43', '2014-06-13 02:36:43', '', 224, 'http://codeseeking.sinaapp.com/?p=231', 0, 'revision', '', 0),
(232, 1, '2014-06-11 13:32:30', '2014-06-11 13:32:30', 'UDPclient，只写了几种需要特别说明的功能，如cd mkdir等。持续更新，java相较还是挺好写的，就是长阿长长啊长\r\n<pre lang="java" colla="-">\r\npublic class TestClient{\r\n	public static void main(String[] args){\r\n		new TestClient();\r\n	}\r\n\r\n	private String dir;\r\n	private DatagramSocket client;\r\n	private String serverip = "";\r\n	private DatagramPacket initPacket;\r\n	private int port;\r\n	private InetAddress addr;\r\n\r\n	public TestClient(){\r\n		initData();\r\n		serverip = "192.168.140.6";\r\n		try {\r\n			addr = InetAddress.getByName(serverip);\r\n		} catch (UnknownHostException e) {\r\n			e.printStackTrace();\r\n		}\r\n		String rec = null;\r\n		udpsent("hello");\r\n		rec = udpread();\r\n		port = Integer.parseInt(rec);\r\n		String infostr = "port is changed to :" + rec;\r\n		System.out.println(infostr);\r\n		udpsent("USER XiaoNa");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n			\r\n		udpsent("PASS 13S...");\r\n		rec = udpread();\r\n		System.out.println(rec);\r\n		\r\n		udpsent("cwd /");\r\n		udpread();\r\n\r\n		winput();\r\n	}\r\n	public void initData(){\r\n		port = 5050;\r\n		dir = "/";\r\n		try{\r\n			client = new DatagramSocket();\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public void udpsent(String sendStr){\r\n		try {\r\n			byte[] sendBuf;\r\n			sendBuf = sendStr.getBytes();\r\n			DatagramPacket sendPacket = new DatagramPacket(sendBuf,sendBuf.length,addr,port);\r\n			client.send(sendPacket);\r\n			System.out.println("??");\r\n		} catch (SocketException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n\r\n	public String udpread(){\r\n		String recStr = null;\r\n		try {\r\n			byte[] recBuf = new byte[1024];\r\n			DatagramPacket recPacket = new DatagramPacket(recBuf,recBuf.length);\r\n			client.receive(recPacket);\r\n			recStr = new String(recPacket.getData(),0,recPacket.getLength());\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return recStr;\r\n	}\r\n\r\n	public void winput(){\r\n		String strin = "";\r\n		String rec = null;\r\n		while(!strin.equals("#")){\r\n			System.out.println("Please Input the command line : ");\r\n			Scanner input = new Scanner(System.in);\r\n			strin = input.nextLine();\r\n			strin = strin.toUpperCase();\r\n			switch(strin) {\r\n			case "TYPE":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			case "LIST":\r\n				udpsent(strin);\r\n				udpread();\r\n				rec = udpread();\r\n				String[] items = rec.split("\\r\\n");\r\n				for(int i = 0;i < items.length;i++){\r\n					if(items[i].startsWith("d")){\r\n						System.out.println("/"+items[i].substring(2)+"/");\r\n					}else {\r\n						System.out.println("/"+items[i].substring(2));\r\n					}\r\n				}\r\n				rec = udpread();\r\n				break;\r\n			case "CWD":\r\n				System.out.println("You''ve entered the cd cmdline.Please input the cmd like eg. cwd //..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				//System.out.println(rec);\r\n				break;\r\n			case "CDUP":\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				//System.out.println(rec);\r\n			case "MKD":\r\n				System.out.println("You''ve entered the mkdir commandline:please input the cmd like mkd dir..");\r\n				strin = input.nextLine();\r\n				udpsent(strin);\r\n				rec = udpread();\r\n				System.out.println(rec);\r\n				break;\r\n			default:\r\n				break;\r\n			}\r\n		}\r\n	}\r\n}\r\n</pre>', 'Java ftp', '', 'inherit', 'open', 'open', '', '224-revision-5', '', '', '2014-06-11 13:32:30', '2014-06-11 13:32:30', '', 224, 'http://codeseeking.sinaapp.com/?p=232', 0, 'revision', '', 0),
(234, 1, '2014-06-13 08:46:48', '2014-06-13 08:46:48', '命令历史\n\n以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。\n启动vim\n\n在命令行窗口中输入以下命令即可\n\nvim 直接启动vim\n\nvim filename 打开vim并创建名为filename的文件\n文件命令\n\n打开单个文件\n\nvim file\n\n同时打开多个文件\n\nvim file1 file2 file3 ...\n\n在vim窗口中打开一个新文件\n\n:open file\n\n在新窗口中打开文件\n\n:split file\n\n切换到下一个文件\n\n:bn\n\n切换到上一个文件\n\n:bp\n\n查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。\n\n:args\n\n打开远程文件，比如ftp或者share folder\n\n:e ftp://192.168.10.76/abc.txt\n\n:e \\\\qadrive\\test\\1.txt\nvim的模式\n\n正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空\n插入模式（按i键进入） 左下角显示--INSERT--\n可视模式（不知道如何进入） 左下角显示--VISUAL--\n导航命令\n\n% 括号匹配\n插入命令\n\ni 在当前位置生前插入\n\nI 在当前行首插入\n\na 在当前位置后插入\n\nA 在当前行尾插入\n\no 在当前行之后插入一行\n\nO 在当前行之前插入一行\n查找命令\n\n/text　　查找text，按n健查找下一个，按N健查找前一个。\n\n?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。\n\nvim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$\n\n:set ignorecase　　忽略大小写的查找\n\n:set noignorecase　　不忽略大小写的查找\n\n查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。\n\n:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。\n\n:set nohlsearch　　关闭高亮搜索显示\n\n:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。\n\n:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。\n\n:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。\n替换命令\n\nra 将当前字符替换为a，当期字符即光标所在字符。\n\ns/old/new/ 用old替换new，替换当前行的第一个匹配\n\ns/old/new/g 用old替换new，替换当前行的所有匹配\n\n%s/old/new/ 用old替换new，替换所有行的第一个匹配\n\n%s/old/new/g 用old替换new，替换整个文件的所有匹配\n\n:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。\n\nddp 交换光标所在行和其下紧邻的一行。\n移动命令\n\nh 左移一个字符\nl 右移一个字符，这个命令很少用，一般用w代替。\nk 上移一个字符\nj 下移一个字符\n以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。\n\nw 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。\n\nb 向后移动一个单词 2b 向后移动2个单词\n\ne，同w，只不过是光标停在单词尾部\n\nge，同b，光标停在单词尾部。\n\n^ 移动到本行第一个非空白字符上。\n\n0（数字0）移动到本行第一个字符上，\n\n<HOME> 移动到本行第一个字符。同0健。\n\n$ 移动到行尾 3$ 移动到下面3行的行尾\n\ngg 移动到文件头。 = [[\n\nG（shift + g） 移动到文件尾。 = ]]\n\nf（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。\n\nF 同f，反向查找。\n\n跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。\n\nCtrl + e 向下滚动一行\n\nCtrl + y 向上滚动一行\n\nCtrl + d 向下滚动半屏\n\nCtrl + u 向上滚动半屏\n\nCtrl + f 向下滚动一屏\n\nCtrl + b 向上滚动一屏\n撤销和重做\n\nu 撤销（Undo）\nU 撤销对整行的操作\nCtrl + r 重做（Redo），即撤销的撤销。\n删除命令\n\nx 删除当前字符\n\n3x 删除当前光标开始向后三个字符\n\nX 删除当前字符的前一个字符。X=dh\n\ndl 删除当前字符， dl=x\n\ndh 删除前一个字符\n\ndd 删除当前行\n\ndj 删除上一行\n\ndk 删除下一行\n\n10d 删除当前行开始的10行。\n\nD 删除当前字符至行尾。D=d$\n\nd$ 删除当前字符之后的所有字符（本行）\n\nkdgg 删除当前行之前所有行（不包括当前行）\n\njdG（jd shift + g）   删除当前行之后所有行（不包括当前行）\n\n:1,10d 删除1-10行\n\n:11,$d 删除11行及以后所有的行\n\n:1,$d 删除所有行\n\nJ(shift + j)　　删除两行之间的空行，实际上是合并两行。\n拷贝和粘贴\n\nyy 拷贝当前行\n\nnyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。\n\np  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。\n\nshift+p 在当前行前粘贴\n\n:1,10 co 20 将1-10行插入到第20行之后。\n\n:1,$ co $ 将整个文件复制一份并添加到文件尾部。\n\n正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制\n\nddp交换当前行和其下一行\n\nxp交换当前字符和其后一个字符\n剪切命令\n\n正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切\n\nndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴\n\n:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。\n\n:1, 10 m 20 将第1-10行移动到第20行之后。\n退出命令\n\n:wq 保存并退出\n\nZZ 保存并退出\n\n:q! 强制退出并忽略所有更改\n\n:e! 放弃所有修改，并打开原来文件。\n窗口命令\n\n:split或new 打开一个新窗口，光标停在顶层的窗口上\n\n:split file或:new file 用新窗口打开文件\n\nsplit打开的窗口都是横向的，使用vsplit可以纵向打开窗口。\n\nCtrl+ww 移动到下一个窗口\n\nCtrl+wj 移动到下方的窗口\n\nCtrl+wk 移动到上方的窗口\n\n关闭窗口\n\n:close 最后一个窗口不能使用此命令，可以防止意外退出vim。\n\n:q 如果是最后一个被关闭的窗口，那么将退出vim。\n\nZZ 保存并退出。\n\n关闭所有窗口，只保留当前窗口\n\n:only\n\n录制宏\n\n按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。\n执行shell命令\n\n:!command\n\n:!ls 列出当前目录下文件\n\n:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。\n\n:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。\n\n:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。\n注释命令\n\nperl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#\n\n3,5 s/^/#/g 注释第3-5行\n\n3,5 s/^#//g 解除3-5行的注释\n\n1,$ s/^/#/g 注释整个文档。\n\n:%s/^/#/g 注释整个文档，此法更快。\n帮助命令\n\n:help or F1 显示整个帮助\n:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。\n:help ''number'' Vim选项的帮助用单引号括起\n:help <Esc> 特殊键的帮助用<>扩起\n:help -t Vim启动参数的帮助用-\n：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式\n帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回\n其他非编辑命令\n\n. 重复前一次命令\n\n:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看\n\n:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。\n\n:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:>-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。\n\nVim教程\n在Unix系统上\n$ vimtutor\n在Windows系统上\n:help tutor\n\n:syntax 列出已经定义的语法项\n:syntax clear 清除已定义的语法规则\n:syntax case match 大小写敏感，int和Int将视为不同的语法元素\n:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案', '', '', 'inherit', 'open', 'open', '', '233-revision', '', '', '2014-06-13 08:46:48', '2014-06-13 08:46:48', '', 233, 'http://codeseeking.sinaapp.com/?p=234', 0, 'revision', '', 0);
INSERT INTO `wp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`) VALUES
(235, 1, '2014-06-13 08:46:55', '2014-06-13 08:46:55', '命令历史\r\n\r\n以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。\r\n启动vim\r\n\r\n在命令行窗口中输入以下命令即可\r\n\r\nvim 直接启动vim\r\n\r\nvim filename 打开vim并创建名为filename的文件\r\n文件命令\r\n\r\n打开单个文件\r\n\r\nvim file\r\n\r\n同时打开多个文件\r\n\r\nvim file1 file2 file3 ...\r\n\r\n在vim窗口中打开一个新文件\r\n\r\n:open file\r\n\r\n在新窗口中打开文件\r\n\r\n:split file\r\n\r\n切换到下一个文件\r\n\r\n:bn\r\n\r\n切换到上一个文件\r\n\r\n:bp\r\n\r\n查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。\r\n\r\n:args\r\n\r\n打开远程文件，比如ftp或者share folder\r\n\r\n:e ftp://192.168.10.76/abc.txt\r\n\r\n:e \\\\qadrive\\test\\1.txt\r\nvim的模式\r\n\r\n正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空\r\n插入模式（按i键进入） 左下角显示--INSERT--\r\n可视模式（不知道如何进入） 左下角显示--VISUAL--\r\n导航命令\r\n\r\n% 括号匹配\r\n插入命令\r\n\r\ni 在当前位置生前插入\r\n\r\nI 在当前行首插入\r\n\r\na 在当前位置后插入\r\n\r\nA 在当前行尾插入\r\n\r\no 在当前行之后插入一行\r\n\r\nO 在当前行之前插入一行\r\n查找命令\r\n\r\n/text　　查找text，按n健查找下一个，按N健查找前一个。\r\n\r\n?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。\r\n\r\nvim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$\r\n\r\n:set ignorecase　　忽略大小写的查找\r\n\r\n:set noignorecase　　不忽略大小写的查找\r\n\r\n查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。\r\n\r\n:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。\r\n\r\n:set nohlsearch　　关闭高亮搜索显示\r\n\r\n:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。\r\n\r\n:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。\r\n\r\n:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。\r\n替换命令\r\n\r\nra 将当前字符替换为a，当期字符即光标所在字符。\r\n\r\ns/old/new/ 用old替换new，替换当前行的第一个匹配\r\n\r\ns/old/new/g 用old替换new，替换当前行的所有匹配\r\n\r\n%s/old/new/ 用old替换new，替换所有行的第一个匹配\r\n\r\n%s/old/new/g 用old替换new，替换整个文件的所有匹配\r\n\r\n:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。\r\n\r\nddp 交换光标所在行和其下紧邻的一行。\r\n移动命令\r\n\r\nh 左移一个字符\r\nl 右移一个字符，这个命令很少用，一般用w代替。\r\nk 上移一个字符\r\nj 下移一个字符\r\n以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。\r\n\r\nw 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。\r\n\r\nb 向后移动一个单词 2b 向后移动2个单词\r\n\r\ne，同w，只不过是光标停在单词尾部\r\n\r\nge，同b，光标停在单词尾部。\r\n\r\n^ 移动到本行第一个非空白字符上。\r\n\r\n0（数字0）移动到本行第一个字符上，\r\n\r\n<HOME> 移动到本行第一个字符。同0健。\r\n\r\n$ 移动到行尾 3$ 移动到下面3行的行尾\r\n\r\ngg 移动到文件头。 = [[\r\n\r\nG（shift + g） 移动到文件尾。 = ]]\r\n\r\nf（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。\r\n\r\nF 同f，反向查找。\r\n\r\n跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。\r\n\r\nCtrl + e 向下滚动一行\r\n\r\nCtrl + y 向上滚动一行\r\n\r\nCtrl + d 向下滚动半屏\r\n\r\nCtrl + u 向上滚动半屏\r\n\r\nCtrl + f 向下滚动一屏\r\n\r\nCtrl + b 向上滚动一屏\r\n撤销和重做\r\n\r\nu 撤销（Undo）\r\nU 撤销对整行的操作\r\nCtrl + r 重做（Redo），即撤销的撤销。\r\n删除命令\r\n\r\nx 删除当前字符\r\n\r\n3x 删除当前光标开始向后三个字符\r\n\r\nX 删除当前字符的前一个字符。X=dh\r\n\r\ndl 删除当前字符， dl=x\r\n\r\ndh 删除前一个字符\r\n\r\ndd 删除当前行\r\n\r\ndj 删除上一行\r\n\r\ndk 删除下一行\r\n\r\n10d 删除当前行开始的10行。\r\n\r\nD 删除当前字符至行尾。D=d$\r\n\r\nd$ 删除当前字符之后的所有字符（本行）\r\n\r\nkdgg 删除当前行之前所有行（不包括当前行）\r\n\r\njdG（jd shift + g）   删除当前行之后所有行（不包括当前行）\r\n\r\n:1,10d 删除1-10行\r\n\r\n:11,$d 删除11行及以后所有的行\r\n\r\n:1,$d 删除所有行\r\n\r\nJ(shift + j)　　删除两行之间的空行，实际上是合并两行。\r\n拷贝和粘贴\r\n\r\nyy 拷贝当前行\r\n\r\nnyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。\r\n\r\np  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。\r\n\r\nshift+p 在当前行前粘贴\r\n\r\n:1,10 co 20 将1-10行插入到第20行之后。\r\n\r\n:1,$ co $ 将整个文件复制一份并添加到文件尾部。\r\n\r\n正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制\r\n\r\nddp交换当前行和其下一行\r\n\r\nxp交换当前字符和其后一个字符\r\n剪切命令\r\n\r\n正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切\r\n\r\nndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴\r\n\r\n:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。\r\n\r\n:1, 10 m 20 将第1-10行移动到第20行之后。\r\n退出命令\r\n\r\n:wq 保存并退出\r\n\r\nZZ 保存并退出\r\n\r\n:q! 强制退出并忽略所有更改\r\n\r\n:e! 放弃所有修改，并打开原来文件。\r\n窗口命令\r\n\r\n:split或new 打开一个新窗口，光标停在顶层的窗口上\r\n\r\n:split file或:new file 用新窗口打开文件\r\n\r\nsplit打开的窗口都是横向的，使用vsplit可以纵向打开窗口。\r\n\r\nCtrl+ww 移动到下一个窗口\r\n\r\nCtrl+wj 移动到下方的窗口\r\n\r\nCtrl+wk 移动到上方的窗口\r\n\r\n关闭窗口\r\n\r\n:close 最后一个窗口不能使用此命令，可以防止意外退出vim。\r\n\r\n:q 如果是最后一个被关闭的窗口，那么将退出vim。\r\n\r\nZZ 保存并退出。\r\n\r\n关闭所有窗口，只保留当前窗口\r\n\r\n:only\r\n\r\n录制宏\r\n\r\n按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。\r\n执行shell命令\r\n\r\n:!command\r\n\r\n:!ls 列出当前目录下文件\r\n\r\n:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。\r\n\r\n:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。\r\n\r\n:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。\r\n注释命令\r\n\r\nperl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#\r\n\r\n3,5 s/^/#/g 注释第3-5行\r\n\r\n3,5 s/^#//g 解除3-5行的注释\r\n\r\n1,$ s/^/#/g 注释整个文档。\r\n\r\n:%s/^/#/g 注释整个文档，此法更快。\r\n帮助命令\r\n\r\n:help or F1 显示整个帮助\r\n:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。\r\n:help ''number'' Vim选项的帮助用单引号括起\r\n:help <Esc> 特殊键的帮助用<>扩起\r\n:help -t Vim启动参数的帮助用-\r\n：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式\r\n帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回\r\n其他非编辑命令\r\n\r\n. 重复前一次命令\r\n\r\n:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看\r\n\r\n:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。\r\n\r\n:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:>-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。\r\n\r\nVim教程\r\n在Unix系统上\r\n$ vimtutor\r\n在Windows系统上\r\n:help tutor\r\n\r\n:syntax 列出已经定义的语法项\r\n:syntax clear 清除已定义的语法规则\r\n:syntax case match 大小写敏感，int和Int将视为不同的语法元素\r\n:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案', '', '', 'inherit', 'open', 'open', '', '233-revision-2', '', '', '2014-06-13 08:46:55', '2014-06-13 08:46:55', '', 233, 'http://codeseeking.sinaapp.com/?p=235', 0, 'revision', '', 0);

-- --------------------------------------------------------

--
-- 表的结构 `wp_terms`
--

CREATE TABLE IF NOT EXISTS `wp_terms` (
  `term_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) NOT NULL DEFAULT '',
  `slug` varchar(200) NOT NULL DEFAULT '',
  `term_group` bigint(10) NOT NULL DEFAULT '0',
  PRIMARY KEY (`term_id`),
  UNIQUE KEY `slug` (`slug`),
  KEY `name` (`name`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=52 ;

--
-- 转存表中的数据 `wp_terms`
--

INSERT INTO `wp_terms` (`term_id`, `name`, `slug`, `term_group`) VALUES
(1, '随笔', '%e7%ac%94%e8%ae%b0', 0),
(2, '链接表', '%e9%93%be%e6%8e%a5%e8%a1%a8', 0),
(8, '娱乐', '%e7%8e%a9', 0),
(7, '随想', '%e6%83%85%e6%84%9f', 0),
(6, '笔记', 'code', 0),
(9, 'Java', 'java', 0),
(10, 'C++', 'c', 0),
(11, 'Perl', 'perl', 0),
(12, 'JavaScript', 'javascript', 0),
(13, 'Asp', 'asp', 0),
(14, '音乐', '%e9%9f%b3%e4%b9%90', 0),
(15, '电影', '%e7%94%b5%e5%bd%b1', 0),
(16, 'JavaScript', 'js', 0),
(17, 'ASP', 'asp-2', 0),
(18, '感慨', '%e6%84%9f%e6%85%a8', 0),
(19, 'sqlserver', 'sqlserver', 0),
(20, '随笔', '%e9%9a%8f%e7%ac%94', 0),
(21, 'lua', 'lua', 0),
(22, 'linux', 'linux', 0),
(23, 'linux bmp', 'linux-bmp', 0),
(24, '位操作', '%e4%bd%8d%e6%93%8d%e4%bd%9c', 0),
(25, 'linux vim', 'linux-vim', 0),
(26, '混沌', '%e6%b7%b7%e6%b2%8c', 0),
(27, '混沌加密', '%e6%b7%b7%e6%b2%8c%e5%8a%a0%e5%af%86', 0),
(28, 'github', 'github', 0),
(29, 'Eigen', 'eigen', 0),
(30, 'ndct', 'ndct', 0),
(31, 'python', 'python', 0),
(32, '正则', '%e6%ad%a3%e5%88%99', 0),
(33, 'VIM', 'vim', 0),
(34, '数据结构', '%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84', 0),
(35, 'MLearning', 'mlearning', 0),
(36, 'python', 'python-code', 0),
(37, 'pyhton', 'pyhton', 0),
(38, 'ubuntu', 'ubuntu', 0),
(39, 'shell', 'shell', 0),
(40, 'NLP', 'nlp', 0),
(41, 'KG', 'kg', 0),
(42, 'yeild', 'yeild', 0),
(43, 'yield', 'yield', 0),
(44, 'vim', 'vim-2', 0),
(45, 'terminal', 'terminal', 0),
(46, 'dict', 'dict', 0),
(47, 'HMM', 'hmm', 0),
(48, 'ftp', 'ftp', 0),
(49, 'java', 'java-linux', 0),
(50, 'java', 'java-2', 0),
(51, 'udp', 'udp', 0);

-- --------------------------------------------------------

--
-- 表的结构 `wp_term_relationships`
--

CREATE TABLE IF NOT EXISTS `wp_term_relationships` (
  `object_id` bigint(20) unsigned NOT NULL DEFAULT '0',
  `term_taxonomy_id` bigint(20) unsigned NOT NULL DEFAULT '0',
  `term_order` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`object_id`,`term_taxonomy_id`),
  KEY `term_taxonomy_id` (`term_taxonomy_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `wp_term_relationships`
--

INSERT INTO `wp_term_relationships` (`object_id`, `term_taxonomy_id`, `term_order`) VALUES
(1, 2, 0),
(2, 2, 0),
(1, 1, 0),
(5, 1, 0),
(17, 18, 0),
(10, 6, 0),
(17, 7, 0),
(19, 17, 0),
(19, 13, 0),
(19, 19, 0),
(19, 6, 0),
(25, 17, 0),
(25, 6, 0),
(25, 13, 0),
(33, 17, 0),
(33, 6, 0),
(33, 13, 0),
(38, 17, 0),
(38, 6, 0),
(38, 13, 0),
(38, 16, 0),
(195, 32, 0),
(3, 1, 0),
(3, 20, 0),
(48, 14, 0),
(50, 21, 0),
(50, 6, 0),
(58, 10, 0),
(58, 6, 0),
(58, 22, 0),
(60, 1, 0),
(60, 23, 0),
(63, 22, 0),
(63, 6, 0),
(67, 6, 0),
(65, 6, 0),
(67, 10, 0),
(72, 6, 0),
(72, 10, 0),
(86, 24, 0),
(86, 6, 0),
(86, 10, 0),
(89, 25, 0),
(89, 6, 0),
(92, 27, 0),
(92, 26, 0),
(92, 6, 0),
(92, 10, 0),
(100, 1, 0),
(100, 7, 0),
(108, 28, 0),
(102, 26, 0),
(102, 6, 0),
(105, 26, 0),
(105, 6, 0),
(105, 10, 0),
(108, 26, 0),
(108, 6, 0),
(108, 10, 0),
(141, 26, 0),
(110, 26, 0),
(110, 29, 0),
(116, 26, 0),
(116, 6, 0),
(116, 10, 0),
(118, 30, 0),
(118, 26, 0),
(118, 6, 0),
(118, 10, 0),
(123, 31, 0),
(123, 26, 0),
(123, 6, 0),
(123, 10, 0),
(126, 1, 0),
(110, 33, 0),
(128, 7, 0),
(131, 6, 0),
(131, 10, 0),
(138, 26, 0),
(138, 32, 0),
(141, 34, 0),
(141, 32, 0),
(147, 36, 0),
(143, 26, 0),
(143, 35, 0),
(147, 26, 0),
(147, 32, 0),
(147, 37, 0),
(48, 1, 0),
(48, 38, 0),
(165, 41, 0),
(195, 26, 0),
(163, 39, 0),
(165, 26, 0),
(165, 32, 0),
(165, 6, 0),
(165, 40, 0),
(168, 42, 0),
(168, 26, 0),
(168, 6, 0),
(168, 43, 0),
(171, 6, 0),
(171, 44, 0),
(171, 45, 0),
(173, 37, 0),
(173, 26, 0),
(173, 32, 0),
(173, 6, 0),
(173, 40, 0),
(173, 46, 0),
(179, 37, 0),
(179, 26, 0),
(179, 32, 0),
(179, 6, 0),
(179, 40, 0),
(179, 47, 0),
(181, 48, 0),
(181, 26, 0),
(181, 35, 0),
(181, 6, 0),
(181, 49, 0),
(181, 22, 0),
(181, 42, 0),
(195, 50, 0),
(195, 6, 0),
(195, 40, 0),
(195, 37, 0),
(201, 37, 0),
(201, 26, 0),
(201, 32, 0),
(201, 6, 0),
(201, 44, 0),
(201, 40, 0),
(201, 51, 0),
(218, 52, 0),
(208, 26, 0),
(208, 32, 0),
(213, 26, 0),
(213, 35, 0),
(218, 10, 0),
(224, 54, 0),
(224, 26, 0),
(224, 53, 0),
(224, 6, 0),
(224, 9, 0),
(224, 52, 0),
(224, 55, 0),
(233, 1, 0),
(229, 26, 0),
(229, 35, 0);

-- --------------------------------------------------------

--
-- 表的结构 `wp_term_taxonomy`
--

CREATE TABLE IF NOT EXISTS `wp_term_taxonomy` (
  `term_taxonomy_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `term_id` bigint(20) unsigned NOT NULL DEFAULT '0',
  `taxonomy` varchar(32) NOT NULL DEFAULT '',
  `description` longtext NOT NULL,
  `parent` bigint(20) unsigned NOT NULL DEFAULT '0',
  `count` bigint(20) NOT NULL DEFAULT '0',
  PRIMARY KEY (`term_taxonomy_id`),
  UNIQUE KEY `term_id_taxonomy` (`term_id`,`taxonomy`),
  KEY `taxonomy` (`taxonomy`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=56 ;

--
-- 转存表中的数据 `wp_term_taxonomy`
--

INSERT INTO `wp_term_taxonomy` (`term_taxonomy_id`, `term_id`, `taxonomy`, `description`, `parent`, `count`) VALUES
(1, 1, 'category', '', 0, 4),
(2, 2, 'link_category', '', 0, 7),
(9, 9, 'category', '', 6, 1),
(8, 8, 'category', '', 0, 0),
(7, 7, 'category', '', 0, 3),
(6, 6, 'category', '', 0, 29),
(10, 10, 'category', '', 6, 12),
(11, 11, 'category', '', 6, 0),
(12, 12, 'category', '', 6, 0),
(13, 13, 'category', '', 6, 4),
(14, 14, 'category', '', 8, 1),
(15, 15, 'category', '', 8, 0),
(16, 16, 'post_tag', '', 0, 1),
(17, 17, 'post_tag', '', 0, 4),
(18, 18, 'post_tag', '', 0, 1),
(19, 19, 'post_tag', '', 0, 1),
(20, 20, 'post_tag', '', 0, 0),
(21, 21, 'post_tag', '', 0, 1),
(22, 22, 'post_tag', '', 0, 3),
(23, 23, 'post_tag', '', 0, 1),
(24, 24, 'post_tag', '', 0, 1),
(25, 25, 'post_tag', '', 0, 1),
(26, 22, 'category', '', 0, 23),
(27, 26, 'post_tag', '', 0, 1),
(28, 27, 'post_tag', '', 0, 1),
(29, 28, 'post_tag', '', 0, 1),
(30, 29, 'post_tag', '', 0, 1),
(31, 30, 'post_tag', '', 0, 0),
(32, 31, 'category', '', 22, 9),
(33, 28, 'category', '', 22, 1),
(34, 32, 'category', '', 22, 1),
(35, 33, 'category', '', 22, 4),
(36, 34, 'post_tag', '', 0, 1),
(37, 31, 'post_tag', '', 0, 5),
(38, 14, 'post_tag', '', 0, 1),
(39, 35, 'category', '', 0, 1),
(40, 36, 'category', '', 6, 5),
(41, 37, 'post_tag', '', 0, 1),
(42, 38, 'post_tag', '', 0, 2),
(43, 39, 'post_tag', '', 0, 1),
(44, 40, 'category', '', 6, 2),
(45, 41, 'post_tag', '', 0, 1),
(46, 42, 'post_tag', '', 0, 1),
(47, 43, 'post_tag', '', 0, 1),
(48, 44, 'post_tag', '', 0, 1),
(49, 45, 'post_tag', '', 0, 1),
(50, 46, 'post_tag', '', 0, 1),
(51, 47, 'post_tag', '', 0, 1),
(52, 48, 'post_tag', '', 0, 2),
(53, 49, 'category', '', 22, 1),
(54, 50, 'post_tag', '', 0, 1),
(55, 51, 'post_tag', '', 0, 1);

-- --------------------------------------------------------

--
-- 表的结构 `wp_usermeta`
--

CREATE TABLE IF NOT EXISTS `wp_usermeta` (
  `umeta_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) unsigned NOT NULL DEFAULT '0',
  `meta_key` varchar(255) DEFAULT NULL,
  `meta_value` longtext,
  PRIMARY KEY (`umeta_id`),
  KEY `user_id` (`user_id`),
  KEY `meta_key` (`meta_key`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=41 ;

--
-- 转存表中的数据 `wp_usermeta`
--

INSERT INTO `wp_usermeta` (`umeta_id`, `user_id`, `meta_key`, `meta_value`) VALUES
(1, 1, 'first_name', ''),
(2, 1, 'last_name', ''),
(3, 1, 'nickname', 'cc'),
(4, 1, 'description', ''),
(5, 1, 'rich_editing', 'true'),
(6, 1, 'comment_shortcuts', 'false'),
(7, 1, 'admin_color', 'fresh'),
(8, 1, 'use_ssl', '0'),
(9, 1, 'show_admin_bar_front', 'true'),
(10, 1, 'show_admin_bar_admin', 'false'),
(11, 1, 'aim', ''),
(12, 1, 'yim', ''),
(13, 1, 'jabber', ''),
(14, 1, 'wp_capabilities', 'a:1:{s:13:"administrator";s:1:"1";}'),
(15, 1, 'wp_user_level', '10'),
(38, 2, 'wp_dashboard_quick_press_last_post_id', '134'),
(17, 1, 'managenav-menuscolumnshidden', 'a:4:{i:0;s:11:"link-target";i:1;s:11:"css-classes";i:2;s:3:"xfn";i:3;s:11:"description";}'),
(18, 1, 'metaboxhidden_nav-menus', 'a:2:{i:0;s:8:"add-post";i:1;s:12:"add-post_tag";}'),
(19, 1, 'wp_user-settings', 'editor=html&m6=c&m1=c&m2=c&m3=c&m4=c&m7=c&m8=c&m9=c&hidetb=1'),
(20, 1, 'wp_user-settings-time', '1402024670'),
(21, 1, 'plugins_last_view', 'all'),
(22, 2, 'first_name', 'charley'),
(23, 2, 'last_name', 'cheng'),
(24, 2, 'nickname', 'charlley88'),
(25, 2, 'description', ''),
(26, 2, 'rich_editing', 'true'),
(27, 2, 'comment_shortcuts', 'false'),
(28, 2, 'admin_color', 'fresh'),
(29, 2, 'use_ssl', '0'),
(30, 2, 'show_admin_bar_front', 'true'),
(31, 2, 'show_admin_bar_admin', 'false'),
(32, 2, 'aim', ''),
(33, 2, 'yim', ''),
(34, 2, 'jabber', ''),
(35, 2, 'wp_capabilities', 'a:1:{s:13:"administrator";s:1:"1";}'),
(36, 2, 'wp_user_level', '10'),
(37, 1, 'wp_dashboard_quick_press_last_post_id', '185'),
(39, 1, 'closedpostboxes_dashboard', 'a:0:{}'),
(40, 1, 'metaboxhidden_dashboard', 'a:0:{}');

-- --------------------------------------------------------

--
-- 表的结构 `wp_users`
--

CREATE TABLE IF NOT EXISTS `wp_users` (
  `ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `user_login` varchar(60) NOT NULL DEFAULT '',
  `user_pass` varchar(64) NOT NULL DEFAULT '',
  `user_nicename` varchar(50) NOT NULL DEFAULT '',
  `user_email` varchar(100) NOT NULL DEFAULT '',
  `user_url` varchar(100) NOT NULL DEFAULT '',
  `user_registered` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `user_activation_key` varchar(60) NOT NULL DEFAULT '',
  `user_status` int(11) NOT NULL DEFAULT '0',
  `display_name` varchar(250) NOT NULL DEFAULT '',
  PRIMARY KEY (`ID`),
  KEY `user_login_key` (`user_login`),
  KEY `user_nicename` (`user_nicename`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

--
-- 转存表中的数据 `wp_users`
--

INSERT INTO `wp_users` (`ID`, `user_login`, `user_pass`, `user_nicename`, `user_email`, `user_url`, `user_registered`, `user_activation_key`, `user_status`, `display_name`) VALUES
(1, 'cc', '$P$Bluy9ZbVnLAg.nM5c1DGJF9KHTtxBe/', 'cc', 'charleytemp@163.com', '', '2012-10-15 06:34:06', 'AFElQpIEYHRIOxCxYDlc', 0, 'cc'),
(2, 'charlley88', '$P$B0wWaQgDnNrtqWjitgMa6GWDI/zvI8.', 'charlley88', 'charlley88@163.com', '', '2013-02-08 12:20:36', 'r60pioel3hUy3nZD1xwk', 0, 'charlley88');
